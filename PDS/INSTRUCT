./ ADD NAME=$$README 0101-02141-02141-1422-00080-00232-00000-BC0THOR
***********************************************************************
* INSTRUCT library: Contains detailed instructions for use of some of *
*                the programs that need more than a quick description *
*                in the program source code and/or execution JCL. A   *
*                short description of each member is shown below.     *
*                                                                     *
***********************************************************************
ABAL      .Instructions for the ABAL program in FILE 558.
ABEND878  .An information APAR made by IBM to aid in debugging S878,
           S80A, and other out-of-storage problems, such as S106-0C
ALOCDYN1  .Instructions for calling subroutine ALLOCDYN in FILE 558 from
           an assembler language program.
ALOCDYN2  .Instructions for calling subroutine ALLOCDYN in FILE 558 from
           a COBOL program.
CHRDUMP   .Instructions for program chrdump in FILE 558.
COBOL2    .Note to programmers concerning our use of COBOL II compile
           parameters.
COB2ASM   .Instructions for the COB2ASM program in FILE 558.
COMPASM   .Instructions for the COMPASM program in FILE 558.
COPYDUMP  .Instructions for the COPYDUMP program in FILE 558.
COPYMULT  .Instructions for the COPYMULT program in FILE 558.
DASDIO    .Note on using TMONMVS to display DASD I/O data.
DDLIST    .Instructions for the DDLIST program in FILE 558.
DISASM    .Instructions for the DISASM0/DISASM1/DISASM2 disassembler
           in FILE 558.
DUMPFIL   .Instructions for using program DUMPFIL in FILE 558.
DYNALOC1  .Instructions for calling the DYNALOC program in FILE 558 from
           an assembler language program.
DYNALOC2  .Instructions for calling the DYNALOC program in FILE 558 from
           a COBOL program.
DYNERRS   .Documentation for the DYNERRS assembler message table in
           FILE 558.
ENQLIST   .Instructions for the ENQLIST program in FILE 558.
EXCHANGE  .Instructions for using program EXCHANGE in FILE 558.
EXCPIO    .Instructions for calling the EXCPIO subroutine in FILE 558.
FINDMAC   .Use instructions for the FINDMAC program in FILE 558.
FINDSUBR  .Instructions for the FINDSUBR program in FILE 558.
GENLDAT1  .COBOL program calling instructions for the GENLDAT2 sub-
           routine in file 558.
GENLDAT2  .Assembler program calling instructions for the GENLDAT2 sub-
           routine in file 558.
GETGDG    .Calling instructions for the GETGDG subroutine in FILE 558.
ILBCHECK  .Use instructions for the ILBCHECK program in FILE 558.
IPCS      .Notes on using the IBM program IPCS for viewing dumps.
IPOUPDTE  .IBM IPO instructions for the IBM utility IPOUPDTE.
JOBINFO   .Calling instructions for the JOBINFO subroutine in FILE 558.
LIBPRNT   .Instructions for using the LIBPRNT program in FILE 558.
LSTVTOC   .Instructions for using the LSTVTOC1, LSTVTOC2, and LSTVTOC3
           programs in FILE 558.
MODSCB    .Instructions for using the MODSCB program in FILE 558.
MODXREF   .Usage for the MODXREF program in FILE 558.
PDSPGMS   .Short descriptions of a number of programs in FILE 558 that
           process PDS's.
PDSREAD   .Instructions for calling the PDSREAD subroutine in FILE 558.
PRNTMULT  .Use instructions for the PRNTMULT program in FILE 558.
PRTPCH    .Instructions for using program PRTPCH in FILE 558.
QWIKVTOC  .Usage instructions for the QWIKVTOC program in FILE 558.
RCVRPDS   .How to use the RCVRPDS program in FILE 558.
READDIR   .Calling instructions for the READDIR subroutine in FILE 558.
READMEM   .Calling instructions for the READMEM subroutine in FILE 558.
RENSCR    .Using the RENSCR program in FILE 558.
RMFINST   .Notes on using IBM's RMF Monitor III
SIRTSO    .Usage for an old IBM system monitor called SIT or SIRTSO
SMODE     .Coding instructions for use of the SMODE macro in FILE 558.
SRBINST   .Describes the use of the macros BCBLDSRB, BCGETRTN, BCSRBFRE
           BCSRBDEF, BCSRBENT, and BCSRBPST, in scheduling and writing
           routines.
TAKETEST  .Tips for taking tests (not computer related).
TRACE     .An APAR made by IBM to describe the GETMAIN/FREEMAIN trace
           facility built into the operating system. This provides a
           much more complete trace than does GTF tracing of SVC's,
           since many storage requests are done by branch entry, and
           will not be seen by GTF SVC traces.
TRACEBR   .Notes on tracing wild branches using SLIP and GTF.
UPDMEM    .calling instructions for the subroutine UPDMEM in FILE 558.
VI        .Simplified instructions for using the VI editor in the AIX
           operating system or other UNIX-based operating systems.
VOLLIST2  .Instructions for the VOLLIST2 program in FILE 558.
WAITASEC  .Using the WAITASEC program on FILE 558.
WHEREAMI  .Usage instructions for the WHEREAMI subroutine on FILE 558.
./ ADD NAME=ABAL     0100-92167-92167-1458-00064-00064-00000-USER02
*                 *** INSTRUCTIONS FOR ABAL ***
*
*     ABAL IS A REFORMATTING TOOL FOR ASSEMBLER LANGUAGE SOURCE
* PROGRAMS. THE INPUT DATASET IS SCANNED FOR LABELS, MNEMONICS,
* OPERANDS, AND COMMENTS, WHICH MAY BE ENTERED FREE-FORM. OUTPUT
* WILL CONTAIN THE SAME INFORMATION, WITH LABELS BEGINNING IN COLUMN
* 1, MNEMONIC IN COLUMN 10, OPERANDS IN COLUMN 16, AND COMMENTS IN
* COLUMN 40. CONTENT OF COLUMNS 73-80 IS UNCHANGED ON OUTPUT.  IN
* ADDITION, ALL EXPLICIT REGISTER REFERENCES WILL BE OUTPUT WITH
* THE LETTER 'R' PRECEDING THE REGISTER NUMBER.
*
*     ALTHOUGH THE INPUT IS RELATIVELY FREE-FORM, CERTAIN CONVENTIONS
* MUST BE OBSERVED. THESE ARE:
*  (1) LABELS MUST BEGIN IN COLUMN 1. ANYTHING BEGINNING IN COLUMN 1
*      WILL BE TREATED AS A LABEL, WHETHER IT IS, OR NOT.
*  (2) IF COLUMN 72 CONTAINS A CHARACTER ON INPUT, IT WILL BE RETAINED
*      ON OUTPUT.
*  (3) COMMENTS WILL BE RIGHT-ADJUSTED TO BEGIN IN COLUMN 40. ANY EXCESS
*      BEYOND COLUMN 71 WILL BE TRUNCATED WITHOUT WARNING.
*  (4) THE 'LOGICAL OR' SYMBOL (|) MAY BE USED TO EFFECT A CONTINUATION
*      OF A MACRO PARAMETER STRING. WHEN USED, IT MUST BE AT LEAST 1
*      SPACE TO THE RIGHT OF THE LAST PRECEDING CHARACTER ON THE LINE,
*      AND THE REMAINDER OF THE LINE MUST BE BLANK. WHEN THIS SYMBOL IS
*      FOUND, THE LABEL, MNEMONIC, AND OPERANDS ARE ALIGNED TO COLUMNS
*      1,10,16, AS ABOVE, AND AN 'X' IS PLACED IN COLUMN 72. ANY EXCESS
*      OPERAND BEYOND COLUMN 72 WILL BE TRUNCATED WITHOUT WARNING. THE
*      FOLLOWING CARD WILL BE TREATED AS A CONTINUATION CONTAINING ONLY
*      MACRO OPERANDS, AND WILL BE ADJUSTED TO BEGIN IN COLUMN 16.
*  (5) WHEN ANY ERROR IS FOUND, THE INPUT IS COPIED TO OUTPUT WITHOUT
*      CHANGE, EXCEPT THAT '*/' WILL BE PLACED IN COLUMNS 70-71 ON THE
*      OUTPUT RECORD.
*  (6) A PARM FIELD IS AVAILABLE TO CAUSE THE OUTPUT TO CONTAIN A DOT
*      (PERIOD) IN COLUMN 40 OF EACH OUTPUT RECORD WHICH CONTAINS NO
*      COMMENT. THIS MAY EASE ADDITION OF COMMENTS USING TSO EDIT.
*
*
*
*
*
*     A CLIST EXISTS FOR USE OF ABAL. TO USE THE CLIST, ENTER:
*               ABAL SSSSSSSS
* IN THE FORMAT, SSSSSSSS IS THE NAME OF A DATASET WHOSE QUALIFIER
* MUST BE ASM, AND WHICH IS CATALOGUED UNDER YOUR USER ID.
* THE CLIST RENAMES YOUR .ASM DATASET TO .TEXT, ALLOCATES A NEW
* .ASM DATASET WITH THE SAME NAME AS THE ORIGINAL ONE HAD, THEN
* READS THE .TEXT DATASET AND PRODUCES A NEW .ASM DATASET. ON
* COMPLETION, BOTH DATASETS ARE AVAILABLE. IF THE .TEXT DATASET
* ALREADY EXISTS FROM A PREVIOUS ABAL, THE CLIST WILL FAIL.
*
*
*
*     MEMBER ABAL ON SYS1.CLIST CONTAINS THE FOLLOWING COMMANDS:
*
*   PROC  1 NAME
*   CHGUNIT SYSTS
*   REN &NAME..ASM &NAME..TEXT
*   FREE F(INPUT1 OUTPUT1 DUM)
*   ALLOC F(INPUT1) DA(&NAME..TEXT) SHR
*   ALLOC F(DUM) DUMMY B(6160)
*   ALLOC F(OUTPUT1) DA(&NAME..ASM) NEW SP(6,3) TRACKS USING(DUM) -
*         RELEASE
*   CALL 'SYS1.LINKLIB(BAL)'
*   FREE F(INPUT1 OUTPUT1 DUM)
*   END
./ ADD NAME=ABEND878 0100-91360-91360-1330-00405-00405-00000-USER02
 FOLLOWING IS AN INFO-TYPE APAR MADE BY IBM TO AID IN DEBUGGING S878,
 S80A, AND OTHER OUT-OF-STORAGE PROBLEMS, SUCH AS S106-0C

  APAR Identifier ...... II05506      Last Changed ........ 91/12/18

  HOW TO DEBUG ABEND878 / ABEND80A RC4 RC8 RC0C RCC RC10
  ABEND106 RC0C / RCC   5752SC1CH  IGVVSERR

  PROBLEM SUMMARY:
    THE FOLLOWING IS A WAY TO DEBUG ABEND80A / ABEND878 (OUT
    OF STORAGE CONDITIONS).  YOU WILL NEED A DUMP OF THE
    ABEND TO PURSUE.

    1.  TO FIND THE FAILING GETMAIN REQUEST (THE LAST ONE THAT
        WAS ATTEMPTED--REMEMBER THIS GETMAIN IS NOT ALWAYS THE
        CULPRIT, IT CAN BE THE VICTIM OF SOMEONE ELSE EATING
        UP STORAGE) YOU CAN EITHER:

     A. FIND MESSAGE IEA705I (MSGIEA705I) IN THE SYSLOG OUTPUT.
        THE MESSAGE IS FORMATTED IN THE MESSAGES MANUAL.
        THE MESSAGE CONTAINS THE CURRENT ASCB ADDRESS,
        THE DISPATCHED AND INPUTTED TCB ADDRESS, AS WELL
        AS THE SUBPOOL NUMBER AND HOW MANY BYTES THE REQUEST
        WAS FOR.  PLEASE SEE THE MESSAGE MANUAL TO DEBUG.

     B. LOCATED IN THE DUMP IS AN AREA IN THE ENUCLEUS THAT
        VSM PLACES AN UNFORMATTED COPY OF THE MSGIEA705I.
        TO FIND THE LAST GETMAIN REQUESTED, DO THE FOLLOWING
        ON IPCS:

       1. FORMAT THE 'CVT' CONTROL BLOCK BY GOING TO THE
          COMMAND PANEL AND ENTERING 'CVTMAP'
          (FOR MVS/XA) OR 'CBF CVT' (FOR ESA).

       2. AT OFFSET X'10C' INTO THE CVT IS A FIELD CALLED 'QMSG'.
          THIS FIELD POINTS TO AN AREA IN THE EXTENDED NUCLEUS
          THAT VSM USES AS A SAVE AREA FOR ERROR CONDITIONS.  GO
          TO THIS ADDRESS IN THE DUMP.

       3. THE QMSG AREA HAS 'NO' EYECATCHERS, SO YOU
          MUST BE SURE THAT YOU ARE AT THE PROPER LOCATION.
          THE QMSG AREA IS LAID OUT IN THE FOLLOWING MANNER:

    +X'0'=ADDRESS OF NEXT MESSAGE AREA TO BE USED

    +X'C'=REG14 FROM CALLER (IN CASE OF BRANCH ENTRY TO VSM,
                          THIS IS THE CALLER OF VSM)

    +X'12'=ABEND CODE (878, 80A, B78...)

    +X'14'=REASON CODE (10,14,04...)

    +X'15'=FLAGS (DETERMINE IF THIS IS GM OR FM AND SVC OR
           BRANCH ENTRY:

           X'00'=SVC GETMAIN
           X'40'=SVC FREEMAIN
           X'80'=BRANCH ENTRY GETMAIN
           X'C0'=BRANCH ENTRY FREEMAIN

    +X'18'=ASCB ADDRESS OF ASID THAT WAS IN CONTROL AT TIME
           OF REQUEST.

    +X'1C'=THE DISPATCHED TCB ADDRESS

    +X'20'=THE TCB ADDRESS THAT WAS INPUTTED (PASSED) TO VSM .

           (THIS MAY BE DIFFERENT FROM THE DISPATCHED TCB ADDRESS
            IF THE REQUEST WAS A BRANCH ENTRY)

    +X'24'=SUBPOOL NUMBER

    +X'26'=INTERNAL VSM FLAGS (SEE THE MESSAGES MANUAL UNDER
           MSGIEA705I FOR FLAG MEANINGS)

    +X'28'-X'30'= VARIABLE INFORMATION ... MAY BE DIFFERENT
           DEPENDING ON THE FAILURE...SEE THE MSGIEA705I
           INFORMATION IN THE MESSAGES MANUAL FOR THE MEANINGS
           OF THESE FIELDS FOR EACH ABEND DESCRIBED.

    NOW YOU NEED TO DETERMINE IF THE ABEND/CONDITION INDICATE
    A GLOBAL (SQA/CSA) SHORTAGE OR LOCAL (ASID) SHORTAGE.
    GLOBAL DEBUGGING IS GONE THROUGH HERE FIRST, LOCAL
    DEBUGGING FOLLOWS THE CSA DEBUGGING TIPS.

    GLOBAL DEBUGGING:

    ***********************************************************
    * NOTE, YOU NEED TO REMEMBER THAT ONCE THE 'SQA' STORAGE
    IS FILLED, SQA OVERFLOWS INTO CSA.  THIS GOES FOR ABOVE
    THE LINE ALSO, ONCE ESQA FILLS UP, IT OVERFLOWS INTO ECSA.
    SO AN SQA SHORTAGE, MAY ALSO TURN INTO A CSA SHORTAGE IF
    ALL OF THE CSA STORAGE IS EATEN UP BY SQA OVERFLOW.  *
    ***********************************************************

       1.  MAKE SURE YOU HAVE EITHER AN SVCDUMP OF THE ABEND OR
           A SADUMP, HOWEVER A SADUMP TAKEN AFTER THE FACT MAY
           NOT BE OF USE, BECAUSE MANY JOBS/TASKS MAY HAVE BEEN
           ALREADY BROUGHT DOWN AND STORAGE CLEANED UP.

       2.  I WILL GO THROUGH THE STEPS ON HOW TO DEBUG USING IPCS,
           IF YOU ARE NOT USING IPCS, PRINT VSMDATA AND PURSUE
           BY HAND.

       3.  GO TO THE COMMAND PANEL ON IPCS AND
           ENTER THE FOLLOWING COMMAND:  'VERBX VSMDATA'

       4.  DO A FIND ON "GDA", THIS IS THE
           GLOBAL DATA AREA, AND THERE IS ONE PER SYSTEM.

           THE GDA+

           X'6C'= CSA  = START OF CSA (BELOW THE LINE)

           X'70'= CSASZ= SIZE OF CSA (BELOW THE LINE)

           X'7C'= ECSA = START OF ECSA (ABOVE THE LINE)

           X'80'= ECSAS= SIZE OF ECSA (ABOVE THE LINE)

       * ->X'8C'= CSACV= THE AMOUNT OF CSA AND/OR ECSA THAT
                  HAS BEEN 'CONVERTED' INTO SQA (OVERFLOW AMOUNT)

           X'90'= SQA  = START OF SQA (BELOW THE LINE)

           X'94'= SQASZ= SIZE OF SQA  (BELOW THE LINE)

           X'98'= ESQA = START OF ESQA (ABOVE THE LINE)

           X'9C'= ESQAS= SIZE OF ESQA  (ABOVE THE LINE)

       * ->CSACV (X'8C') IS A CRITICAL FIELD WHEN DEBUGGING A
           POSSIBLE SQA STORAGE SHORTAGE PROBLEM.   THIS FIELD
           WILL BE NON-ZERO IF THERE IS A POSSIBLE SQA STORAGE
           SHORTAGE PROBLEM.  PROCEED WITH THE FOLLOWING IF
           THERE IS AN SQA STORAGE SHORTAGE PROBLEM:

       5.  DO A FIND ON X'*****' (5 ASTERISKS). EACH TIME YOU
           FIND THIS, YOU WILL FIND THE FOLLOWING MSG: "THE
           AMOUNT OF VIRTUAL STORAGE ALLOCATED TO SUBPOOL X  IS
           XXXX"  WRITE THE TOTALS DOWN.

           THERE ARE 3 SQA SUBPOOLS:
           SP226 (USUALLY USED FOR IOS CONTROL BLOCKS) IS STORAGE
           THAT RESIDES BELOW THE LINE ONLY.  THIS SUBPOOL IS
           USUALLY RELATIVELY  SMALL (X'20000'-X'30000' BYTES).
           SP239 (SUBPOOL IS LARGER THAN SP226) IS USED BY MANY
           PRODUCTS AND STORAGE CAN BE EITHER ABOVE OR
           OR BELOW THE LINE.

           SP245 IS USUALLY THE LARGEST SQA SUBPOOL. AGAIN, THIS
           SUBPOOL IS USED BY MANY PRODUCTS.
           IF YOU CANNOT TELL WHICH SUBPOOL IS THE ONE THAT IS
           ABNORMALLY LARGE, YOU MAY NEED TO TAKE A COMPARISON
           DUMP TO TELL WHAT THE SUBPOOLS ARE NORMALLY LIKE. DO YO
           HAVE AN 'OLD' DUMP WHEN THE SUBPOOLS WERE NOT LARGE?  W
           MAY NEED TO RESORT TO HAVING YOU TAKE A CONSOLE DUMP
           OF AN ASID (MAKING SURE SQA/CSA ARE DUMPED) TO
           COMPARE THE SUBPOOL SIZES IF WE CANNOT TELL WHERE THE
           ABNORMAL GROWTH IS.   IF YOU HAVE ISOLATED THE SUBPOOL,
           THEN CONTINUE TO THE NEXT STEP:

       6.  THE MESSAGE 'THE AMOUNT OF VIRTUAL STORAGE ALLOCATED
           TO SUBPOOL XXX IS XXXXXXXX' FOLLOWS THE CONTROL BLOCKS
           THAT REPRESENT THIS STORAGE.  TO GET TO THE TOP OF THE
           DATA FOR THE SUBPOOL, FIND:
           F 'SUBPOOL XXX' PREV     WHERE THE SUBPOOL NUMBER
           CORRESPONDS TO THE SUBPOOL THAT YOU ARE INTERESTED IN.
           THIS WILL GET YOU BACK TO THE START OF THE VSM CONTROL
           BLOCKS THAT REPRESENT THIS SUBPOOL.

       7.  THE STORAGE FOR SQA IS REPRESENTED BY AQATS.
           FIRST GET THE STARTING ADDRESS OF THE 64K REPRESENTED
           BY THE AQAT.  THEN GO TO THE FAR RIGHT, AND OBTAIN THE
           ALLOCATION BITS.  THE BITS ARE A HEX REPRESENTATION
           OF A BIT MAP.  IN MAPPING OUT THE BITS, REMEMBER
           THAT THERE ARE 16 PAGES IN 64K, AND THERE ARE 16
           BITS REPRESENTED BY THE MAP.  TO MAP OUT THE
           ALLOCATED PAGES YOU NEED TO DO THE FOLLOWING:
           OBTAIN THE FIRST AQAT STARTING ADDRESS AND THE
           CORRESPONDING ALLOCATION BITS (EXAMPLE):

           STARTING ADDRESS=E40000     ALLOCATION BITS=2345
           ALLOCATION BITS MAP TO:     0010 0011 0100 0101

           YOU NEED TO NUMBER EACH
           BIT FROM LEFTMOST:          0123 4567 89AB CDEF

           EACH 'ON' BIT, REPRESENTS A PAGE IN USE, IE:
           IN THE PRECEDING EXAMPLE, BIT2 IS ON, SO THE
           2 PAGE IS IN USE.  USING THE START ADDRESS OF X'E40000'
           THE PAGE AT X'E4 2000' IS IN USE,
           BIT 6 IS ALSO ON, SO THE PAGE AT X'E46000' IS IN USE.
           BIT 7 IS ALSO ON, SO THE PAGE AT X'E47000' IS IN USE.
           BIT 9 IS ALSO ON, SO THE PAGE AT X'E49000' IS IN USE.
           AND SO ON...

       8.  TO FIND OUT IF THERE IS ANY FREE STORAGE ON THE
           PAGES SHOWN TO BE IN USE, FIND:
           'ADDRESS QUEUE ORDER'
           THIS WILL GET THEM TO A SECTION UNDERNEATH THE AQAT'S
           CALLED: "DOUBLE FREE ELEMENTS IN ADDRESS QUEUE ORDER
           FOLLOW" .   THE DFE'S ARE ARRANGED IN ASCENDING ORDER
           OF ADDRESS OF FREE STORAGE.   THERE ARE TWO FIELDS
           THAT ARE IMPORTANT:
           AREA (THE START OF THE FREE STORAGE)
           SIZE (THE SIZE OF THE FREE STORAGE)
           GO DOWN THE AREA FIELD UNTIL YOU SEE A NON-ZERO AREA.
           THE AREA COMBINED WITH THE SIZE WILL BE THE START AND
           END OF THE FREE STORAGE.   MAP THIS OUT, BECAUSE YOU
           WILL NEED TO NOTE WHAT IS FREE AS OPPOSED TO WHAT IS
           GETMAINED IN STORAGE AT THIS TIME.

       9.  AFTER YOU HAVE MAPPED OUT MANY OF THE GETMAINED/
           FREEMAINED AREAS OF STORAGE, GO RANDOMLY THROUGH
           THE GETMAINED AREAS IN THE DUMP, LOOKING
           FOR SIMILARITIES IN THE EYECATCHERS IN THE
           GETMAINED AREAS.   IF YOU CANNOT FIND ANY
           SIMILARITIES, YOU MAY NEED TO DO ONE OF THE
           FOLLOWING:

           1.   TAKE A DUMP WHEN THE STORAGE UTILIZATION IS NORMAL
                AND USE THIS TO COMPARE WITH THE HIGH UTILIZATION
                DUMP TO SEE WHAT THE DIFFERENCE IN THE STORAGE
                GETMAINED IS.

           2.   TURN ON THE GETMAIN/FREEMAIN TRACE.

     ---------------------------------------------------
    | C O M M O N  S E R V I C E   A R E A    (CSA)     |
    | __________________________________________________|

    1.  IF THE RETURN CODE DENOTES A CSA PROBLEM, THE
        FOLLOWING SHOULD BE USED TO DEBUG:

    2.  FROM THE TOP OF THE VSMDATA FORMAT (GDA), DO A
        FIND ON:
        'C O M M O N'
        THIS WILL FIND THE 'COMMON SERVICE AREA' WHICH IS THE
        CSA SECTION OF VSMDATA.

    3.  THE FIRST CONTROL BLOCKS FOUND ARE
        FREE BLOCK QUEUE ELEMENTS (FBQE)
        THESE CONTROL BLOCKS ARE PRECEDED BY A 'DUMMY' FBQE
        THAT STARTS WITH "+0 FBQEF ...." AND THE ENTIRE LINE
        OF DATA ON THIS LINE SHOULD BE IGNORED.
        IF THERE IS ANY FREE STORAGE IN ECSA/CSA, THERE
        WILL BE 'FREE BLOCK QUEUE ELEMENTS' LISTED AFTER
        THE DUMMY FBQE.
        IMPORTANT FBQE FIELDS:
        SIZE XXXXXXXX  THE SIZE OF THE FREE CONTIGUOUS STORAGE
        AREA XXXXXXXX  THE STARTING ADDRESS OF THE FREE STORAGE
        IF THE CUSTOMER IS OUT OF CSA, CHANCES ARE
        THERE WON'T BE MANY FBQE'S LISTED.

    4.  FROM HERE, YOU WILL NEED TO MAP OUT EACH SUBPOOL AND
        KEY TO FIND OUT WHO MAY BE EATING UP THE CSA.
        TO FIND EACH SUBPOOL/KEY, HAVE THE CUSTOMER DO A FIND
        ON '*****'.  EACH TIME THEY FIND IT, IT WILL STATE:

        "THE AMOUNT OF VIRTUAL STORAGE ALLOCATED TO SUBPOOL XXX
        KEY XX IS XXXXXXXX"  . WHAT YOU NEED IS THE SUBPOOL,
        THE KEY AND THE AMOUNT OF STORAGE ALLOCATED TO EACH ONE.
        ONCE ALL OF THE CSA SUBPOOLS ARE MAPPED OUT, NOW
        DISCUSS WITH THE CUSTOMER WHICH SUBPOOL LOOKS ABNORMALLY
        LARGE.

    5.  ONCE YOU FIND THE ABNORMALLY LARGE SUBPOOL, YOU NEED
        TO START WITH THE TOP OF THE DATA FOR THAT SUPBOOL (AS
        THE MESSAGE IS AT THE BOTTOM OF THE DATA).

    6.  THE STORAGE IS REPRESENTED BY CONTROL BLOCKS CALLED
        DQE'S AND FQE'S.   EACH DQE DESCRIBES STORAGE ON PAGE
        BOUNDRIES, THE FQE (IF THERE IS ONE) CHAINED TO THE
        DQE SHOWS HOW MUCH OF THE DQE STORAGE IS FREE.

    7.  DQE FIELDS OF IMPORTANCE:
        AREA  XXXXXXXX      THE STARTING ADDRESS OF THE STORAGE
        SIZE  XXXXXXXX      THE SIZE OF THE STORAGE REPRESENTED

    8.  FQE FIELDS OF IMPORTANCE:
        AREA  XXXXXXXX  THE STARTING ADDRESS OF THE FREE STORAGE
        SIZE  XXXXXXXX  THE SIZE OF THE FREE STORAGE

    9.  AFTER MAPPING OUT MANY (RANDOMLY SOMETIMES WORKS)
        DQE/FQE PAIRS, GO INTO STORAGE LOOKING FOR EYECATCHERS.

   10.  LOOK FOR A PATTERN OR EXCESSIVE AMOUNT OF EYECATCHERS.

   11.  IF YOU ARE UNABLE TO FIND A PATTERN, YOU MAY WISH TO
        ASK IBM FOR ASSISTANCE.  YOU MAY NEED TO TAKE ANOTHER
        DUMP OR TURN ON THE GETMAIN / FREEMAIN TRACE.

  ****************************************************************
          L O C A L  (ASID) RELATED DEBUGGING
  ****************************************************************
  IF THE ABEND/REASON CODE INDICATES A PROBLEM WITH VIRTUAL
  STORAGE USAGE IN THE ASID, THE FOLLOWING STEPS NEED TO BE
  TAKEN TO FIND OUT WHERE THE PROBLEM RESIDES:
    1.  HAVE THE CUSTOMER FORMAT OUT THE VSMDATA.

    2.  FIND THE WORD 'LOCAL'
        THIS WILL BE IN THE FOLLOWING STRING OF WORDS:
        "VSM LOCAL DATA AREA (LDA) AT ADDRESS XXXXXXXX"
        IF THE LDA CANNOT BE ACCESSED, THE DUMP DID NOT CONTAIN
        LSQA FOR THE ASID THAT HAD THE STORAGE PROBLEM.

    3.  THE 'LDA' IS THE VSM ANCHOR CONTROL BLOCK FOR ASID'S.
        THERE IS 1 LDA PER ASID.

    4.  THE FOLLOWING FIELDS NEED TO BE OBTAINED EACH TIME
        AN ASID RELATED STORAGE PROBLEM IS DETECTED:

        LDA+
        X'3C'= LDASTRTA  (THE STARTING ADDRESS OF THE PRIVATE AREA

        X'40'= LDASIZA   (THE SIZE OF THE ENTIRE PRIVATE AREA)

        X'4C'= LDAESTRA  (THE STARTING ADDRESS OF EPRIVATE AREA)

        X'50'= LDAESIZA  (THE SIZE OF THE ENTIRE EPRIVATE AREA)

        X'98'= LDACRGTP  (THE CURRENT TOP OF THE REGION (ADDRESS))

        X'9C'= LDAERGTP  (THE CURRENT TOP OF THE EREGION (ADDRESS)

        X'CC'= LDAREGRQ  (THE REGION SIZE REQUESTED BY JOB)

        X'D0'= LDALIMIT  (THE IEALIMIT VALUE FOR BELOW THE LINE)

        X'D4'= LDAVVRG   (THE ADJUSTED REGION SIZE REQUESTED)

        X'D8'= LDAELIM   (THE IEALIMIT VALUE FOR ABOVE THE LINE)

        X'DC'= LDAEVVRG  (THE ADJUSTED EREGION SIZE REQUESTED)

    5.  FIND 'FBQEF' . THIS IS GOING TO BE FOUND
        JUST AFTER 'ADDRESS SPACE REGION DESCRIPTOR DATA
        FOLLOWS'.   THE FBQEF IS ON A 'DUMMY' LINE, AND THIS
        ENTIRE LINE CAN BE IGNORED.
        HOWEVER, IF THERE IS ANY FREE CONTIGUOUS STORAGE IN THE
        ADDRESS SPACE, THERE WILL BE:

        'FREE BLOCK QUEUE ELEMENTS' LISTED UNDERNEATH THIS LINE.
        EACH FBQE REPRESENTS STORAGE ON PAGE BOUNDRIES THAT IS
        FREE.
        THE TWO IMPORTANT FIELDS ARE:
        SIZE (THE SIZE OF THE FREE STORAGE)
        AREA (THE STARTING ADDRESS OF THE FREE STORAGE)

    6.  ONCE ALL OF THIS DATA IS GATHERED, MAP OUT THE STORAGE
        ALLOCATED/FREE BY DRAWING A BOX AND FILLING IN THE
        APPLICABLE ADDRESSES DENOTING WHAT THE ADDRESS SPACE
        LOOKS LIKE AT THIS POINT IN TIME.

    7.  THE NEXT STEP IS TO CORRELATE THIS WITH THE ACTUAL
        OUT OF STORAGE CONDITION THAT IS OCCURRING.
        FOR EXAMPLE, IS THE OUT OF STORAGE CONDITION CAUSED BY
        A LACK OF FREE STORAGE IN THE 'HIGH PRIVATE AREA SUBPOOLS'
        (LSQA/SP229/230/236/237)?   IF SO, WHY?   DOES A SUBPOOL
        HAVE ALL OF THE AVAILABLE STORAGE ALLOCATED TO THEM?
        OR, DOES THE REGION ITSELF HAVE ALL OF THE ALLOCATED
        STORAGE, THUS SQUEEZING OUT THE HIGH PRIVATE SUBPOOLS.

     *** SOMETIMES THIS IS VERY DIFFICULT TO DETERMINE, AND DO NOT
         HESITATE TO CALL LVL2 TO ASSIST ***

    8.  ONCE THE AREA WHERE THE STORAGE PROBLEM HAS BEEN DETERMINE
        (USER REGION VS HIGH PRIVATE), YOU WILL NEED TO GO TO THE
        SUBPOOLS TO FIND OUT WHICH ONE HAS THE STORAGE ALLOCATED T
        IT.

    9.  IF THE PROBLEM IS DETERMINED TO BE THAT A SUBPOOL
        IN THE HIGH PRIVATE AREA HAS EATEN UP ALL OF THE AVAILABLE
        STORAGE, YOU WILL NEED TO GO BACKWARDS IN THE VSMDATA
        TO FIND THE AMOUNT OF STORAGE ALLOCATED TO SP255 (LSQA).
        DO A "F '*****' PREV " .  THIS WILL TAKE THE
        CURSOR BACKWARDS TO FIND THE AMOUNT OF STORAGE ALLOCATED
        TO SP255.
        (THE NORMAL ALLOCATION IN SP255 IS APROXIMATELY X'10000'
        TO X'1F000'.  IF LSQA LOOKS LIKE IT IS ABNORMALLY HIGH,
        YOU WILL NEED TO INTERROGATE THE AQATS/DFE'S IN THE SAME
        MANNER AS YOU WOULD FOR SQA (SEE THE BREAKDOWN OF
        AQAT/DFE IN THE SQA DEBUGGING).

   10.  IF IT IS DETERMINED THAT IT IS NOT LSQA THAT IS CAUSING TH
        STORAGE SHORTAGE SITUATION, HAVE THE CUSTOMER DO REPEAT
        FINDS ON '*****'.   VSM WILL FORMAT OUT THE REST OF THE
        SUBPOOLS UNDER THE TCB THAT WAS CURRENT AT THE TIME OF
        THE GETMAIN INSTRUCTION,  SO YOU WILL FIND MULTIPLES OF
        EACH SUBPOOL.

   11.  YOU WILL NEED TO WRITE EACH AMOUNT DOWN, AND THEN DETERMIN
        WHICH SUBPOOL LOOKS ABNORMALLY LARGE.   ONCE THE SUBPOOL
        IS DETERMINED, YOU WILL NEED TO FIND OUT WHAT THE ALLOCATE
        STORAGE IS COMPRISED OF.

   12.  MAP OUT THE DQE/FQE'S IN THE SAME MANNER AS FOR A CSA
        STORAGE SITUATION (SEE THE CSA DEBUGGING FOR THE MAPPING
        OF DQE/FQE'S) AND GO INTO THE ALLOCATED STORAGE LOOKING
        FOR EYECATCHERS.

   13.  IF NO EYECATCHER IS EVIDENT, YOU MAY NEED TO TURN
        ON THE GM/FM TRACE FOR THE APPLICABLE SUBPOOLS.  SEE
        APAR OY19890 FOR MORE DETAILS ON THE TRACE.
./ ADD NAME=ALOCDYN1 0102-92045-94025-1047-00282-00281-00000-USER02
          ***** ALLOCDYN  SUBROUTINE *****

         ***** ASSEMBLER INSTRUCTIONS *****
         ***** SEE ALOCDYN2 FOR COBOL *****

 THE ALLOCDYN SUBROUTINE IS USED TO ALLOCATE A FILE TO A PROGRAM
 DURING EXECUTION, WITHOUT THE USE OF A DD CARD IN THE EXECUTION
 JCL. THE USER FILLS IN DESIRED DD CARD INFORMATION IN A PARAMETER
 FIELD, AND CALLS THE ALLOCDYN SUBROUTINE, PASSING THE DD CARD
 INFORMATION AND A PARAMETER CONTAINING RETURN INFORMATION.
 IN ADDITION, THE USER MAY REQUEST VOLUME SERIAL NUMBER FEEDBACK.
 THIS IS A REWRITE OF THE FORMER SUBROUTINE DYNALLOC, WHICH HAD
 A MUCH SMALLER SET OF ALLOWABLE ALLOCATION PARAMETERS.

 FOR ALLOCATION, THE SUBROUTINE WILL FREE ANY CURRENT USE OF THE
 DDNAME GIVEN, THEN ALLOCATE THE FILE DESCRIBED BY THE PARAMETER
 FIELDS SUPPLIED. THE RETURN CODE, ERROR RETURN CODE, AND INFORMATION
 REASON CODE FROM DYNAMIC ALLOCATION ARE RETURNED TO THE CALLER.
 A TABLE LOOKUP IS DONE TO PROVIDE A 71-CHARACTER MESSAGE FOR
 ANY ERRORS TO SAVE THE USER FROM LOOKING UP THE CODES IN A MANUAL.

 THE ALLOCDYN SUBROUTINE MAY BE CALLED ANY NUMBER OF TIMES DURING
 EXECUTION OF A JOB STEP. IF THE SAME DDNAME IS TO BE RE-ALLOCATED
 BE SURE TO CLOSE THE FILE BEFORE CALLING ALLOCDYN FOR ALLOCATION
 AGAIN.

 FOR VOLUME SERIAL NUMBER FEEDBACK, THE CALLER USES THE 'V' REQUEST
 CODE, AND PLACES THE DDNAME OF THE FILE IN THE FIRST PARAMETER.
 ON RETURN, THE VOLUME SERIAL NUMBER WILL BE IN THE APPROPRIATE
 FIELD IN THE FIRST PARAMETER, OR BLANK IF THE DDNAME COULD NOT
 BE FOUND. IN ADDITION, THE DEVICE ADDRESS WILL BE IN THE FIRST
 PARAMETER UNIT NAME FIELD. THIS CAN BE USED IN SUBSEQUENT CALLS
 TO INSURE ALLOCATION OF THE SAME DRIVE, IF THIS IS DESIRABLE.
 BEFORE CALLING FOR VOLUME SERIAL FEEDBACK, THE FILE MUST BE OPEN.

 THE FIRST PARAMETER PASSED CONTAINS INFORMATION NORMALLY SUPPLIED
 BY A DD CARD. THE USER SHOULD FIRST MOVE BINARY ZEROS TO THE
 FIRST PARAMETER AREA, THEN FILL IN THE FIELDS OF INTEREST. ANY
 FIELD CONTAINING BINARY ZEROS WILL BE IGNORED.

 THE DSNAME FIELD IS USED TO SPECIFY THE DSNAME FOR NORMAL DATASETS,
 AND IS ALSO USED TO ALLOCATE DUMMY DATASETS (MOVE "DUMMY" TO THE
 DSNAME FIELD), OR FOR SYSOUT DATASETS (MOVE "SYSOUT=A" TO THE DSNAME
 FIELD, OR "SYSOUT=B", ETC). IF A SYSOUT DATASET IS SPECIFIED, THE
 MEMBER NAME FIELD MAY BE USED TO SPECIFY THE DESTINATION FOR THE SYSOUT
 DATA. FOR A PDS, PUT THE DSNAME IN THE DSNAME FIELD AND THE MEMBER
 NAME IN THE MEMBER FIELD. FOR A GDG, PUT THE GENERIC DATASET NAME IN
 THE DSNAME FIELD AND THE SIGNED RELATIVE GENERATION NUMBER (WITHOUT
 PARENTHESES) IN THE MEMBER FIELD.

 WHEN A FIELD COMMENT SHOWS ">0"    YOU MAY PUT ANY VALUE IN IT OTHER
 THAN BINARY ZEROES TO ACTIVATE IT.

 WHEN A FIELD COMMENT CONTAINS "SUM OK", IT MAY CONTAIN A SINGLE VALUE,
 OR THE SUM OF ALL APPROPIRATE VALUES. FOR OTHER FIELDS, ONLY ONE OF THE
 INDICATED VALUES MAY BE USED.

 WHEN A FIELD COMMENT CONTAINS "NUM", THE CONTENTS ARE EXPECTED TO BE A
 BINARY NUMBER RIGHT JUSTIFIED WITH LEADING BINARY ZEROES. THE NUMBER
 MUST BE GREATER THAN ZERO, SINCE BINARY ZEROES CONSTITUTE AN EMPTY
 FIELD.

 WHEN A FIELD COMMENT CONTAINS "TXT", THE CONTENTS ARE EXPECTED TO BE
 PRINTABLE CHARACTERS, LEFT JUSTIFIED WITH TRAILING SPACES.

*
*
*
PARM1    DS    0C                      1ST PARAMETER DESCRIPTION
PRMDDNAM DS    CL8                     DDNAME TXT
PRMDSNAM DS    CL44                    DSN=TXT
PRMMEMBR DS    CL8                     MEMBER NAME/GDG GEN TXT
PRMSTATS DS    XL2                     DISP=STATUS NUM: 1=OLD,2=MOD,
*                                                  4=NEW,8=SHR
PRMNDISP DS    XL2                     DISP=NORMAL NUM: 8=KEEP,
*                                         1=UNCATLG,2=CATLG,4=DELETE
PRMCDISP DS    XL2                     DISP=CONDITIONAL NUM:
*                                         SAME AS PRMNDISP
PRMUNIT  DS    CL8                     UNIT= TXT
PRMUNCNT DS    XL2                     UNIT COUNT NUM
PRMVLSER DS    6CL6                    VOL=SER= TXT (1-6)
PRMLABEL DS    XL2                     LABEL= NUM:01=NL,02=SL,10=BLP
PRMDSSEQ DS    XL2                     DATASET SEQUENCE NUM (TAPE)
PRMCLOSE DS    CL1                     FREE=CLOSE >0
PRMRETPD DS    XL2                     RETPD= NUM
PRMRECFM DS    XL2                     RECFM=: HEX SUM OK
*                                      80=FIXED, 40=VARIABLE,
*                                      C0=UNDEFINED, 10=BLOCKED,
*                                      04=ASA CONTROL CHARACTERS,
*                                      02=MACHINE CONTROL CHARACTERS,
*                                      08=STANDARD(F) OR SPANNED(V)
*                                      20=VRBL ASCII(D) OR TRK OFLO(T)
PRMLRECL DS    XL2                     LRECL= NUM
PRMBLKSZ DS    XL2                     BLKSIZE= NUM
PRMDEN   DS    XL2                     DEN= NUM: 03=200,43=556,
*                                             83=800,C3=1600,D3=6250
PRMBUFNO DS    XL2                     BUFNO= NUM
PRMKYLEN DS    XL2                     KEYLEN= NUM
PRMDSORG DS    XL2                     DSORG= NUM:
*                                      0008=VSAM, 0080=GS, 0200=PO,
*                                      0300=POU, 2000=DA, 2100=DAU,
*                                      4000=PS, 4100=PSU
PRMSPACE DS    CL1                     SPACE= TYPE TXT:
*                                      C=CYL, T=TRK
PRMPRIME DS    XL4                     PRIMARY SPACE AMOUNT NUM
PRMSECND DS    XL4                     SECONDARY SPACE AMOUNT NUM
PRMRLSE  DS    CL1                     RLSE >0
PRMDIR   DS    XL4                     DIRECTORY BLOCKS NUM
PRMEX100 DS    CL2                     EXPDT= CENTURY TXT
PRMEXPDT DS    CL5                     EXPDT= YYDDD TXT
PRMBLKLN DS    XL4                     SPACE AVERAGE BLOCKSIZE NUM
PRMSPFRM DS    XL2                     SPACE FORM NUM: 2=ALX,
*                                                  4=MXIG, 8=CONTIG
PRMROUND DS    CL1                     ROUND >0
PRMPRIVT DS    CL1                     PRIVATE >0
PRMVLSEQ DS    XL2                     VOLUME SEQUENCE NUM
PRMVLCNT DS    XL2                     VOLUME COUNT NUM
PRMVLRDS DS    CL44                    VOL=REF= DSNAME TXT
PRMPARAL DS    CL1                     PARALLEL MOUNT REQUEST >0
PRMSPGNM DS    CL8                     SYSOUT PROGRAM NAME TXT
PRMSFMNO DS    CL4                     SYSOUT FORM NUMBER TXT
PRMOUTLM DS    XL4                     OUTLIM FOR SYSOUT NUM
PRMCOPYS DS    XL2                     COPIES= NUM
PRMPASPR DS    XL2                     PASSWORD PROTECTION NUM:
*                                            10=PWREAD, 30=NOPWREAD
PRMINOUT DS    XL2                     INPUT/OUTPUT ONLY NUM:
*                                      40=OUTPUT-ONLY, 80=INPUT-ONLY
PRMFCBIM DS    CL4                     FCB= TXT
PRMFCBAV DS    XL2                     FCB ALIGN/VERIFY NUM:
*                                           4=VERIFY, 8=ALIGN
PRMTERM  DS    CL1                     TERM=TS >0
PRMUCS   DS    CL4                     UCS= TXT
PRMUFOLD DS    CL1                     UCS FOLD >0
PRMUVRFY DS    CL1                     UCS VERIFY REQUEST >0
PRMDCBDS DS    CL44                    DCB MODEL DSNAME TXT
PRMDCBDD DS    CL26                    DCB DDNAME BACKREFERENCE TXT
PRMEROPT DS    XL2                     EROPT= NUM: 10=T, 20=ABE,
*                                                  40=SKP, 80=ACC
PRMNCP   DS    XL2                     NCP= NUM
PRMOPTCD DS    XL2                     OPTCD= SUM OK: 1=R,J; 2=T;
*                                             4=Z; 8=A,Q; 10=F,H,O;
*                                             20=C,E; 40=B,U; 80=W
PRMPRTSP DS    XL2                     PRINTER SPACING NUM: 1=NO SPACE
*                                          9=SINGLE SPACED, 11=DOUBLE
*                                          SPACED, 19=TRIPLE SPACED
PRMTRTCH DS    XL2                     7-TRACK TAPE NUM: 4=NON-COMPACT,
*                                          8=COMPACTION, 13=C, 23=E,
*                                          2B=ET, 3B=T
PRMPASSW DS    CL32                    PASSWORD VALUE TXT
PRMDIAGN DS    CL1                     DIAGNS=TRACE >0
PRMSUSER DS    CL8                     SYSOUT DEST NODE NAME TXT
PRMSHOLD DS    CL1                     HOLD=YES >0
PRMUSRID DS    CL8                     SYSOUT DEST USERID TXT
PRMBURST DS    XL2                     BURST= NUM: 2=BURST/STACK/TRIM
*                                                  4=CONTINUOUS
PRMCHARS DS    4CL4                    CHARS= NAMES TXT (0-4)
PRMCOPYG DS    8XL2                    SYSOUT COPY GROUPS (0-8)
PRMFFORM DS    CL4                     FLASH= FORM OVERLAY NAME TXT
PRMFCNT  DS    XL2                     FLASH OVERLAY COUNT NUM
PRMMMOD  DS    CL4                     MODIFY= MODULE NAME TXT
PRMMTRC  DS    XL2                     MODIFY TRC NUM: 0=1ST CAT,
*                                       1=2ND CAT, 2=3RD CAT, 3=4TH CAT
PRMDEFER DS    CL1                     DEFER MOUNT REQUEST >0
PRMOUTPT DS    8CL26                   OUTPUT= REFERENCES TXT (0-8)
PRMCNTL  DS    CL26                    CNTL STATEMENT REFERENCE TXT
PRMSTCL  DS    CL8                     STORCLAS= TXT
PRMMGCL  DS    CL8                     MGMTCLAS= TXT
PRMDACL  DS    CL8                     DATACLAS= TXT
PRMRECO  DS    XL2                     RECORG=NUM: 8=KS,4=ES,2=RR,1=LS
PRMKEYO  DS    XL2                     KEYOFF= NUM
PRMREFD  DS    CL26                    REFDD= DDNAME REFERENCE TXT
PRMLIKE  DS    CL44                    LIKE= DSNAME REFERENCE TXT
PRMAVGR  DS    XL2                     AVGREC= NUM: 80=SINGLE RECS
*                                        40=THOUSANDS ,20=MILLIONS
PRMDSNT  DS    XL2                     DSNTYPE= NUM: 80=PDSE, 40=PDS

  THE SECOND PARAMETER IS A SET OF FIELDS IN WHICH THE RESULT OF
  ALLOCATION IS RETURNED. ENVIRONMENT ERROR RESULTS FROM THE CURRENT
  ENVIRONMENT, UNAVAILABILITY OF A SYSTEM RESOURCE, OR SYSTEM ROUTINE
  FAILURE. ENVIRONMENT ERROR IS ACCOMPANIED BY AN ERROR-REASON-CODE.
  VALIDATION-DENIAL IS CAUSED BY THE INSTALLATION VALIDATION ROUTINE
  (SECURITY). PARAMETER-ERROR IS CAUSED BY AN INVALID PARAMETER LIST.
  PARAMETER-ERROR IS ALSO ACCOMPANIED BY AN ERROR-REASON-CODE.
  SUCCESSFUL-ALLOCATION MAY BE ACCOMPANIED BY AN INFORMATION-REASON
  CODE IF A NON-TERMINATING ERROR OCCURRED DURING PROCESSING. SINCE
  INFORMATION CODES ALL APPLY TO UN-ALLOCATION, THEY SHOULD NOT BE
  PERTINENT TO USERS OF THIS SUBROUTINE.
  ERROR-REASON-CODES AND INFORMATION-REASON CODES MAY BE FOUND IN
  IBM MANUAL GC28-1852: SPL APPLICATION DEVELOPMENT GUIDE, CHAPTER
                        19: REQUESTING SVC 99 FUNCTIONS.
   IN ADDITION, SC28-1875: TSO/E PROGRAMMING SERVICES CONTAINS SOME
                           DAIR RETURN CODES,
           AND  SC26-4567: DFP3.3 SYSTEM PROGRAMMING REFERENCE HAS
                           LOCATE, DADSM, CATALOG, AND OBTAIN CODES.

  THE FIELD IS FORMATTED AS FOLLOWS:
*
*
*
PARM2    DS    0C                      2ND PARAMETER DESCRIPTION
REQCODE  DS    CL1                     REQUEST CODE, A=ALLOC, V=VOLSER
RETCODE  DS    CL2                     ALLOCDYN RETURN CODE
ERRRET   DS    CL4                     ERROR RETURN CODE
ERRMSG   DS    CL71                    ERROR REASON MESSAGE
INFORET  DS    CL4                     INFO RETURN CODE
INFOMSG  DS    CL71                    INFORMATION REASON MESSAGE
PARMSEND EQU   *                       END OF ALLOCDYN PARMS

 USE OF THE ALLOCDYN SUBROUTINE: FIRST, CLEAR THE PARAMETER FIELDS TO
 BINARY ZEROES, THEN FILL IN THE DESIRED FIELDS IN THE PARM1
 PARAMETER BLOCK. FILL IN ALL THE FIELDS YOU WOULD ON A DD CARD FOR
 THE DESIRED ALLOCATION. DEFAULTS ARE THE SAME AS THOSE USED IF A
 DD CARD HAD BEEN USED. WHEN COMPLETE, CALL THE ALLOCDYN SUBROUTINE
 PASSING THE TWO PARAMETER BLOCKS. ON RETURN, CHECK THE RETURN CODE
 FOR ERRORS, AND IF THERE ARE NONE, A DD CARD HAS BEEN CREATED. IF
 A TAPE WAS ALLOCATED, A MOUNT REQUEST WAS GIVEN TO THE OPERATOR.
 AT THIS POINT, AN OPEN MAY BE ISSUED FOR THE FILE, AND PROCESSING
 MAY TAKE PLACE NORMALLY. ANY PREVIOUS DD CARD OR DYNAMIC ALLOCATION
 FOR THE DDNAME GIVEN IS CANCELLED ON ENTRY TO THE ALLOCDYN
 SUBROUTINE, SO THE USER SHOULD NOT INCLUDE A DD CARD WITH THE
 REQUESTED DDNAME IN THE EXECUTION JCL FOR THE JOB STEP.


 EXAMPLE1: ALLOCATE THE FOLLOWING DD CARD -
          //OUTPUT1 DD DSN=MTT.PROCESS.TAPE,DISP=(NEW,CATLG,DELETE),
          //          UNIT=TAPE,DCB=(RECFM=VB,LRECL=320,BLKSIZE=3204)
            .
            .
            LA    R0,PARM1                        CLEAR
            LA    R1,PARMSEND-PARM1                  PARM
            SR    R15,R15                                FIELDS
            MVCL  R0,R14                                    TO ZEROS
            MVC   PRMDDNAM,=C'OUTPUT1'           MOVE IN DD NAME
            MVC   PRMDSNAM,=C'MTT.PROCESS.TAPE'  MOVE IN DSNAME
            MVC   PRMSTATS,=H'4'                 DISP=(NEW,
            MVC   PRMNDISP,=H'2'                         CATLG,
            MVC   PRMCDISP,=H'4'                            DELETE)
            MVC   PRMUNIT,=CL8'TAPE'             UNIT=TAPE
            MVC   PRMRECFM,=X'0050'              RECFM=VB
            MVC   PRMLRECL,=H'320'               LRECL=320
            MVC   PRMBLKSZ,=H'3204'              BLKSIZE=3204
            MVI   REQCODE,C'A'                   REQUEST ALLOCATION.
            CALL  ALLOCDYN,(PARM1,PARM2)         ALLOCATE THE DATASET
            CLC   RETCODE,=C'00'                 ANY ERROR?
            BE    ALLOCERRS                       YES
            .
            .
            .


 EXAMPLE2: OBTAIN THE VOLUME SERIAL NUMBER OF THE DEVICE ALLOCATED
           FOR DDNAME OUTPUT1:


               .
               .
               MVI   REQCODE,C'V'               VOL SER REQUEST
               MVC   PRMDDNAM,=CL8'OUTPUT1'     DDNAME TO PARM FIELD
               CALL  ALLOCDYN,(PARM1,PARM2)     GET THE VOLUME SERIAL
               MVC   PRTVOL,PRMVLSER            USE THE VOL SER
               .
               .
               .



 EXAMPLE3: ALLOCATE THE FOLLOWING DD CARD -
           //PRINT1  DD  SYSOUT=B,DEST=RMT15

            .
            .
            LA    R0,PARM1                        CLEAR
            LA    R1,PARMSEND-PARM1                  PARM
            SR    R15,R15                                FIELDS
            MVCL  R0,R14                                    TO ZEROS
            MVI   REQCODE,C'A'                    REQUEST ALLOCATION
            MVC   PRMDDNAM,=CL8'PRINT1'           MOVE IN DD NAME
            MVC   PRMDSNAM,=CL44'SYSOUT=B'        MOVE IN SYSOUT=B
            MVC   PRMSUSER,=CL8(RMT15)            SET DEST=RMT15
            CALL  ALLOCDYN,(DAPARM1,DAPARM2)      ALLOCATE THE DATASET
            CLC   RETCODE,=C'00'                  ANY ERROR?
            BE    ALLOCERRS                       YES
./ ADD NAME=ALOCDYN2 0110-92042-94077-0918-00345-00317-00000-USER02
           ***** ALLOCDYN SUBROUTINE *****

           ***** COBOL  INSTRUCTIONS *****
       ***** USE ALOCDYN1  FOR ASSEMBLER *****

 THE ALLOCDYN SUBROUTINE IS USED TO ALLOCATE A FILE TO A PROGRAM
 DURING EXECUTION, WITHOUT THE USE OF A DD CARD IN THE EXECUTION
 JCL. THE USER FILLS IN DESIRED DD CARD INFORMATION IN A PARAMETER
 FIELD, AND CALLS THE ALLOCDYN SUBROUTINE, PASSING THE DD CARD
 INFORMATION AND A PARAMETER CONTAINING RETURN INFORMATION.
 IN ADDITION, THE USER MAY REQUEST VOLUME SERIAL NUMBER FEEDBACK.
 THIS IS A REWRITE OF THE FORMER SUBROUTINE DYNALLOC, WHICH HAD
 A MUCH SMALLER SET OF ALLOWABLE ALLOCATION PARAMETERS.

 FOR ALLOCATION, THE SUBROUTINE WILL FREE ANY CURRENT USE OF THE
 DDNAME GIVEN, THEN ALLOCATE THE FILE DESCRIBED BY THE PARAMETER
 FIELDS SUPPLIED. THE RETURN CODE, ERROR RETURN CODE, AND INFORMATION
 REASON CODE FROM DYNAMIC ALLOCATION ARE RETURNED TO THE CALLER.
 A TABLE LOOKUP IS DONE TO PROVIDE A 71-CHARACTER MESSAGE FOR
 ANY ERRORS TO SAVE THE USER FROM LOOKING UP THE CODES IN A MANUAL.

 THE ALLOCDYN SUBROUTINE MAY BE CALLED ANY NUMBER OF TIMES DURING
 EXECUTION OF A JOB STEP. IF THE SAME DDNAME IS TO BE RE-ALLOCATED
 BE SURE TO CLOSE THE FILE BEFORE CALLING ALLOCDYN FOR ALLOCATION
 AGAIN.

 FOR VOLUME SERIAL NUMBER FEEDBACK, THE CALLER USES THE 'V' REQUEST
 CODE, AND PLACES THE DDNAME OF THE FILE IN THE FIRST PARAMETER.
 ON RETURN, THE VOLUME SERIAL NUMBER WILL BE IN THE APPROPRIATE
 FIELD IN THE FIRST PARAMETER, OR BLANK IF THE DDNAME COULD NOT
 BE FOUND. IN ADDITION, THE DEVICE ADDRESS WILL BE IN THE FIRST
 PARAMETER UNIT NAME FIELD. THIS CAN BE USED IN SUBSEQUENT CALLS
 TO INSURE ALLOCATION OF THE SAME DRIVE, IF THIS IS DESIRABLE.
 BEFORE CALLING FOR VOLUME SERIAL FEEDBACK, THE FILE MUST BE OPEN.

 THE FIRST PARAMETER PASSED CONTAINS INFORMATION NORMALLY SUPPLIED
 BY A DD CARD. THE USER SHOULD FIRST MOVE BINARY ZEROS TO THE
 FIRST PARAMETER AREA, THEN FILL IN THE FIELDS OF INTEREST. ANY
 FIELD CONTAINING BINARY ZEROS WILL BE IGNORED.

 THE DSNAME FIELD IS USED TO SPECIFY THE DSNAME FOR NORMAL DATASETS,
 AND IS ALSO USED TO ALLOCATE DUMMY DATASETS (MOVE "DUMMY" TO THE
 DSNAME FIELD), OR FOR SYSOUT DATASETS (MOVE "SYSOUT=A" TO THE DSNAME
 FIELD, OR "SYSOUT=B", ETC). IF A SYSOUT DATASET IS SPECIFIED, THE
 MEMBER NAME FIELD MAY BE USED TO SPECIFY THE DESTINATION FOR THE SYSOUT
 DATA. FOR A PDS, PUT THE DSNAME IN THE DSNAME FIELD AND THE MEMBER
 NAME IN THE MEMBER FIELD. FOR A GDG, PUT THE GENERIC DATASET NAME IN
 THE DSNAME FIELD AND THE SIGNED RELATIVE GENERATION NUMBER (WITHOUT
 PARENTHESES) IN THE MEMBER FIELD.

 WHEN A FIELD NAME ENDS WITH -INDIC, YOU MAY PUT ANY VALUE IN IT OTHER
 THAN LOW-VALUES TO ACTIVATE IT.

 WHEN A FIELD NAME ENDS WITH -SUM, IT CAN CONTAIN ANY ONE VALUE, OR THE
 SUM OF ALL DESIRED VALUES. FOR EXAMPLE, TO INDICATE RECFM=FB, YOU WOULD
 MOVE +144 TO RECORDING-MODE-SUM (F=128, B=16, 128+16=144).

       01  ALLOCATE-DATA.
           05  DDNAME                      PIC X(8).
           05  DSNAME-DUMMY-SYSOUT         PIC X(44).
           05  MEMBER-NAME-GENERATION      PIC X(8).
           05  CURRENT-STATUS              PIC S9(4) COMP.
               88  STATUS-OLD                VALUE +1.
               88  STATUS-MOD                VALUE +2.
               88  STATUS-NEW                VALUE +4.
               88  STATUS-SHR                VALUE +8.
           05  NORMAL-DISPOSITION          PIC S9(4) COMP.
               88  NORM-UNCATLG              VALUE +1.
               88  NORM-CATLG                VALUE +2.
               88  NORM-DELETE               VALUE +4.
               88  NORM-KEEP                 VALUE +8.
           05  CONDITIONAL-DISPOSITION     PIC S9(4) COMP.
               88  COND-UNCATLG              VALUE +1.
               88  COND-CATLG                VALUE +2.
               88  COND-DELETE               VALUE +4.
               88  COND-KEEP                 VALUE +8.
           05  UNIT-NAME                   PIC X(8).
           05  UNIT-COUNT                  PIC S9(4) COMP.
           05  VOLUME-SERIAL               PIC X(6)
                                             OCCURS 6 TIMES.
           05  LABEL-TYPE                  PIC S9(4) COMP.
               88  NO-LABELS                 VALUE +1.
               88  STANDARD-LABELS           VALUE +2.
               88  BYPASS-LABELS             VALUE +16.
           05  DATASET-SEQUENCE            PIC S9(4) COMP.
           05  FREE-EQU-CLOSE-INDIC        PIC X.
           05  RETENTION-PERIOD-DAYS       PIC S9(4) COMP.
           05  RECORDING-MODE-SUM          PIC S9(4) COMP.
               88  F-FIXED-RECORDS           VALUE +128.
               88  V-VARIABLE-RECORDS        VALUE +64.
               88  U-UNDEFINED-RECORDS       VALUE +192.
               88  D-OR-T-ADD                VALUE +32.
               88  B-BLOCKED-RECORDS-ADD     VALUE +16.
               88  S-STANDARD-SPANNED-ADD    VALUE +8.
               88  A-ASA-PRINT-CONTROL-ADD   VALUE +4.
               88  M-MACHINE-CODE-CONTROL-ADD VALUE +2.
           05  LOGICAL-RECORD-LENGTH       PIC S9(4) COMP.
           05  BLOCK-LENGTH                PIC S9(4) COMP.
           05  TAPE-DENSITY                PIC S9(4) COMP.
               88  200-BPI                   VALUE +3.
               88 556-BPI                    VALUE +67.
               88 800-BPI                    VALUE +131.
               88 1600-BPI                   VALUE +195.
               88 6250-BPI                   VALUE +211.
           05  NUMBER-BUFFERS              PIC S9(4) COMP.
           05  KEY-LENGTH                  PIC S9(4) COMP.
           05  DATASET-ORGANIZATION        PIC S9(4) COMP.
               88 VSAM-DATASET               VALUE +8.
               88 GRAPHICS-GS                VALUE +128.
               88 PARTITIONED-DATASET        VALUE +512.
               88 PARTITIONED-UNMOVABLE      VALUE +768.
               88 DIRECT-DATASET             VALUE +8192.
               88 DIRECT-UNMOVABLE           VALUE +8448.
 *             88 PHYSICAL-SEQUENTIAL        VALUE +16384.
 *             88 PHYSICAL-UNMOVABLE         VALUE +16640.
           05  SPACE-TYPE                  PIC X.
               88 CYLINDER-REQUEST           VALUE 'C'.
               88 TRACK-REQUEST              VALUE 'T'.
           05  PRIMARY-SPACE-AMOUNT        PIC S9(8) COMP.
           05  SECONDARY-SPACE-AMOUNT      PIC S9(8) COMP.
           05  RELEASE-SPACE-INDIC         PIC X.
           05  NBR-DIRECTORY-BLOCKS        PIC S9(8) COMP.
           05  EXPIRATION-DATE-CENTURY     PIC X(2).
           05  EXPIRATION-DATE-YYDDD       PIC X(5).
           05  AVG-BLKSIZE-FOR-SPACE       PIC S9(8) COMP.
           05  SPACE-FORMAT-TYPE           PIC S9(4) COMP.
               88  ALX-SPACE                 VALUE +2.
               88  MXIG-SPACE                VALUE +4.
               88  CONTIG-SPACE              VALUE +8.
           05  SPACE-ROUNDING-INDIC        PIC X.
           05  PRIVATE-VOLUME-INDIC        PIC X.
           05  VOLUME-SEQUENCE-NUMBER      PIC S9(4) COMP.
           05  VOLUME-COUNT                PIC S9(4) COMP.
           05  DSNAME-FOR-VOL-REF          PIC X(44).
           05  PARALLEL-MOUNT-INDIC        PIC X.
           05  SYSOUT-PROGRAM-NAME         PIC X(8).
           05  SYSOUT-FORM-NUMBER          PIC X(4).
           05  SYSOUT-OUTLIM               PIC S9(8) COMP.
           05  NUMBER-SYSOUT-COPIES        PIC S9(4) COMP.
           05  PASSWORD-PROTECTION         PIC S9(4) COMP.
               88  PASSWORD-ALL-REFERENCES   VALUE +16.
               88  NO-PASSWORD-TO-READ       VALUE +48.
           05  INPUT-OUTPUT-ONLY           PIC S9(4) COMP.
               88  INPUT-ONLY                VALUE +64.
               88  OUTPUT-ONLY               VALUE +128.
           05  FCB-IMAGE-NAME              PIC X(4).
           05  FCB-ALIGN-VERIFY            PIC S9(4) COMP.
               88  CHECK-FCB-ALIGN           VALUE +8.
               88  VERIFY-FCB                VALUE +4.
           05  USE-TSO-TERMINAL-INDIC      PIC X.
           05  UCS-IMAGE-NAME              PIC X(4).
           05  FOLD-MODE-INDIC             PIC X.
           05  CHAIN-MOUNT-VERIFY-INDIC    PIC X.
           05  DCB-MODEL-DSNAME            PIC X(44).
           05  DCB-DDNAME-BACKREF          PIC X(26).
           05  ERROR-OPTION                PIC S9(4) COMP.
               88  EROPT-EQU-T               VALUE +16.
               88  EROPT-EQU-ABE             VALUE +32.
               88  EROPT-EQU-SKP             VALUE +48.
               88  EROPT-EQU-ACC             VALUE +128.
           05  NCP-READ-WRITE-BEFORE-CHECK PIC S9(4) COMP.
           05  OPTION-CODES-SUM            PIC S9(4) COMP.
               88  OPTCD-EQU-R-OR-J          VALUE +1.
               88  OPTCD-EQU-T               VALUE +2.
               88  OPTCD-EQU-Z               VALUE +4.
               88  OPTCD-EQU-A-OR-Q          VALUE +8.
               88  OPTCD-EQU-F-OR-H-OR-O     VALUE +16.
               88  OPTCD-EQU-C-OR-E          VALUE +32.
               88  OPTCD-EQU-B-OR-U          VALUE +64.
               88  OPTCD-EQU-W               VALUE +128.
           05  PRINTER-SPACING              PIC S9(4) COMP.
               88  NO-SPACED-PRINT            VALUE +1.
               88  SINGLE-SPACED-PRINT        VALUE +9.
               88  DOUBLE-SPACED-PRINT        VALUE +17.
               88  TRIPLE-SPACED-PRINT        VALUE +25.
           05  TRTCH-7-TRACK-TAPE           PIC S9(4) COMP.
               88  NON-COMPACTION             VALUE +4.
               88  COMPACTION                 VALUE +8.
               88  TRTCH-EQU-C                VALUE +19.
               88  TRTCH-EQU-E                VALUE +35.
               88  TRTCH-EQU-ET               VALUE +43.
               88  TRTCH-EQU-T                VALUE +59.
           05  PASSWORD-VALUE               PIC X(32).
           05  DIAGNOSTIC-TRACE-INDIC       PIC X.
           05  SYSOUT-DEST-NODE-NAME        PIC X(8).
           05  SYSOUT-HOLD-QUEUE-INDIC      PIC X.
           05  SYSOUT-DEST-USERID           PIC X(8).
           05  SYSOUT-BURSTER-STACKER       PIC S9(4) COMP.
               88  BURST-EQU-YES              VALUE +2.
               88  BURST-EQU-NO               VALUE +4.
           05  CHARACTER-ARRANGEMENT-TABLE  PIC X(4)
                                              OCCURS 4 TIMES.
           05  SYSOUT-COPY-GROUP-VALUE      PIC S9(4) COMP
                                              OCCURS 8 TIMES.
           05  SYSOUT-FLASH-OVERLAY-NAME    PIC X(4).
           05  SYSOUT-FLASH-OVERLAY-COUNT   PIC S9(4) COMP.
           05  COPY-MODIFY-MODULE-NAME      PIC X(4).
           05  COPY-MODULE-TRC              PIC S9(4) COMP.
               88  FIRST-CHAR-ARR-TABLE       VALUE +0.
               88  SECOND-CHAR-ARR-TABLE      VALUE +1.
               88  THIRD-CHAR-ARR-TABLE       VALUE +2.
               88  FOURTH-CHAR-ARR-TABLE      VALUE +3.
           05  DEFER-MOUNT-INDIC            PIC X.
           05  OUTPUT-STATEMENT-REFERENCE   PIC X(26)
                                              OCCURS 8 TIMES.
           05  CNTL-STATEMENT-REFERENCE     PIC X(26).
           05  SMS-STORCLAS-NAME            PIC X(8).
           05  SMS-MGMTCLAS-NAME            PIC X(8).
           05  SMS-DATACLAS-NAME            PIC X(8).
           05  SMS-RECORD-ORGANIZATION      PIC S9(4) COMP.
               88  VSAM-KSDS                  VALUE +128.
               88  VSAM-ESDS                  VALUE +64.
               88  VSAM-RRDS                  VALUE +32.
               88  VSAM-LINEAR-SPACE          VALUE +16.
           05  SMS-KEY-OFFSET               PIC S9(4) COMP.
           05  SMS-REFDD                    PIC X(26).
           05  SMS-LIKE-DSNAME              PIC X(44).
           05  SMS-AVERAGE-RECORD-UNITS     PIC S9(4) COMP.
               88  IN-SINGLE-RECORDS          VALUE +128.
               88  IN-THOUSAND-RECORD-UNITS   VALUE +64.
               88  IN-MILLION-RECORD-UNITS    VALUE +32.
           05  SMS-DSNTYPE                  PIC S9(4) COMP.
               88  PDSE-LIBRARY               VALUE +128.
               88  OLD-STYLE-PDS              VALUE +64.

  THE SECOND PARAMETER IS A SET OF FIELDS IN WHICH THE RESULT OF
  ALLOCATION IS RETURNED. ENVIRONMENT ERROR RESULTS FROM THE CURRENT
  ENVIRONMENT, UNAVAILABILITY OF A SYSTEM RESOURCE, OR SYSTEM ROUTINE
  FAILURE. ENVIRONMENT ERROR IS ACCOMPANIED BY AN ERROR-REASON-CODE.
  VALIDATION-DENIAL IS CAUSED BY THE INSTALLATION VALIDATION ROUTINE
  (SECURITY). PARAMETER-ERROR IS CAUSED BY AN INVALID PARAMETER LIST.
  PARAMETER-ERROR IS ALSO ACCOMPANIED BY AN ERROR-REASON-CODE.
  SUCCESSFUL-ALLOCATION MAY BE ACCOMPANIED BY AN INFORMATION-REASON
  CODE IF A NON-TERMINATING ERROR OCCURRED DURING PROCESSING. SINCE
  INFORMATION CODES ALL APPLY TO UN-ALLOCATION, THEY SHOULD NOT BE
  PERTINENT TO USERS OF THIS SUBROUTINE.
  ERROR-REASON-CODES AND INFORMATION-REASON CODES MAY BE FOUND IN
  IBM MANUAL GC28-1852: SPL APPLICATION DEVELOPMENT GUIDE, CHAPTER
                        19: REQUESTING SVC 99 FUNCTIONS.
   IN ADDITION, SC28-1875: TSO/E PROGRAMMING SERVICES CONTAINS SOME
                           DAIR RETURN CODES,
           AND  SC26-4567: DFP3.3 SYSTEM PROGRAMMING REFERENCE HAS
                           LOCATE, DADSM, CATALOG, AND OBTAIN CODES.

  THE FIELD IS FORMATTED AS FOLLOWS:

       01  ALLOCATION-RESULT.
           05  ALLOCDYN-REQUEST             PIC X.
               88  ALLOCATION-REQUEST         VALUE 'A'.
               88  VOLSER-REQUEST             VALUE 'V'.
           05  ALLOCDYN-RETURN-CODE         PIC XX.
               88  SUCCESSFUL-ALLOCATION      VALUE '00'.
               88  ENVIRONMENT-ERROR          VALUE '04'.
               88  VALIDATION-DENIAL          VALUE '08'.
               88  PARAMETER-ERROR            VALUE '12'.
           05  ERROR-REASON-CODE.
               10  CLASS-7-CODE             PIC X.
               10  ERROR-CLASS              PIC X.
                   88  UNAVAILABLE-RESOURCE   VALUE '2'.
                   88  INVALID-PARAMETER-LIST VALUE '3'.
                   88  ERROR-IN-ENVIRONMENT   VALUE '4'.
                   88  SYSTEM-ROUTINE-ERROR   VALUE '7'.
               10  SPECIFIC-ERROR-CODE      PIC XX.
           05  ERROR-REASON-MESSAGE         PIC X(71).
           05  INFORMATION-REASON           PIC X(4).
           05  INFO-REASON-MESSAGE          PIC X(71).


 USE OF THE ALLOCDYN SUBROUTINE: FIRST, CLEAR THE PARAMETER FIELDS TO
 LOW-VALUES, THEN FILL IN THE DESIRED FIELDS IN THE ALLOCATE-DATA
 PARAMETER BLOCK. FILL IN ALL THE FIELDS YOU WOULD ON A DD CARD FOR
 THE DESIRED ALLOCATION. DEFAULTS ARE THE SAME AS THOSE USED IF A
 DD CARD HAD BEEN USED. WHEN COMPLETE, CALL THE ALLOCDYN SUBROUTINE
 PASSING THE TWO PARAMETER BLOCKS. ON RETURN, CHECK THE RETURN CODE
 FOR ERRORS, AND IF THERE ARE NONE, A DD CARD HAS BEEN CREATED. IF
 A TAPE WAS ALLOCATED, A MOUNT REQUEST WAS GIVEN TO THE OPERATOR.
 AT THIS POINT, AN OPEN MAY BE ISSUED FOR THE FILE, AND PROCESSING
 MAY TAKE PLACE NORMALLY. ANY PREVIOUS DD CARD OR DYNAMIC ALLOCATION
 FOR THE DDNAME GIVEN IS CANCELLED ON ENTRY TO THE ALLOCDYN
 SUBROUTINE, SO THE USER SHOULD NOT INCLUDE A DD CARD WITH THE
 REQUESTED DDNAME IN THE EXECUTION JCL FOR THE JOB STEP.

 EXAMPLE1: ALLOCATE THE FOLLOWING DD CARD -
          //OUTPUT1 DD DSN=MTT.PROCESS.TAPE,DISP=(NEW,CATLG,DELETE),
          //          UNIT=TAPE,DCB=(RECFM=VB,LRECL=320,BLKSIZE=3204)


       ALLOCATE-THE-FILE.
            MOVE LOW-VALUES TO ALLOCATE-DATA.
            MOVE 'OUTPUT1' TO DDNAME.
            MOVE 'MTT.PROCESS.TAPE' TO DSNAME-DUMMY-SYSOUT.
            MOVE +4 TO CURRENT-STATUS.
            MOVE +2 TO NORMAL-DISPOSITION.
            MOVE +4 TO CONDITIONAL-DISPOSITION.
            MOVE 'TAPE' TO UNIT-NAME.
            MOVE +80 TO RECORDING-MODE-SUM.
            MOVE +320 TO LOGICAL-RECORD-LENGTH.
            MOVE +3204 TO BLOCK-LENGTH.
            MOVE 'A' TO ALLOCDYN-REQUEST.
       CALL 'ALLOCDYN' USING ALLOCATE-DATA, ALLOCATION-RESULT.
       IF SUCCESSFUL-ALLOCATION
           NEXT SENTENCE
       ELSE DISPLAY 'UNABLE TO ALLOCATE OUTPUT1: RETURN CODE='
                     ALLOCDYN-RETURN-CODE
            DISPLAY '   ERROR-REASON-CODE=' ERROR-REASON-CODE
                     ': ' ERROR-REASON-MESSAGE
            DISPLAY '   INFORMATION-REASON=' INFORMATION-REASON
                   ': ' INFO-REASON-MESSAGE
            CALL 'COBABEND'.
     OPEN INPUT INPUT-FILE OUTPUT OUTPUT-FILE.



 EXAMPLE2: OBTAIN THE VOLUME SERIAL NUMBER OF THE DEVICE ALLOCATED
           FOR DDNAME OUTPUT1:

               MOVE 'V' TO ALLOCDYN-REQUEST.
               MOVE 'OUTPUT1' TO DDNAME.
               CALL 'ALLOCDYN' USING ALLOCATE-DATA, ALLOCATION-RESULT.
               MOVE VOLUME-SERIAL TO PRINT-SERIAL-NUMBER.




 EXAMPLE3: ALLOCATE THE FOLLOWING DD CARD -
          //PRINT1  DD SYSOUT=(,),OUTPUT=(*.OUT1,*.OUT2,*.ARK1)

       ALLOCATE-THE-FILE.
            MOVE 'A' TO ALLOCDYN-REQUEST.
            MOVE LOW-VALUES TO ALLOCATE-DATA.
            MOVE 'PRINT1' TO DDNAME.
            MOVE 'SYSOUT=(,)' TO DSNAME.
            MOVE 'OUT1' TO OUTPUT-STATEMENT-REFERENCE(1).
            MOVE 'OUT2' TO OUTPUT-STATEMENT-REFERENCE(2).
            MOVE 'ARK1' TO OUTPUT-STATEMENT-REFERENCE(3).
            CALL 'ALLOCDYN' USING ALLOCATE-DATA, ALLOCATION-RESULT.
            IF SUCCESSFUL-ALLOCATION
                    OPEN OUTPUT MTT-TAPE, PRINT-FILE
               ELSE DISPLAY 'UNABLE TO ALLOCATE PRINT1: RETURN CODE='
                            ALLOCDYN-RETURN-CODE
                    DISPLAY '   ERROR-REASON-CODE=' ERROR-REASON-CODE
                            ': ' ERROR-REASON-MESSAGE
                    DISPLAY '   INFORMATION-REASON=' INFORMATION-REASON
                            ': ' INFO-REASON-MESSAGE
                    CALL 'COBABEND'.
./ ADD NAME=CHRDUMP  0100-02092-02092-1412-00245-00245-00000-BC0THOR
                    ***** INSTRUCTIONS FOR CHRDUMP *****

CHRDUMP IS A DISK ACCESS UTILITY WHICH CAN BE USED TO DISPLAY DISK
RECORDS AT ANY LOCATION ON ANY VOLUME WITHOUT USE OF JCL ALLOCATION.
TO PERMIT PRINTING THE OUTPUT, THE COMMANDS ARE READ FROM THE SYSIN
ALLOCATION, AND THE OUTPUT IS WRITTEN TO THE SYSPRINT ALLOCATION.
BOTH OF THESE MUST BE RECFM=FB,LRECL=80.

FILE SYSLST MAY BE ALLOCATED TO PROVIDE A FILE OF THE PRINTED
OUTPUT, IF DESIRED. IF A SYSLST DD STATEMENT IS FOUND, ALL PRINTED
OUTPUT WILL BE WRITTEN TO THE FILE ALLOCATED. THIS FILE MUST HAVE
RECFM=F OR FB. LRECL SHOULD BE 80, BUT CAN VARY IF THE USER IS
WILLING TO ACCEPT TRUNCATION OR GARBAGE AT THE RIGHT RELATIVE TO
AN 80-BYTE RECORD. ONLY DSORG=PS IS VALID FOR THIS FILE.

FILE SYSOUT MAY BE ALLOCATED TO PROVIDE A FILE OF THE ACTUAL DISK
RECORDS SELECTED FOR OUTPUT. THIS OUTPUT WILL CONTAIN THE KEY AND
DATA PORTIONS OF THE RECORD. IF A VARIABLE FILE IS DEFINED, THE
OUTPUT RECORDS WILL BE WRITTEN AT THE SUM OF THE LENGTHS OF THE
KEY AND DATA, OR DCBLRECL, WHICHEVER IS SHORTER. FOR FIXED LENGTH
RECORDS, THE SPECIFIED LRECL WILL BE USED, WHICH MAY CAUSE
TRUNCATION OR TRASH AT THE RIGHT. ONLY DSORG=PS IS VALID FOR THIS
FILE.



WHEN STARTED, AND IF AN INVALID COMMAND IS ENTERED, THE FOLLOWING
MENU IS PRINTED:

R . . . . . . . . . . . . . READ NEXT RECORD IN EXTENT AND DISPLAY IT
P . . . . . . . . . . . . . RE-DISPLAY THE CURRENT RECORD
VOL . . . . . . . . . . . . DISPLAY A LIST OF ONLINE DISK VOLUMES
VOL=VVVVVV  . . . . . . . . ALLOCATE TO VOLUME VVVVVV
DSN . . . . . . . . . . . . DISPLAY ALL DATASETS ON CURRENT VOLUME
DSN=DDD...DDD . . . . . . . ALLOCATE TO THE DATASET NAMED DDD...DDD
CHR=CCCCHHHHRR-CCCCHHHHRR . SET EXTENT RANGE
C . . . . . . . . . . . . . CHANGE THE CONTENT OF THE CURRENT RECORD
F . . . . . . . . . . . . . DEFINE DISPLAY FORMAT
DCB . . . . . . . . . . . . SET UP DCB ATTRIBUTES
S . . . . . . . . . . . . . DEFINE SEARCH CRITERIA
CAT=DDD...DDD . . . . . . . ALLOCATE TO DATASET DDD...DDD USING CATALOG
REWRITE . . . . . . . . . . REWRITE THE CURRENT RECORD
END . . . . . . . . . . . . TERMINATE PROCESSING



TO USE CHRDUMP, ENTER ONE OF THE COMMANDS ABOVE AND PRESS ENTER. IF
ENTER IS PRESSED WITH NO DATA ENTERED, THE LAST COMMAND ENTERED IS
REPEATED. THIS IS USEFUL IN REPEATED R COMMANDS, FOR EXAMPLE. EACH
OF THE COMMANDS IS EXPLAINED BELOW:


R
     THIS COMMAND IS USED TO READ AND PRINT THE NEXT RECORD. CONTENT OF
     THE PRINTOUT IS CONTROLLED BY USE OF THE FMT COMMAND. IF NO FMT
     HAS BEEN SPECIFIED, THE ENTIRE BLOCK IS PRINTED. THE NEXT RECORD
     WILL BE THE NEXT PHYSICAL BLOCK IN THE EXTENT IF NO FMT OR SCH
     COMMAND HAS BEEN ENTERED. IF AN FMT COMMAND HAS BEEN ENTERED, THE
     NEXT LOGICAL RECORD WILL BE PRINTED FROM THE CURRENT BLOCK, IF
     THE BLOCK READ MATCHES THE DCB INFORMATION SET UP BY THE LAST
     CAT, DSN, OR DCB COMMAND. IF A SCH COMMAND HAS BEEN ENTERED AND
     THE BLOCKS MATCH THE DCB INFORMATION SPECIFIED BY THE LAST CAT,
     DSN, OR DCB COMMAND, THE NEXT LOGICAL RECORD WHICH MATCHES THE
     SEARCH CRITERIA GIVEN IN THE SCH COMMAND WILL BE PRINTED. BEFORE
     USING THE R COMMAND, USE THE CAT, DSN, OR CHR COMMAND TO SET UP
     THE EXTENTS TO BE DISPLAYED.



P
     THIS COMMAND CAUSES A RE-PRINT OF THE LAST RECORD PRINTED, AND
     FUNCTIONS IDENTICALLY TO THE R COMMAND ABOVE EXCEPT FOR THE
     RECORD SELECTED FOR PRINTING. THIS COMMAND IS USEFUL TO DISPLAY
     A RECORD AFTER CHANGES ARE MADE, AND BEFORE REWRITING THE
     RECORD.



VOL=VVVVVV
     THIS COMMAND IS USED TO ALLOCATE TO A GIVEN DISK VOLUME, WHERE
     VVVVVV IS THE VOLUME SERIAL NUMBER OF THE VOLUME. THE DISPLAY
     PRODUCED IS SHOWN BELOW, WHERE X'S REPRESENT DATA OBTAINED FROM
     THE VOLUME LABEL OF THE DRIVE SELECTED:

FORMAT 4 DSCB AT XXXXXXXXXX, HIGH USED VTOC CHR=XXXXXXXXXX, FREE DSCBS=X
NBR CYL IN VOL=XXXXX, NBR TRKS PER CYL=XXXXX, BYTES PER TRK=XXXXX, DSCB/
DIRECTORY BLK/TRK=XXX, VSAM TIME STAMP=XXXXXXXXXXXXXXXX, VSAM OWNED=XXX
REL TRK OF CRA=XXXXX, CATALOG MATCH TIMESTAMP=XXXXXXXXXXXXXXXX
VTOC EXTENTS (CCHH) FROM XXXXXXXX TO XXXXXXXX, DEVICE=XXXX



VOL
     THIS COMMAND PRINTS A LIST OF ALL ONLINE DISK DRIVES, WITH ONE
     LINE PER DRIVE. THE FORMAT IS SHOWN BELOW, WITH X'S FOR THE
     VARIABLE DATA:

VOLSER=XXXXXX, DEVICE=XXXX, CUU=XXX, VTOCTTR=XXXXXX



CHR=CCCCHHHHRR-CCCCHHHHRR
     THIS COMMAND SETS UP A DISK EXTENT ON THE CURRENTLY ALLOCATED
     VOLUME. THE FIRST CCCCHHHHRR IS THE BEGINNING CYLINDER, HEAD,
     AND RECORD, AND IS REQUIRED. THE SECOND CCCCHHHHRR IS THE
     ENDING CYLINDER, HEAD, AND RECORD. IF THE ENDING CYLINDER, HEAD,
     RECORD IS OMITTED, THE FIRST IS USED FOR BOTH BEGIN AND END.
     IF THE BEGIN RECORD NUMBER IS GIVEN AS 00, IT WIL BE CHANGED
     TO 01. IF BOTH BEGIN AND END LOCATIONS ARE GIVEN, THEY MUST BE
     SEPARATED BY A DASH (-).



DSN
     THIS COMMAND PRESENTS A DISPLAY OF ALL DATASETS ON THE CURRENT
     VOLUME. THE CURRENT VOLUME IS THAT SPECIFIED BY A VOL COMMAND,
     OR FOUND BY A CAT COMMAND. ONE LINE IS PRINTED FOR EACH DATASET
     IN THE FORMAT BELOW:

DSNAME                                       DSORG RECFM  LRECL  BLKSIZE
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XXX   XXX XXXXXX   XXXXXX



DSN=CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
     THIS COMMAND ALLOCATES TO A DATASET ON THE CURRENT VOLUME, AS
     ESTABLISHED BY PRIOR USE OF A VOL OR CAT COMMAND. THE DATASET
     EXTENTS ARE SET UP FOR READING THE FILE, AND THE FIRST RECORD
     IN THE FILE WILL BE READ BY A FOLLOWING R COMMAND. DCB INFORMATION
     USED BY THE R, FMT, AND SCH COMMANDS IS SET TO THAT FOR THE
     FILE ALLOCATED, OVERRIDING PREVIOUS DCB INFORMATION. FOR A PDS,
     POSITIONING IS TO THE FIRST DATA RECORD AFTER THE DIRECTORY.
     INFORMATION IN THE DISPLAY BELOW IS TAKEN FROM THE FORMAT 1
     AND FORMAT 3 DSCB'S FOR THE FILE. THE DISPLAY IS SHOWN BELOW.
     THE EXTENT LINE WILL BE REPEATED FOR EACH EXTENT IN THE FILE.
     THE LAST LINE IS SHOWN ONLY FOR PDS'S:

FORMAT 1 DSCB AT XXXXXXXXXX, DSNAME=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    DSORG=XXXX, RECFM=XXX, LRECL=XXXXX, BLKSIZE=XXXXX, KEYLEN=XXX, RKP=X
    VOLSER=XXXXXX, NBR EXTENTS=XX, VOL SEQ=XXX, CREATED=XXXXX, EXPIRES=X
    LAST REFER=XXXXX, PASSWORD=XXXXXXXXXX, ALLOC IN=XXXXXX, SEC ALLOC=XX
    LAST BLK TTR=XXXXXX, FORMAT 3 DSCB ADDRESS=XXXXXXXXXX
        EXTENT TYPE=XXXX, SEQ=XXX, BEGIN CCHH=XXXXXXXX, END CCHH=XXXXXXX
OF THE NNNNN DIRECTORY BLOCKS ALLOCATED, NNNNN ARE IN USE



CHG
     THIS COMMAND CAUSES THE DISPLAY BELOW TO BE PRINTED. MOVE THE
     CURSOR UP TO THE DISPLAYED LINE, AND FILL IN THE UNDERSCORED
     FIELDS. FOR KEY/DATA ENTER A K FOR KEY, OR D FOR DATA TO SHOW
     WHETHER YOU WISH TO CHANGE THE KEY OR THE DATA PORTION OF THE
     RECORD. IN OFFSET, ENTER THE DECIMAL NUMBER OF THE LEFTMOST
     BYTE OF DATA TO BE CHANGED. THE FIRST POSITION OF THE RECORD
     WOULD BE SPECIFIED BY 1____. IN THE NEXT FIELD, PLACE AN X IF
     THE CHANGE DATA IS IN HEX, OR A C IF IT WILL BE IN CHARACTER
     FORM. THE FINAL FIELD CONTAINS THE DATA TO BE PLACED IN THE
     RECORD AT THE SPECIFIED LOCATION. IF X IS SPECIFIED, ENTER
     1-16 PAIRS OF HEX DIGITS, AND IF C IS SPECIFIED, ENTER 1-32
     CHARACTERS. THE CHANGE WILL BE MADE TO THE LAST DISPLAYED
     RECORD. IF FMT OR SCH IS IN EFFECT, AND THE BLOCK MATCHES
     THE DCB INFORMATION SET BY THE LAST CAT, DSN, OR DCB COMMAND,
     THE CURRENT LOGICAL RECORD IN THE BLOCK WILL BE CHANGED,
     OTHERWISE THE OFFSET WILL BE APPLIED TO THE BLOCK.

CHG> KEY/DATA _ OFFSET _____ IN X OR C _ TO ____________________________



FMT
     THIS COMMAND BRINGS UP THE DISPLAY BELOW, TO PERMIT SPECIFICATION
     OF PRINT FORMAT FOR FOLLOWING R COMMANDS. MOVE THE CURSOR TO THE
     DISPLAY AND ENTER DATA IN THE UNDERSCORED FIELDS. IN THE ID FIELD,
     ENTER A 2-DIGIT DECIMAL NUMBER, 01-20, SPECIFYING THE FORMAT
     NUMBER. UP TO 20 FORMATS CAN BE IN USE AT ONE TIME. IN THE SET/CLR
     FIELD ENTER AN S IF YOU WANT TO SET UP A FORMAT, OR A C IF YOU
     WANT TO CLEAR THE FORMAT. IF CLEARING THE FORMAT, NO OTHER DATA IS
     REQUIRED. IN THE KEY/DATA FIELD, ENTER A K FOR KEY FORMAT, OR A D
     FOR DATA RECORD FORMAT. THE STRT POS FIELD CONTAINS THE STARTING
     POSITION (BEGINNING WITH 1) IN THE RECORD. LENGTH IS THE NUMBER
     OF BYTES TO BE PRINTED. WHEN A FMT IS IN EFFECT, SUBSEQUENT R,
     P, AND CHG COMMANDS WILL OPERATE ON LOGICAL RECORDS WITHIN THE
     BLOCK, SO LONG AS IT CONFORMS TO THE DCB INFORMATION SET UP BY
     THE LAST CAT, DSN, OR DCB COMMAND.

FMT> ID(01-20)=__, SET/CLR=_, KEY/DATA=_, STRT POS=_____, LENGTH=_____


DCB
     THIS COMMAND IS USED TO SET UP DCB INFORMATION FOR USE WITH THE
     FMT, R, AND CHG COMMANDS TO OPERATE ON LOGICAL RECORDS. IT
     OVERRIDES THE DCB INFORMATION SET UP BY ANY PRECEDING CAT OR
     DSN COMMANDS. THE DISPLAY BELOW IS PRESENTED, AND YOU SHOULD
     MOVE THE CURSOR TO THIS LINE AND ENTER DATA IN THE UNDERSCORED
     FIELDS. RECFM MAY BE F, FB, V, VB, OR U. LLRECL IS THE LOGICAL
     RECORD LENGTH, AND BLKSIZE IS THE BLOCK SIZE.

DCB> RECFM=__, LRECL=_____, BLKSIZE=_____, KEYLEN=___



SCH
     THIS COMMAND CAUSES THE LINES BELOW TO BE PRINTED. MOVE THE
     TO THE SECOND LINE AND ENTER DATA OVER THE UNDERSCORES. THE
     SET/CLR FIELD PERMITS YOU TO SET UP SEARCH PARAMETERS (S), OR
     TURN OFF SEARCHING (C). THE KEY/DATA FIELD MUST BE K IS THE
     COMPARISON FIELD IS IN THE KEY RECORD, OR D IF IT IS IN THE
     DATA RECORD. THE START FIELD SPECIFIES THE STARTING POSITION
     OF THE ARGUMENT FIELD (STARTING WITH 1), AND LENGTH IS THE
     LENGTH OF THE ARGUMENT FIELD (1-16). COMPARE IS THE COMPARISON
     TO BE USED, =, <, >, <=, >=, OR <>. THE CHAR/HEX MUST BE C IF
     DATA IS GIVEN IN CHARACTER FORM, OR X IF DATA IS GIVEN IN HEX.
     THE DATA FIELD CONTAINS THE DATA TO BE USED TO COMPARE AGAINST
     RECORDS READ FROM THE CURRENT EXTENT. IF X IS SPECIFIED, DATA
     MUST BE IN PAIRS OF HEX DIGITS, OTHERWISE IN CHARACTERS. IF
     HEX DATA IS USED, THE LENGTH CAN ONLY BE 1-8 BYTES.

     SET/CLR  KEY/DATA START LENGTH COMPARE CHAR/HEX DATA
SCH>    _        _     _____   __     __       _     ________________



CAT=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
     THIS COMMAND ALLOCATES TO THE SPECIFIED DATASET USING THE CATALOG.
     FIRST, THE DATASET ENTRY IS FOUND IN THE CATALOG. NEXT, THE VOLUME
     IS ALLOCATED, AND A VOLUME DISPLAY IS PRODUCED (SEE VOL). AFTER
     THE VOLUME IS ALLOCATED, THE DATASET IS ALLOCATED, AND A DATASET
     DISPLAY IS PRODUCED (SEE DSN). THIS COMMAND CONBINES ALL THE
     FUNCTIONS OF THE VOL AND DSN COMMANDS.



REWRITE
     THIS COMMAND CAUSES THE LAST RECORD READ TO BE REWRITTEN. BEFORE
     USING THIS COMMAND AFTER CHANGING THE DATA RECORD, USE THE P
     COMMAND TO VALIDATE THE CHANGES.



IF AN I/O ERROR OCCURS DURING DISK I/O OPERATIONS, THE DISPLAY BELOW
WILL BE SHOWN:

*** I/O ERROR: ECBCC=XX, CSW=XXXXXXXX XXXXXXXX, FAILING CCW=XXXXXXXX XXX
               SENSE=XXXX, COMMAND CHAIN IS XXXXXXXX, SEARH ADDRESS=XXXX
               BYTES READ=XXXXX, DATA AT CCW ADDRESS=XXXXXXXX XXXXXXXX X
./ ADD NAME=COBDECML 0100-02092-02092-1412-00063-00063-00000-BC0THOR
//RUX1077W JOB (1113010-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//********************************************************************
//* ADDS DECIMAL BYTE LOCATION RELATIVE TO POSITION 1 WITHIN THE 01  *
//* LEVEL FOR EACH DATA ITEM IN A COBOL COMPILE LISTING. THE DECIMAL *
//* FIELD LENGTH IS ALSO ADDED FOLLOWING THE DISPLACEMENT WITH A     *
//* SEPARATING HYPHEN. TO ACCOMODATE THE ADDITIONAL FIELDS, THE COBOL*
//* FIELD IDENTIFIER IS OVERLAID. SINCE THIS IS USED ONLY WITH A PMAP*
//* IT SHOULD CAUSE NO PROBLEM.                                      *
//*                                                                  *
//* PROCEDURES: THE FIRST STEP, COB, COMPILES THE PROGRAM, PLACING   *
//* LISTING IN A TEMPORARY DISK DATASET CALLED &&COBPRNT. THE SECOND *
//* STEP, COBDECML, READS &&COBPRNT, ADDS DECIMAL DISPLACEMENTS, AND *
//* WRITES A NEW LISTING DATASET VIA THE OUTPUT1 DD STATEMENT. THE   *
//* &&COBPRNT LISTING FILE CONTAINS 121 BYTE LOGICAL RECORDS, AND THE*
//* NEW LISTING FILE CREATED BY COBDECML HAS 133 BYTE RECORDS.       *
//* IN ADDITION, COBPRNT CALCULATES AND PRINTS THE DECIMAL LOCATION  *
//* FOR EACH DATA FIELD WITHIN ITS 01 LEVEL. THE DECIMAL LOCATION IS *
//* GIVEN RELATIVE TO 1 RATHER THAN TO ZERO, SO THAT IT IS EASIER TO *
//* USE WITH STANDARD FILE DUMP UTILITIES.                           *
//*                                                                  *
//* IF THE COBOL COMPILE LISTING IS AVAILABLE FROM ANOTHER SOURCE,   *
//* DELETE THE COB STEP AND CHANGE THE INPUT1 DD STATEMENT IN THE    *
//* COBDECML STEP TO POINT TO THE DISK FILE CONTAINING THE COBOL     *
//* LISTING.                                                         *
//*                                                                  *
//* BEFORE USE, CHANGE THE JOB STATEMENT, THE SYSIN DD STATEMENT FOR *
//* THE COB STEP, AND THE OUTPUT1 DD STATEMENT IN THE COBDECML STEP  *
//* FOR YOUR USE.                                                    *
//*                                                                  *
//* IF THERE ARE ANY QUESTIONS, CONTACT DICK THORNTON AT 287-2480    *
//********************************************************************
//*
//*        COMPILE TO CREATE LISTING ON DISK
//*
//COB      EXEC PGM=CPXUPTSM,REGION=300K,PARM=(CLIST,APOST,CSYNTAX,
//         NOOPT,NODUMP,NOLOAD,NODECK,NOXREF,SXREF,NOPMAP,
//         NOSTATS,'SIZE=(296K,96K)')
//SYSIN1   DD  UNIT=DISK,SPACE=(CYL,(10,5))
//SYSIN2   DD  UNIT=DISK,SPACE=(CYL,(10,5))
//SYSPRINT DD  DSN=&&COBPRNT,DISP=(NEW,PASS,DELETE),
//         UNIT=DISK,SPACE=(TRK,(15,5),RLSE)
//SYSPUNCH DD  DUMMY
//SYSLIN   DD  DUMMY
//SYSLIB   DD  DSN=PROD.FILEDESC,DISP=SHR
//         DD  DSN=TEST.FILEDESC,DISP=SHR
//         DD  DSN=UCC10.COPYLIB,DISP=SHR
//SYSUT1   DD  UNIT=DISK,SPACE=(CYL,(1,1))
//SYSUT2   DD  UNIT=DISK,SPACE=(CYL,(1,1))
//SYSUT3   DD  UNIT=DISK,SPACE=(CYL,(1,1))
//SYSUT4   DD  UNIT=DISK,SPACE=(CYL,(1,1))
//SYSIN    DD  DSN=USER02.TSO.DUMPCLAS(ABNDCOB),DISP=SHR
//*
//*        ADD DECIMAL DISPLACEMENTS TO LISTING
//*
//COBDECML EXEC PGM=COBDECML
//STEPLIB  DD   DSN=TEST.LOAD,DISP=SHR
//SYSUDUMP DD   SYSOUT=*
//INPUT1   DD   DSN=&&COBPRNT,DISP=(OLD,DELETE,DELETE)
//OUTPUT1  DD   DSN=USER02.ABNDCOB.LIST,DISP=(NEW,CATLG,DELETE),
//         UNIT=SYSTS,SPACE=(TRK,(15,5),RLSE),
//         DCB=(RECFM=FBA,LRECL=133,BLKSIZE=19019)
./ ADD NAME=COBOL2   0100-94137-94137-1156-00112-00112-00000-USER02
          ***** COBOL II Release 4.0 at Blue Cross of VA *****

 The following compile PARM defaults are in effect. Those parameters
 having *** to the right differ from the defaults supplied with the
 compiler as shipped by IBM. You may override the defaults below as
 desired to meet your needs:

     NOADV               ***
       QUOTE
     NOAWO
       BUFSIZE(4096)
     NOCMPR2
     NOCOMPILE(E)        ***
       DATA(31)
     NODBCS
     NODECK
     NODUMP
     NODYNAM
     NOEXIT
     NOFASTSRT
     NOFDUMP
       FLAG(I)
     NOFLAGMIG
     NOFLAGSAA
     NOFLAGSTD
       LANGUAGE(EN)
       LIB               ***
       LINECOUNT(60)
       LIST              ***
       MAP               ***
     NONAME
     NONUMBER
       NUMPROC(MIG)      ***
       OBJECT
     NOOFFSET
       OPTIMIZE          ***
       OUTDD(SYSOUT)
       RENT              ***
       RESIDENT          ***
     NOSEQUENCE          ***
       SIZE(MAX)
       SOURCE
       SPACE(1)
     NOSSRANGE
       TERM              ***
     NOTEST
       TRUNC(BIN)        ***
       VBREF             ***
     NOWORD
       XREF(FULL)        ***
       ZWB

  NOTES:
     Most programs at Blue Cross use single quotes (apostrophes) around
     non-numeric literals. If this applies to you, specify APOST.

     If you wish your programs to run above the 16-megabyte line or if
     they will run under IMS you must use the RESIDENT and RENT compile
     PARMs.

     If you compile for XPEDITER testing you must use the MAP, SOURCE,
     NONUMBER, NOTEST, AND NOFDUMP parameters. In addition, either
     OFFSET or LIST is required. If OPTIMIZE is specified, LIST must
     also be specified for XPEDITER.

 If compile PARM defaults are changed, please be aware of the following
 precedence rules which are enforced by the COBOL II compiler:

  ---------------------------------------------------------------------
  |If this is specified   |These are forced ON   |These are ignored   |
  |-----------------------|----------------------|--------------------|
  |TEST                   |NOFDUMP               |FDUMP               |
  |                       |OBJECT                |NOOBJECT            |
  |                       |RES                   |NORES               |
  |                       |NOOPTIMIZE            |OPTIMIZE            |
  |-----------------------|----------------------|--------------------|
  |RENT                   |NORES                 |RES                 |
  |-----------------------|----------------------|--------------------|
  |DYNAM                  |NORES                 |RES                 |
  |-----------------------|----------------------|--------------------|
  |OFFSET                 |NOLIST                |LIST                |
  |-----------------------|----------------------|--------------------|
  |CMPR2                  |NOFLAGSTD             |FLAGSTD             |
  |                       |NOFLAGSAA             |FLAGSAA             |
  |                       |NODBCS                |DBCS                |
  |-----------------------|----------------------|--------------------|
  |NOCMPR2                |NOFLAGMIG             |FLAGMIG             |
  |-----------------------|----------------------|--------------------|
  |WORD                   |NOFLAGSTD             |FLAGSTD             |
  |-----------------------|----------------------|--------------------|
  |FLAGSTD                |NOFLAGSAA             |FLAGSAA             |
  |                       |NOFLAGMIG             |FLAGMIG             |
  |                       |NODBCS                |DBCS                |
  |-----------------------|----------------------|--------------------|
  |FLAGSAA                |NOFLAGMIG             |FLAGMIG             |
  |-----------------------|----------------------|--------------------|
  |DBCS                   |NOFLAGMIG             |FLAGMIG             |
  ---------------------------------------------------------------------

  In addition to the compile PARM defaults, Blus Cross has chosen the
  following compiler options which can only be changed by use of an
  IGZEOPT module:
                          MIXRES
                          LIBKEEP


  The following VS COBOL II Application Programming manuals are of
  general use to those who program in COBOL II:

    GC26-4047   Language Reference          ($7.15)
    SC26-4045   Guide for MVS and CMS       ($18.25)
    SC26-4049   Debuggung                   ($12.75)
./ ADD NAME=COBREAD0 0100-99125-99125-1407-00111-00111-00000-BC0THOR
         TWA TOOLBOX PACKAGE DOCUMENTATION

         A COPY OF THIS DOCUMENT IS CONTAINED IN THE DISTRIBUTION PDS
         AS MEMBER DOC.


         REX WIDMER / RON STUBBLEFIELD

         TRANS WORLD AIRLINES INC.
         KANSAS CITY ADMINISTRATIVE CENTER
         11500 AMBASADOR DRIVE
         KANSAS CITY, MO 64195

         816-464-6671
         816-464-6512

         THIS PACKAGE IS DISTRIBUTED WITHOUT CHARGE TO MEMBERS
         OF SHARE AND GUIDE. IT IS DISTRIBUTED ON AN AS IS,
         WHERE IS BASIS, WITHOUT EXPRESSED OR IMPLIED WARRANTY
         OF ANY KIND.  IT IS DISTRIBUTED IN HOPE THAT IT MAY SAVE
         OTHER MEMBERS OF THE PROJECT SOME WHEEL RE-INVENTING...

         THE PACKAGE CONSISTS OF THE FOLLOWING PROGRAMS....

           WHATSNEW  THIS PROGRAM ANALYZES A PDS AND LISTS
                     THE MEMBERS IN MOST RECENTLY CHANGED ORDER
                     A CHANGE IS CONSTITUTED TO MEAN A RE-LINKEDIT,
                     OR A CHANGE BY SUPERZAP.  IT IS DRIVEN BY THE
                     IDR DATA RECORDS WITHIN THE PDS.

                       LANGUAGE  OS BAL

           WHEREUSD  THIS PROGRAM ANALYZES A PDS AND LISTS ALL MEMBERS
                     WHICH CONTAIN A REFERENCE TO A GIVEN EXTERNAL
                     SYMBOL.

                       LANGUAGE  OS BAL

           COMPARE   THIS PROGRAM ANALYZES GIVEN MEMBERS WHICH EXIST IN
                     A PAIR OF PDS'S.  THE MEMBERS ARE CHECKED FOR
                     DIFFERENCES AND FOR ADHERANCE TO INSTALLATION
                     STANDARDS AS A PRE-IMPLEMENTATION Q/C MEASURE.

                       LANGUAGE  OS BAL
                       MEMBERS / CSECTS
                          COMPARE  -- MAINLINE
                          COBFMT   -- SUBROUTINE
                          COMPDS   -- SUBROUTINE
                          COMPTBL  -- SUBROUTINE
                          PRTTBL   -- SUBROUTINE

           COBREAD   THIS PROGRAM ANALYZES A PDS AND LISTS ALL MEMBERS
                     ALONG WITH THE COBOL ATTRIBUTES ASSOCIATED WITH
                     THE MAIN CSECT WITHIN THE MODULE.  SUCH ITEMS AS
                     COBOL /STATE/, /FLOW/, /OPTIMIZATION/, /TEST/,
                     /ENDJOB/, AND /DYNAM/ ARE LISTED.
                     THE ABILITY TO SELECTIVELY ANALYZE A SINGLE
                     MEMBER IS ALSO SUPPORTED.

                       LANGUAGE  OS BAL
                       MEMBERS / CSECTS
                          COBREAD  -- MAINLINE
                          COBFMT   -- SUBROUTINE TO COBREAD

                       NOTES...  REPLACES EARLIER PROGRAM /COBAUDIT/
                          THIS IS AN ENHANCED VERSION WITH CSECT BY
                          CSECT SCANNING ABILITY

           XREF1     THIS PROGRAM SCANS A PDS AND PRODUCES INTERMEDIATE
                     RECORDS TO ALLOW XREF2 TO CREATE A GLOBAL CROSS-
                     REFERENCE OF EXTERNAL SYMBOLS IN THE PDS.  THIS
                     REPORT PROVIDES INFORMATION OF THE FORM  CSECT IS
                     CONTAINED IN THE FOLLOWING LOAD MODULES...

                       LANGUAGE  OS BAL

           XREF2     THIS IS THE REPORT PROGRAM TO PROCESS THE OUTPUT
                     OF XREF1.  IT MAY HAVE MULTIPLE XREF1 FILES AS
                     INPUT, ALL INPUTS WILL BE MERGED WITHIN THE REPORT
                     GENERATION PROCESS.

                       LANGUAGE  PL/I OPTIMIZER / CHECKOUT COMPILER

           INSTALLATION INSTRUCTIONS....

                     THE PACKAGE IS IN THE FORM OF IEBUPDTE SYSIN.
                     IT REQUIRES ABOUT 2.5 MEGABYTE OF DISK STORAGE
                     TO HOLD THE PDS (1 3350 CYLINDER AT 80 X 19040).

                     ONCE THE PDS HAS BEEN CREATED ON YOUR SYSTEM THE 5
                     PROGRAMS MAY BE RECOMPILED.  ALL OF THE PROGRAMS
                     EXCEPT XREF2 ARE WRITTEN IN OS/VS ASSEMBLER
                     LANGUAGE.  THE PRIVATE MACROS UTILIZED WITHIN THE
                     PROGRAM ARE INCLUDED IN THE PDS.  THE DISTRIBUTION
                     PDS SHOULD BE INCLUDED WITHIN THE SYSLIB DD-CARD
                     SPECIFICATION FOR THE ASSEMBLIES.  PROGRAM XREF2
                     IS WRITTEN IN PL/I UTILIZING THE OPTIMIZING
                     COMPILER.  IF THE OPTIMIZER IS NOT AVAILABLE, THE
                     F LEVEL PL/I (FREEBEE) MAY BE USED WITH MINOR
                     CHANGES TO THE BUILTIN FUNCTION NAMES.  IF PL/I IS
                     NOT AVAILABLE IN ANY FORM THE PROGRAM MAY EASILY BE
                     RECODED IN COBOL, OR IN BAL.
                     EXECUTION JCL AND INSTRUCTIONS ARE INCLUDED IN THE
                     COMMENT BLOCK AT THE START OF EACH PROGRAM.

                     IF WE MAY PROVIDE ADDITIONAL INFORMATION OR
                     ASSISTANCE, DON'T HESITATE TO CALL OR WRITE.


                                                 REX WIDMER
                                                 RON STUBBLEFIELD
./ ADD NAME=COB2ASM  0100-02092-02092-1413-00091-00091-00000-BC0THOR
                             COB2ASM

 PROGRAM TO CREATE AN ASSEMBLER RECORD DESCRIPTION USING A COBOL
 RECORD DESCRIPTION AS INPUT. THE INPUT FILE IS EXPECTED TO BE A
 VALID PORTION OF A COBOL PROGRAM WITH THE FORMAT:
   COL  1-6  LINE NUMBER OR BLANK
   COL   7   CONTINUATION/COMMENT INDICATOR. AN * HERE INDICATES
             A COMMENT STATEMENT (WHICH IS IGNORED). ANY OTHER
             VALUE IN THIS FIELD WILL RESULT IN AN ERROR MESSAGE
             AND U0888 ABEND.
   COL  8-11 MARGIN A. THE FIRST NON-COMMENT RECORD IN THE INPUT
             FILE MUST CONTAIN "01  " IN MARGIN A. ALL OTHER NON-
             COMMENT STATEMENTS ON INPUT MUST CONTAIN BLANKS IN
             MARGIN A OR THE PROGRAM WILL WRITE AN ERROR MESSAGE
             AND ABEND WITH U0888.
   COL 12-72 MARGIN B. CONTAINS VALID COBOL DATA DIVISION STATE-
             MENTS. AFTER THE INITIAL 01 LEVEL, ONLY LEVELS 02-49
             AND 88 ARE VALID. ANY OTHER LEVEL NUMBER WILL CAUSE
             AN ERROR MESSAGE AND U0888 ABEND.
   COL 73-80 UNUSED. MAY CONTAIN ANY DESIRED DATA.

 ONLY A SINGLE RECORD DESCRIPTION IS PROCESSED, AND THE FIRST
 NON-COMMENT INPUT RECORD MUST CONTAIN 01 IN COLUMNS 8 AND 9,
 AND BLANKS IN COLUMNS 10 AND 11. THE INPUT MUST CONTAIN THIS
 INITIAL 01 LEVEL ITEM, AND AN ERROR MESSAGE WILL BE WRITTEN
 FOLLOWED BY A U0888 ABEND IF IT IS MISSING. IF A COBOL COPY
 BOOK WITHOUT AN 01 LEVEL IS TO BE PROCESSED, ADD AN 01 ITEM.

 THE 66 LEVEL IS NOT ACCEPTABLE AS INPUT AND SHOULD BE REMOVED
 BEFORE PROCESSING.

 REDEFINES STATEMENTS ARE ACCEPTABLE AS INPUT, BUT WILL BE
 IGNORED, WITH ASSEMBLER OUTPUT STATEMENTS PRODUCED ONLY FOR THE
 INITIAL FIELD DEFINITION.

 88 CONDITION NAME ENTRIES WILL CAUSE GENERATION OF ASSEMBLER
 EQU STATEMENTS ONLY FOR THOSE HAVING 1-BYTE VALUE CLAUSES.
 THIS MEANS SINGLE DIGIT OR CHARACTER VALUES, AND DOES NOT
 INCLUDE THE WORDS ZERO(S) OR SPACE(S).

 FOR ITEMS CONTAINING OCCURS IN THE DESCRIPTION, THE OCCURRING
 ITEM IS DESCRIBED ONCE IN THE OUTPUT FILE, AS-IS, THEN IS
 THEN IS FOLLOWED BY AN ITEM WHOSE SIZE IS THAT OF THE OCCURRING
 ITEM, AND WITH A REPLICATION FACTOR ONE LESS THAN THE ORIGINAL
 ITEM.

 THE ASSEMBLER OUTPUT WILL CONTAIN ONE STATEMENT FOR EACH INPUT
 LEVEL NUMBER EXCEPT REDEFINES STATEMENTS. PROCESSING WILL
 TERMINATE ABNORMALLY WITH AN ERROR MESSAGE IF A 66 LEVEL IS
 FOUND, IF MULTIPLE 01 LEVELS ARE FOUND, IF COLUMN 7 CONTAINS
 OTHER THAN AN *, OR IF MARGIN A IS NON-BLANK.

 THE INPUT FILE IS EXPECTED TO CONTAIN ONLY CLEAN, SYNTACTICALLY
 CORRECT COBOL DATA DIVISION STATEMENTS AS NOTED ABOVE. SOME
 PROTECTIVE EDITING IS DONE, BUT INCORRECT COBOL STATEMENTS WILL
 CREATE UNPREDICTABLE OUTPUT OR U0888 ABENDS WITH A MESSAGE.

 A MAXIMUM OF 1,000 INPUT STATEMENTS CAN BE PROCESSED, THOUGH
 THIS CAN BE INCREASED BY INCREASING THE SIZE OF THE GETMAIN.

 ASSEMBLER OUTPUT STATEMENTS WILL CONTAIN A BLANK LABEL FIELD
 WHICH MUST BE SUPPLIED BY THE USER IN A LATER EDIT SESSION.
 THE OP-CODE FIELD WILL CONTAIN DS FOR LEVELS 01-49, AND EQU FOR
 LEVEL 88. FOR GROUP ITEMS, THE OPERAND FIELD WILL CONTAIN 0CL
 FOLLOWED BY THE LENGTH OF THE GROUP ITEM. ELEMENTARY ITEMS WILL
 CONTAIN CL, XL, OR PL FOLLOWED BY THE FIELD LENGTH OR MERELY
 H, F, OR 2F DEPENDING ON THE PICTURE. THE COMMENT FIELD WILL
 CONTAIN THE COBOL LEVEL NUMBER, DATANAME, AND NUMBER OF OCCURS
 IF MORE THAN 1. COLUMNS 72-80 WILL BE BLANK.

 EXAMPLE JCL:

//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//********************************************************************
//* READS A SINGLE COBOL 01 LEVEL RECORD DESCRIPTION FROM ITS INPUT1 *
//* FILE AND CREATES AN ASSEMBLER EQUIVALENT (WITHOUT LABELS) IN THE *
//* OUTPUT1 FILE. EDIT THE OUTPUT1 DATASET AND ADD LABELS AFTERWARD. *
//* OUTPUT FILES MUST BE FIXED LENGTH WITH 80-BYTE LOGICAL RECORDS.  *
//* THE PRINT1 OUTPUT IS AN ERROR MESSAGE LOG FOR ABEND MESSAGES.    *
//********************************************************************
//COB2ASM  EXEC PGM=COB2ASM
//STEPLIB  DD   DSN=TEST.LOAD,DISP=SHR
//SYSUDUMP DD   SYSOUT=*
//ABNLTERM DD   SYSOUT=*
//PRINT1   DD   SYSOUT=*,DCB=BLKSIZE=80
//INPUT1   DD   DSN=USER02.TSO.COBOL(????????),DISP=SHR
//OUTPUT1  DD   DSN=USER02.????????.ASM,DISP=(NEW,CATLG,DELETE),
//         UNIT=SYSTS,SPACE=(TRK,(2,1),RLSE),
//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=19040)
./ ADD NAME=COMPASM  0100-02092-02092-1413-00042-00042-00000-BC0THOR
                  'COMPARE ASSEMBLER SOURCE PROGRAMS'
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*   TWO ASSEMBLER SOURCE PROGRAM FILES ARE COMPARED. THE FILES MUST BE
* FIXED LENGTH WITH 80 BYTE RECORDS. RECORDS ARE READ AND COMPARED
* UNTIL A MISMATCH IS FOUND. COMPARISON IS MADE ON COLUMNS 1-72. WHEN
* RECORDS DO NOT MATCH, A FOUR-LINE MESSAGE IS WRITTEN, SHOWING BOTH
* RECORDS, AND THEIR SEQUENCE NUMBERS. A READ IS THEN ISSUED TO THE
* TERMINAL. THE USER MUST RESPOND WITH "1" IF THE INPUT1 FILE IS TO
* BE READ, A "2" IF THE INPUT2 FILE IS TO BE READ, AN "E" IF THE
* EXECUTION IS TO BE TERMINATED. ANY OTHER REPLY WILL RESULT IN BOTH
* INPUT FILES BEING READ.
*
* THIS PROGRAM IS DESIGNED TO WORK WITH TSO ONLY
*
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*   EXAMPLE OF USE:
*
*   ALLOC F(INPUT1) DA(SOURCE1.ASM)
*   ALLOC F(INPUT2) DA(SOURCE2.ASM)
*   CALL 'SYS1.TECHLOAD(COMPASM)'
*
*   THE PROGRAM WILL BEGIN COMPARING THE RECORDS IN THE TWO FILES
*   UNTIL EOF ON BOTH FILES, OR A MISMATCH OCCURS. WHEN A MISMATCH
*   IS FOUND, BOTH RECORDS WILL BE RETURNED TO THE SCREEN WITH
*   A FOUR-LINE MESSAGE SIMILAR TO:
*
*      INPUT1 RECORD NUMBER IS 00014850
* READREC  GET INPUT1                  READ A RECORD
*      INPUT2 RECORD NUMBER IS 00014850
* READREC  GET INPUT1,RECORD           READ A RECORD
*
*
*   FOLLOWING THIS, THE PROGRAM AWAITS A RESPONSE FROM THE USER.
*   VALID RESPONSES ARE: "1" TO READ INPUT1 ONLY, "2" TO READ
*   INPUT2 ONLY, OR "E" TO END THE COMPARE RUN. ANY OTHER RESPONSE
*   WILL CAUSE BOTH INPUT FILES TO BE READ. AFTER THE READ(S), THE
*   PROGRAM CONTINUES COMPARISON AS ABOVE UNTIL THE NEXT MISMATCH
*   OR EOF ON BOTH FILES.
*
./ ADD NAME=COPYDUMP 0100-88061-88061-0950-00046-00046-00000-USER02
      *** INSTRUCTIONS FOR COPYDUMP ***

   THIS PROGRAM COPIES A FILE CONTAINING ASA CONTROL CHARACTERS,
 MACHINE CODE CONTROL CHARACTERS, OR A COMBINATION OF BOTH, TO AN
 OUTPUT DATASET DEFINED (HARD-CODED) AS RECFM=FB,LRECL=133. INPUT
 FILE RECFM=FB IS HARD-CODED. THE INPUT FILE IS ASSUMED TO CONTAIN
 CONTROL CHARACTERS IN THE FIRST BYTE OF EACH RECORD. THE OUTPUT
 FILE IS DEFINED AS FB, RATHER THAN FBA, TO PERMIT EDITING THE
 FILE INCLUDING THE CONTROL CHARACTERS. USE OF A DD CARD SPECIFYING
 ASA CONTROL CHARACTERS WILL PERMIT CORRECT PRINTING.
  OUTPUT CONTROL CHARACTERS ARE COPIED FROM THE INPUT RECORDS WHEN
 A VALID ASA CONTROL CHARACTER IS FOUND (BLANK, +, -, 0, OR 1). WHEN
 A VALID MACHINE CODE CONTROL CHARACTER (HEX 01, 09, 11, 19, 89, 0B,
 13, 1B, 8B) IS FOUND, ONE OR TWO LINES OF OUTPUT ARE CREATED WITH
 ASA CONTROL CHARACTERS TO DUPLICATE THE PRINT FORMAT. IF THE FIRST
 CHARACTER OF THE INPUT RECORD IS NONE OF THE ABOVE ASA OR MACHINE
 CONTROL CHARACTERS, THE LINE IS WRITTEN WITH AN ASA PRINT-AND-SKIP-1
 CHARACTER (BLANK) IN ITS FIRST POSITION.
    THE LAST 8 BYTES OF EACH OUTPUT RECORD ARE CLEARED TO BLANKS TO
 PERMIT SIMPLE ADDITION OF LINE NUMBERS DURING EDITING, IF DESIRED.
    THIS PROGRAM IS INTENDED PRIMARILY FOR THE CREATION OF CLASSROOM
 HANDOUTS FOR A DUMP CLASS, WHERE COMPILE LISTINGS, ASSEMBLY LISTINGS,
 JCL, AND DUMP LISTINGS ARE COMBINED INTO A SINGLE DATASET TO BE
 PRINTED FOR THE CLASS.
    JCL EXAMPLE (TO EXECUTE COPYDUMP):

 //RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
 //   NOTIFY=USER02,MSGCLASS=Y
 //JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
 //         EXEC PGM=COPYDUMP
 //STEPLIB  DD DSN=SYS1.TECHLOAD,DISP=SHR
 //SYSUDUMP DD SYSOUT=A
 //INPUT1   DD DSN=USER02.ABNDCOB.LIST,DISP=SHR
 //OUTPUT1  DD DSN=USER02.DUMPCLAS,DISP=SHR


    JCL EXAMPLE (TO PRINT THE OUTPUT FROM COPYDUMP):

 //RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
 //   NOTIFY=USER02,MSGCLASS=Y
 //JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
 //         EXEC PGM=IEBGENER
 //SYSIN    DD DUMMY
 //SYSPRINT DD SYSOUT=A
 //SYSUT1   DD DSN=USER02.DUMPCLAS,DISP=SHR,DCB=(RECFM=FBA)
 //SYSUT2   DD SYSOUT=A,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133)
./ ADD NAME=COPYFIL  0100-02092-02092-1413-00192-00192-00000-BC0THOR
                   ***** INSTRUCTIONS FOR COPYFIL *****
*
***********************************************************************
*                                                                     *
* GENERAL FILE COPY UTILITY TO COPY SELECTED RECORDS FROM AN          *
* INPUT FILE TO AN OUTPUT FILE. CONTROL CARDS ARE USED TO SPECIFY     *
* THE RECORDS TO BE COPIED. FILE PARAMETERS ARE OBTAINED FROM THE     *
* COPYIN AND COPYOUT DD CARDS. A LISTING IS PRINTED TO SHOW THE       *
* NUMBER OF RECORDS READ, TOTAL RECORDS WRITTEN TO THE OUTPUT FILE,   *
* AND TOTALS BY TYPE, IF SELECTION CARDS ARE USED. THE PRINCIPAL USE  *
* OF THIS PROGRAM IS IN THE CREATION OF MINIATURE TEST FILES. SINCE   *
* RECORDS ARE NOT FORMATTED FOR PRINT, CPU UTILIZATION IS MUCH LOWER  *
* THAN WHEN DUMPFIL IS USED FOR THIS PURPOSE.                         *
*                                                                     *
***********************************************************************
* * * *  USE  OF  COPYFIL  * * *                                      *
* 1.  COPYFIL IS A GENERAL PURPOSE FILE COPY UTILITY WHICH WILL COPY  *
*        SEQUENTIAL AND ISAM DATASETS. AN ISAM INPUT WITH SEQUENTIAL  *
*        OUTPUT, OR SEQUENTIAL INPUT WITH ISAM OUTPUT MAY BE DONE,    *
*        AS WELL AS SEQUENTIAL TO SEQUENTIAL AND ISAM TO ISAM.        *
* 2.  EXECUTION - A PROC NAMED COPYFIL IS EXECUTED, WHICH REQUIRES A  *
*        DD CARD FOR THE FILE TO BE COPIED. THE DDNAME FOR THIS CARD  *
*        MUST BE COPYIN. DCB PARAMETERS MAY BE SPECIFIED IN THE DD    *
*        CARD, OTHERWISE THE FILE LABEL RECFM, LRECL, AND BLKSIZE WILL*
*        BE USED. IF NON-STANDARD OR UNLABELLED TAPE IS TO BE COPIED, *
*        DCB PARAMETERS MUST BE SPECIFIED. IF FILE CHARACTERISTICS ARE*
*        UNKNOWN, ANY FILE MAY BE COPIED BY SPECIFYING RECFM=U AND    *
*        BLKSIZE=32760 FOR TAPE, OR THE MAXIMUM TRACK SIZE FOR DISK.  *
*        WHEN RECFM=U IS SPECIFIED, THE COPY OUTPUT WILL BE PHYSICAL  *
*        BLOCKS, RATHER THAN LOGICAL RECORDS. THE OUTPUT FILE MUST BE *
*        DEFINED BY A DD CARD WITH DDNAME COPYOUT, WHICH MUST SPECIFY *
*        ALL NECESSARY DCB PARAMETERS, SUCH AS RECFM, LRECL,          *
*        BLKSIZE, RKP, CYLOFL, KEYLEN, DSORG, ETC.                    *
* 3.  IF CONTROL CARDS ARE TO BE USED, THEY ARE ENTERED FOLLOWING A   *
*        //SYSIN DD *                                                 *
*        THE SYSIN DD CARD MAY BE OMITTED IF NO CONTROL CARDS ARE USED*
* 4.  THE OPTION CARD IS FIXED FORMAT. ONLY ONE IS PERMITTED PER      *
*        RUN. IF NO CONTROL CARDS ARE ENTERED, THE INPUT AND OUTPUT   *
*        FILES ARE ASSUMED TO BE PHYSICALLY SEQUENTIAL.               *
*        THE OPTION CARD FORMAT IS:                                   *
*                                                                     *
*        COL 1:     *                                                 *
*        COL 4-10:  NUMBER OF RECORDS TO COPY IN TOTAL. IF BLANK, THE *
*                   OUTPUT FILE WILL CONTAIN ALL RECORDS FROM THE     *
*                   INPUT FILE WHICH ARE SELECTED FOR PRINTING. IF    *
*                   USED, THE NUMBER MUST BE RIGHT JUSTIFIED WITH     *
*                   LEADING ZEROS.                                    *
*        COL 12-13: INPUT FILE TYPE, BLANK=PHYSICALLY SEQUENTIAL,     *
*                   VS=VARIABLE SPANNED, IS=ISAM.                     *
*        COL 15-16: OUTPUT FILE TYPE, IS = ISAM, ELSE LEAVE BLANK.    *
*                   OTHER PARAMETERS WILL BE PICKED UP FROM THE DD    *
*                   CARD.                                             *
*        COL 18-22: STARTING RECORD NUMBER IN FILE. IF BLANK, DUMP    *
*                   WILL BEGIN WITH THE FIRST RECORD IN THE FILE.     *
*        COL 24-79: STARTING GROUP KEY FOR ISAM. ANY VALUE WITH NO    *
*                   IMBEDDED BLANKS. DEFAULT IS BEGINNING OF FILE.    *
* 5.  RECORD SELECTION CARD. THIS CARD IS OPTIONAL, SPECIFIES THE     *
*        CONDITIONS UNDER WHICH RECORDS ARE TO BE COPIED. IF OMITTED, *
*        ALL RECORDS ARE COPIED. THE FORMAT IS FIXED, AND UP TO 25    *
*        CARDS MAY BE ENTERED PER RUN. NOTE THAT WHEN MULTIPLE CARDS  *
*        ARE JOINED TO FORM ONE SELECTION GROUP BY THE USE OF THE     *
*        WORD 'AND' IN COLUMNS 75-77, THE NUMBER OF RECORDS TO BE     *
*        SELECTED ARE TAKEN FROM THE LAST CARD IN THE GROUP.          *
*        COL 1:     S                                                 *
*        COL 2-9:   IDENTIFIER FOR TITLING TOTAL COUNTS ON THE LISTING*
*                   (OPTIONAL).                                       *
*        COL 11-15: STARTING POSITION IN RECORD OF FIELD TO BE CHECKED*
*                   MUST BE NUMERIC WITH LEADING ZEROES, AND GREATER  *
*                   THAN 0. THE FIRST BYTE OF THE RECORD IS SPECIFIED *
*                   AS 00001. DO NOT ADD 4 FOR VARIABLE RECORDS.      *
*        COL 17-18: LENGTH OF FIELD TO BE CHECKED. MUST BE NUMERIC    *
*                   01-16.                                            *
*        COL 20-22: COMPARISON, LEFT JUSTIFIED: EQ, NE, LT, GT, NGT,  *
*                   OR NLT. FOR A TEST UNDER MASK COMPARE, THE VALUES *
*                   O, NO, Z, NZ, OR M MAY BE USED. IN THIS CASE, THE *
*                   LENGTH MUST BE 01, AND THE COMPARISON VALUE MUST  *
*                   BE GIVEN IN HEX: ONE BYTE, WHICH IS TWO HEX DIGITS*
*                   EACH OF WHICH MUST BE 0-9 OR A-F.                 *
*        COL 23:    BLANK FOR CHARACTER VALUE, X FOR HEXADECIMAL VALUE*
*                   WHEN X IS USED, THE VALUE GIVEN MUST BE IN HEX    *
*                   DIGITS WHOSE VALUES MAY BE 0-9 OR A-F. TWO DIGITS *
*                   REPRESENT ONE BYTE, AND AN EVEN NUMBER OF DIGITS  *
*                   MUST BE ENTERED.                                  *
*        COL 24-39: COMPARISON VALUE - ANY VALUE FOR THE LENGTH IN    *
*                   COLUMNS 17-18. BE SURE TO USE THE SAME DATA TYPE  *
*                   FOUND IN THE RECORD . PACKED DECIMAL FIELDS MAY BE*
*                   ENTERED BY USE OF THE HEX FEATURE, OR BY MULTI-   *
*                   PUNCHING THE VALUE. SIGNS ARE NOT CHECKED.        *
*                   REMEMBER THAT HEXADECIMAL REQUIRES TWO DIGITS PER *
*                   BYTE, THEREFORE ONLY 8 BYTES OF HEX DATA MAY BE   *
*                   ENTERED.                                          *
*        COL 41-43: RELATIONSHIP, 1ST TO 2ND COMPARISON: 'AND' OR 'OR'*
*                   BLANK IF ONLY ONE FIELD IN CARD.                  *
*        COL 45-49: SAME AS COL 11-15, FOR 2ND FIELD                  *
*        COL 51-52: SAME AS COL 17-18, FOR 2ND FIELD.                 *
*        COL 54-56: SAME AS COL 20-22, FOR 2ND FIELD.                 *
*        COL 57:    SAME AS COL 23, FOR 2ND FIELD.                    *
*        COL 58-73: SAME AS COL 24-39, FOR 2ND FIELD.                 *
*        COL 75-77: IF NEXT CARD CONTINUES THE SELECTION DEFINITION   *
*                   FOR A SET OF RECORDS, CODE 'AND', ELSE LEAVE THIS *
*                   FIELD BLANK.                                      *
*        COL 78-80: NUMBER OF THESE RECORDS TO BE SELECTED.           *
* 6.  IF ANY CONTROL CARD ERRORS ARE FOUND, 'ERROR IN CONTROL CARD'   *
*        WILL BE PRINTED AT THE TOP OF THE FIRST PAGE, AND THE RUN    *
*        WILL BE TERMINATED WITH A U0777 ABEND CODE.                  *
* 7.  THE PROC TO EXECUTE COPYFIL IS:                                 *
*        //COPYFIL  EXEC PGM=COPYFIL                                  *
*        //SYSUDUMP DD SYSOUT=A                                       *
*        //SYSPRINT DD SYSOUT=A                                       *
* 8.  EXAMPLES.                                                       *
*     A. COPY A THE FIRST 100 RECORDS OF A SEQUENTIAL DISK FILE TO A  *
*        TAPE DATASET.                                                *
*        //DMS0650 EXEC COPYFIL                                       *
*        //COPYIN DD DSN=MEDICAID.DSM0650.CLAIMS,DISP=OLD             *
*        //COPYOUT DD DSN=MEDICAID.TESTFILE,UNIT=TAPE,DISP=(NEW,KEEP),*
*        //           DCB=(RECFM=FB,LRECL=239,BLKSIZE=2390)           *
*        //SYSIN DD *                                                 *
*        *  0000100                                                   *
*     B. COPY AN ISAM INPUT FILE NAMED SUBSCRIB.CLAIM, SELECTING ALL  *
*        RECORDS HAVING AN 'A' IN POSITION 3, A 'B' IN POSITION 6, AND*
*        A 'C' IN POSITION 9. CREATE A SEQUENTIAL OUTPUT FILE OF THE  *
*        SELECTED RECORDS CALLED TESTFILE.                            *
*        //MLR0040 EXEC COPYFIL                                       *
*        //COPYIN DD DSN=SUBSCRIB.CLAIM,DISP=SHR                      *
*        //DUMPOUT DD DSN=TESTFILE,DISP=(NEW,CATLG,DELETE),UNIT=3330, *
*        // DCB=(RECFM=FB,LRECL=140,BLKSIZE=6440),SPACE=(CYL,(2,1))   *
*        //SYSIN DD *                                                 *
*        S         00003 01 EQ  A                AND 00006 01 EQ  C   *
*                                         (POS 75-77):AND             *
*        S         00009 01 EQ  C                                     *
*     C. COPY A SEQUENTIAL INPUT FILE CALLED SEQNTL.INPUT, SELECTING  *
*        UP TO 7 RECORDS HAVING 'ABC' IN POSITIONS 10-12, UP TO 99    *
*        RECORDS HAVING THE '80' BIT ON IN POSITION 96, AND ALL       *
*        RECORDS HAVING AN 'R' IN POSITION 18. AN ISAM OUTPUT FILE OF *
*        THE RECORDS SELECTED IS CREATED, CALLED TESTISAM. NOTE THAT  *
*        AN OVERALL MAXIMUM OF 1700 RECORDS WILL BE OUTPUT, AND AN ISAM
*        OUTPUT FILE IS SPECIFIED BY THE * CONTROL CARD.              *
*        //PLS0073 EXEC COPYFIL                                       *
*        //COPYIN DD DSN=SEQNTL.INPUT,DISP=SHR                        *
*        //COPYOUT DD DSN=TESTISAM,DISP=(NEW,KEEP,KEEP),UNIT=SYSTS,   *
*        // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6400,RKP=1,KEYLEN=6,       *
*        // CYLOFL=1,DSORG=IS),SPACE=(CYL,(30,,2),,CONTIG)            *
*        //SYSIN DD *                                                 *
*        *3 N 01700    IS                                             *
*        S         00010 03 EQ  ABC                                   *
*                                         (POS 78-80):007             *
*        S         00096 01 O  X80                                    *
*                                         (POS 78-80):099             *
*        S         00018 01 EQ  R                                     *
* 9.  NOTES ON USE, AND COMMON ERRORS.                                *
*     A. INCORRECT OUTPUT: CHECK CONTROL CARD(S) FOR ERRORS. CHECK    *
*        FOR ERROR MESSAGE AT TOP OF FIRST PAGE OF OUTPUT. BE SURE    *
*        VS IS SPECIFIED FOR VARIABLE BLOCKED FILES, AND IS FOR ISAM  *
*        FILES ON THE * OPTION CARD.                                  *
*     B. 0C1 ABENDS MAY OCCUR IF THE COPYIN DD CARD IS MISSING OR IF  *
*        THE DDNAME IS MISSPELLED, OR IF AN ISAM DATASET IS INPUT,    *
*        BUT IS IS NOT SPECIFIED ON THE * OPTION CARD.                *
*     C. ERROR MESSAGES:                                              *
*        "UNKNOWN TYPE COL1"   THE CARD PRINTED ABOVE HAS AN INVALID  *
*             CODE IN COLUMN 1: MUST BE "*" OR "S".                   *
*        "INV FILE"  THE CARD PRINTED ABOVE HAS AN ERROR IN THE FILE  *
*             TYPE FIELD (COL 12-13 OR 15-16).                        *
*        "INV MAX"   THE CARD PRINTED ABOVE HAS AN ERROR IN THE       *
*             NUMBER OF RECORDS TO BE PRINTED FIELD (COL 4-10).       *
*        "INV STRT"  THE CARD PRINTED ABOVE HAS AN ERROR IN THE       *
*             STARTING RECORD NUMBER FIELD (COL 18-22).               *
*        "TOO MANY, DROPPED"   THE CARD ABOVE WAS IN EXCESS OF THE    *
*             MAXIMUM OF 25 SELECTION CARDS PERMITTED.                *
*        "INVALID NBR RECDS"   THE CARD PRINTED ABOVE HAS AN ERROR IN *
*             THE NUMBER OF RECORDS FIELD (COL 78-80).                *
*        "START POS ERR"  THE CARD PRINTED ABOVE HAS AN ERROR IN THE  *
*             STARTING POSITION FIELD (COL 11-15 OR 45-49).           *
*        "LEN ERR"  THE CARD PRINTED ABOVE HAS AN ERROR IN THE LENGTH *
*             FIELD (COL 17-18 OR 51-52).                             *
*        "BAD VALUE1"   THE CARD PRINTED ABOVE HAS AN ERROR IN THE    *
*             COMPARISON VALUE FIELD, (COL 24-39 OR 58-73).           *
*        "BAD COMPARE CODE"  THE CARD PRINTED ABOVE HAS AN ERROR IN   *
*             THE COMPARISON CODE FIELD (COL 20-23 OR 54-57).         *
*        "INVALID REL"  THE CARD PRINTED ABOVE HAS AN ERROR IN THE    *
*             RELATION FIELD (COL 41-43 OR 75-77).                    *
*        "***** ERRORS FOUND ON CONTROL CARDS *****"PROCESSING        *
*             STOPPED DUE TO ERRORS FOUND ON CONTROL CARDS. THE       *
*             ERRORS FOUND ARE PRINTED ABOVE. THE PROGRAM WILL END    *
*             ABNORMALLY WITH USER CODE 777. CORRECT THE ERRORS AND   *
*             RESUBMIT THE JOB.                                       *
*        "EOF RECORD"    PROCESSING STOPPED BECAUSE THE END OF THE    *
*             INPUT FILE WAS REACHED. NORMAL END.                     *
*        "*** MAX RECORDS PASSED ***"  PROCESSING STOPPED BECAUSE THE *
*             NUMBER OF OUTPUT RECORDS REQUESTED ON THE OPTION CARD   *
*             (COL 4-10) WAS EXCEEDED. NORMAL END.                    *
*                                                                     *
***********************************************************************
./ ADD NAME=COPYMULT 0100-88061-88061-0951-00050-00050-00000-USER02
            ***** COPY MULTI-FILE TAPE VOLUMES *****
*
*     COPYMULT COPIES A TAPE VOLUME TO ANOTHER VOLUME WITH IDENTICAL
* FORMAT AND CONTENT. ANY NUMBER OF FILES MAY BE CONTAINED ON THE
* INPUT VOLUME, LABELS MAY BE STANDARD OR OMITTED, AND FILES MAY
* BE OF ANY RECFM, LRECL AND BLKSIZE, AND THE VARIOUS FILES MAY
* HAVE DIFFERENT CHARACTERISTICS. A PRINT LINE FOR EACH DATASET SHOWS
* THE INPUT VOLUME SERIAL NUMBER (FROM THE INPUT1 DD CARD), OUTPUT
* VOLUME SERIAL NUMBER (FROM THE OUTPUT1 DD CARD), FILE SEQUENCE
* NUMBER ON THE VOLUME, NUMBER OF BLOCKS COPIED, RECFM, AND BLKSIZE.
* RECFM IS SHOWN AS F IF ALL BLOCKS IN THE FILE ARE THE SAME SIZE
* EXCEPT POSSIBLY THE LAST ONE. RECFM=V FOR FILES IN WHICH THE FIRST
* TWO BYTES OF EACH BLOCK ARE EQUAL TO BLOCK LENGTH. RECFM=U IS
* PRINTED WHEN THE ABOVE CONDITIONS ARE NOT MET. BLKSIZE PRINTED
* IS THAT OF THE LONGEST BLOCK FOUND IN THE DATASET.
*
*      JCL TO EXECUTE COPYMULT IS GIVEN BELOW. AN OPTIONAL PARM FIELD
* MAY BE GIVEN ON THE EXEC CARD TO PROVIDE THE ACTUAL NUMBER OF FILES
* ON THE INPUT TAPE, WHEN KNOWN. THIS SHOULD BE SPECIFIED, IF POSSIBLE,
* AS THE PROGRAM WILL READ INTO I/O ERRORS ON THE INPUT TAPE WHILE
* ATTEMPTING TO FIND ANOTHER DATASET AFTER THE LAST ACTUALLY RECORDED,
* AND WILL ABEND OR HAVE TO BE CANCELLED. IN THIS CASE, THE COPY IS
* GOOD, IT JUST CAUSES OPERATIONAL DIFFICULTIES. THE FILE COUNT IN
* THE PARM FIELD, WHEN SPECIFIED, MUST SHOW THE TOTAL NUMBER OF FILES
* EXISTING BETWEEN TAPE-MARKS ON THE INPUT TAPE. STANDARD LABELS ARE
* NOT RECOGNIZED AS LABELS BY THIS PROGRAM, BUT AS FILES: A STANDARD
* LABELLED TAPE WITH A SINGLE FILE HAS 3 FILES, A HEADER LABEL FILE,
* THE DATA FILE, AND A TRAILER LABEL FILE. THE PROGRAM WILL STOP
* COPYING WHEN THE NUMBER OF FILES SPECIFIED IN THE PARM FIELD HAS
* BEEN COPIED, EVEN IF MORE FILES ARE ON THE TAPE. THERE WILL BE
* NO WARNING SHOULD THIS OCCUR. THE PARM FIELD MUST BE A 1-4 DIGIT
* NUMBER, WHEN PROVIDED. THE INPUT1 AND OUTPUT1 DD CARDS MUST BE
* FOR TAPES, AND THE LABEL=(1,NL) PARAMETER MUST BE CODED AS SHOWN.
* DCB INFORMATION MUST BE OMITTED, EXCEPT FOR DENSITY, IF NEEDED.
*   DEN=2  800 BPI
*   DEN=3  1600 BPI
*   DEN=4  6250 BPI
*
*
//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//COPYTAPE EXEC PGM=COPYMULT,PARM=8
//STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR
//SYSUDUMP DD SYSOUT=A
//PRINT1 DD SYSOUT=A,DCB=BLKSIZE=133
//INPUT1 DD DSN=PTF7805.TAPE1,VOL=SER=002048,LABEL=(1,NL),DISP=OLD,
// UNIT=TAPE
//OUTPUT1 DD DSN=PTF7805.COPY,UNIT=TAPE,LABEL=(1,NL),DISP=(NEW,KEEP),
// DCB=DEN=3
./ ADD NAME=DASDIO   0100-02092-02092-1413-00041-00041-00000-BC0THOR
                   USING TMONMVS to DISPLAY DASD I/O DATA

         TMONMVS can be used to obtain information on the busiest DASD
         devices, and which datasets are being used on a volume, and
         the jobs using these datasets. Following is a procedure for
         doing this.

         1. At the TMONMVS PRIMARY MENU on the SELECTION line, type
            =1.6 and press ENTER. This will bring up the
            I/O CONFIGURATION MONITOR screen.

         2. Press PF5 to get the DASD ACTIVITY MONITOR screen.

         3. Tab to the % DEV BUSY _ field and press ENTER. This will
            sort the display in descending order by % DEV BUSY. The
            first device shown will be the busiest. Pressing ENTER
            will update the display. (To get back to the
            I/O CONFIGURATION MONITOR screen, press PF3).

         4. Decide which DASD volume is to be analyzed and move the
            cursor to its DEV NUM, then press ENTER. This will invoke
            the DEVICE DETAIL SELECTION MENU. On the SELECTION line,
            type the number 2 and press ENTER. A message will appear
            saying I/O PROFILE SUCCESSFULLY STARTED.

         5. On the SELECTION line, enter =5.1 and press ENTER. You
            will then see a PROFILE STATUS/SELECTION menu, and the top
            line should show the request you just made, with PENDING
            in the STATUS COLUMN. This means TMONMVS is monitoring the
            DASD volume, which takes a little time. Every few seconds,
            press ENTER, until the STATUS changes to COMPLETE.

         6. Move the cursor to the SEG field at the left side of the
            COMPLETE report line and press ENTER. This will bring up
            the DASD I/O PROFILE screen.

         7. Press PF6 to get the DASD DATA SET I/O ACTIVITY PROFILE
            screen. This shows the datasets being used on the volume,
            and the jobs using them. This can be very helpful in
            analyzing DASD I/O problems.

./ ADD NAME=DDLIST   0100-02092-02092-1413-00054-00054-00000-BC0THOR
    THIS PROGRAM PRINTS ALL ALLOCATED DATASETS FOR A TSO USER. FOR EACH
    ALLOCATED DATASET, THE FILE NAME, DATASET NAME, DISPOSITION, AND
    VOLUME SERIAL NUMBER IS PRINTED. OUTPUT IS WRITTEN TO SYSRINT. TO
    LOCATE THE INFORMATION, THE TCB IS LOCATED VIA THE TCBWORDS IN THE
    CVT. THE JSCB IS FOUND USING THE TCB. A POINTER TO THE DSAB QDB IS
    OBTAINED FROM THE JSCB. THE DSAB QDB CONTAINS THE ADDRESSES OF THE
    FIRST AND LAST DSAB'S. THE DSAB HAS POINTERS TO THE TIOT DD ENTRY
    AND THE SIOT. THE TIOTDD ENTRY CONTAINS THE DDNAME AND A POINTER
    TO THE UCB. THE UCB CONTAINS THE OLUME SERIAL NUMBER. THE SIOT
    POINTS TO THE JFCB, WHICH HAS THE DSNAME, MEMBER NAME, AND DISP
    FIELDS.

   **********     ******
   *ABSOLUTE*---->* CVT*
   *HEX '10'*     ******      ******
   **********     *+180*----->*JSCB*
                  ******      ******      ******
                              *+320*----->* QDB*      (FIRST)
                              ******      ******      ******
                                          *+12 *----->*DSAB*
                                          ******      ******
                                          *+16 *--|
                                          ******  |   (LAST)
                                                  |   ******
                                                  |-->*DSAB*
                                                      ******
    ******
    *DSAB*
    ******                   ********
    *+16 *------------------>*TIOTDD*
    ******                   ********
    *+64 *-----|             *  +4  * = DDNAME
    ******     |             *      *
               |             ********      *****
               |             *  +16 *----->*UCB*
               |             ********      *****
               |                           *+28* = VOLUME SERIAL NBR
               |                           *****
               |
               |             ******
               |------------>*SIOT*
                             ******
                             * +4 * = DDNAME
                             ******
                             *    *      ******
                             *+156*----->*JFCB*
                             ******      ******
                                         * +0 * = DSNAME
                                         ******
                                         * +44* = MEMBER NAME
                                         ******
                                         * +87* = DISPOSITION FLAGS
                                         ******

./ ADD NAME=DISASM   0105-88061-01025-1113-00430-00426-00000-BC0THOR
**********************************************************************
                ***** DISASSEMBLER *****
*
*
*  DISASM IS A ONE-PASS DISASSEMBLER WHICH PRODUCES AN ASSEMBLER
*  LANGUAGE SOURCE PROGRAM FROM A CSECT WITHIN A LOAD MODULE.
*  CONTROL CARDS PERMIT SPECIFICATION OF AREAS CONTAINING NO
*  INSTRUCTIONS, ALLOW BASE REGISTERS TO BE PROVIDED SO THAT
*  SYMBOLIC LABELS MAY BE CREATED DURING DISASSEMBLY, AND
*  DEFINITION OF DSECTS TO BE USED DURING DISASSEMBLY. CONDITIONAL
*  BRANCH INSTRUCTIONS USE THE EXTENDED MNEMONICS, WHERE POSSIBLE,
*  AND EXPLICIT REGISTERS ARE DENOTED BY R0, R1, ... R15. INFORMATIONAL
*  COMMENTS ARE GIVEN ON SVC'S, AND VARIOUS BAL INSTRUCTIONS TO AID
*  IN CREATING A DOCUMENTED SOURCE PROGRAM.
*
*  1. JCL REQUIREMENTS:
*        A. EXEC CARD:        TO EXECUTE PGM=DISASM. A PARM FIELD MAY
*                             BE SPECIFIED IF FLOATING POINT AND/OR
*                             PRIVILEGED INSTRUCTIONS ARE TO BE
*                             FOUND IN THE MODULE.
*        B. STEPLIB DD CARD:  OPTIONAL, SPECIFY THE PDS CONTAINING
*                             THE MODULE DISASM.
*        C. LOADLIB DD CARD:  OPTIONAL, SPECIFY PDS CONTAINING THE
*                             MODULES DISASM1 AND DISASM2, IF OTHER THAN
*                             SYS1.LINKLIB OR STEPLIB.
*        D. SYSLIB DD CARD:   SPECIFY PDS CONTAINING THE MODULE TO BE
*                             DISASSEMBLED.
*        E. SYSPUNCH DD CARD: OPTIONAL, SPECIFY THE SOURCE PROGRAM
*                             DATASET. BLKSIZE MUST BE SPECIFIED AS
*                             A MULTIPLE OF 80. RECFM=FB,LRECL=80 IS
*                             HARD CODED IN DISASM.
*        F. SYSPRINT DD CARD: OPTIONAL, SPECIFY PRINTED OUTPUT DATASET.
*                             BLKSIZE MUST BE SPECIFIED AS A MULTIPLE
*                             OF 133. RECFM=FB,LRECL=133 IS HARD CODED.
*        G. SYSIN DD CARD:    CONTAINS CONTROL CARDS. THE MODULE-CSECT
*                             CARD IS REQUIRED. BLKSIZE MUST BE A
*                             MULTIPLE OF 80. RECFM=FB,LRECL=80 IS
*                             HARD-CODED.
*
*    JCL EXAMPLE: DISASSEMBLE CSECT IECIOSCN IN MODULE IEANUC01,
*                  WHICH IS IN THE PDS SYS1.NUCLEUS. THE MODULES
*                  DISASM, DISASM1, AND DISASM2 ARE ALL IN THE PDS
*                  SYS1.TECHLOAD. A PRINTED LISTING IS TO BE MADE,
*                  AND THE SOURCE PROGRAM OUTPUT WILL BE PLACED IN
*                  THE SEQUENTIAL DATASET USER02.IECIOSCN.ASM.
*
//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//DISASM EXEC PGM=DISASM
//STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR
//SYSPRINT DD SYSOUT=A,DCB=BLKSIZE=133
//SYSLIB DD DSN=SYS1.NUCLEUS,DISP=SHR
//SYSPUNCH DD DSN=USER02.IECIOSCN.ASM,DISP=(,CATLG),
//         UNIT=SYSTS,DCB=BLKSIZE=18960,
//         SPACE=(TRK,(5,2),RLSE)
//SYSIN DD *
IEANUC01 IECIOSCN
*
*
*
*  2. PARM FIELD ON THE EXEC CARD: OMIT THE PARM FIELD, UNLESS
*          FLOATING POINT AND/OR PRIVILEGED INSTRUCTIONS ARE TO
*          BE FOUND IN THE CSECT BEING DISASSEMBLED. WHEN THE PARM
*          FIELD IS NOT SPECIFIED, ENTRIES FOR THE PRIVILEGED AND
*          FLOATING POINT INSTRUCTIONS ARE ERASED FROM THE INTERNAL
*          INSTRUCTION TABLES USED DURING DISASSEMBLY. VALID PARM
*          FIELDS ARE:
*            PARM=(SUPVR)     ASSEMBLE PRIVILEGED INSTRUCTIONS
*            PARM=(FLTPT)     ASSEMBLE FLOATING POINT INSTRUCTIONS
*            PARM=(SUPVR,FLTPT) ASSEMBLE BOTH PRIVILEGED AND
*                             FLOATING POINT INSTRUCTIONS.
*
*
*  3. CONTROL CARDS ENTERED IN THE SYSIN DATASET. DATA IS
*                   CONTAINED ONLY IN COLUMNS 1-72. COLUMNS
*                   73-80 MAY BE USED FOR ANY DESIRED PURPOSE.
*                   IN ADDITION, COLUMNS BEYOND THE LAST
*                   SPECIFIED MAY BE USED FOR ANY PURPOSE.
*                   LEADING ZEROS MUST BE INCLUDED IN ALL
*                   FIELDS GIVING HEX OR DECIMAL DATA. NAME
*                   FIELDS MUST BE LEFT JUSTIFIED WITH
*                   TRAILING BLANKS. HEX FIELDS MAY CONTAIN
*                   ONLY THE HEX DIGITS 0-9 AND A-F, WHILE
*                   DECIMAL FIELDS MAY CONTAIN ONLY DIGITS 0-9.
*                   THE MODULE-CSECT CARD MUST BE THE FIRST
*                   CARD IN THE INPUT STREAM. DSECT DEFINITIONS
*                   MAY NOT INCLUDE ANY OTHER CONTROL CARDS.
*                   USING CARDS FOR DSECTS MUST BE ENTERED AT
*                   SOME POINT AFTER THE DSECT DEFINITION.
*                   DATA-ONLY CARDS AND PROGRAM USING CARDS
*                   MAY BE ENTERED IN ANY ORDER EXCEPT
*                   WITHIN DSECT DEFINITIONS.
*
*
*     A. MODULE-CSECT CARD (REQUIRED), MUST BE THE FIRST CARD IN
*                     THE SYSIN STREAM. SPECIFIES THE MODULE NAME
*                     AND CSECT NAME. MODULE NAME IS REQUIRED, AND
*                     MUST NAME AN ENTRY IN THE DIRECTORY OF THE
*                     PDS SPECIFIED BY THE SYSLIB DD CARD. CSECT
*                     NAME IS OPTIONAL. IF SPECIFIED, THE NAMED CSECT
*                     MUST EXIST IN THE MODULE. IF OMITTED, THE
*                     CSECT WITH ESDID=0001 IS DISASSEMBLED.
*        FORMAT: FREE-FORM, WITH MODULE NAME PRECEDING CSECT NAME.
*                AT LEAST ONE BLANK MUST SEPARATE MODULE NAME AND
*                CSECT NAME. THE NAMES MAY BE SURROUNDED BY ANY NUMBER
*                OF BLANKS.
*                FOR EXAMPLE, SEE THE JCL EXAMPLE.
*
*
*
*     B. DATA-ONLY CARD (OPTIONAL), USED TO DESCRIBE AREAS OF THE
*                  CSECT BEING DISASSEMBLED WHICH CONTAIN NO
*                  INSTRUCTIONS. USE OF THIS CARD ELIMINATES
*                  CREATION OF INSTRUCTIONS FROM CONSTANT DATA.
*                  UP TO 256 DATA-ONLY CARDS MAY BE ENTERED. THESE
*                  CARDS MAY OCCUR ANYWHERE IN THE SYSIN STREAM
*                  AFTER THE MODULE-CSECT CARD, BUT NOT WITHIN
*                  A DSECT DEFINITION SET.
*        FORMAT:
*                COL  1-4  : LITERAL 'DATA'
*                COL   5   : BLANK
*                COL  6-11 : OFFSET TO BEGINNING OF AREA IN HEX
*                COL   12  : BLANK
*                COL 13-18 : OFFSET TO END OF AREA IN HEX
*
*
*
*     C. DSECT DEFINITIONS (OPTIONAL). A DSECT IS DEFINED BY A
*                HEADER CARD FOLLOWED BY A VARIABLE NUMBER OF
*                FIELD DEFINITION CARDS (UP TO 9999 OF THEM).
*                NO OTHER CONTROL CARD MAY BE ENTERED WITHIN A
*                DSECT DEFINITION. UP TO 256 DSECT DEFINITIONS
*                MAY BE ENTERED. THE USING FOR THE DSECT MUST FOLLOW
*                THE FIELD DEFINITION CARDS.
*
*        DSECT HEADER CARD FORMAT:
*             COL 1-8    : DSECT NAME
*             COL 9      : BLANK
*             COL 10-14  : LITERAL 'DSECT'
*             COL 15     : BLANK
*             COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)
*
*        DSECT FIELD CARD FORMAT:
*             COL 1-8    : FIELD NAME
*             COL 9      : BLANK
*             COL 10-13  : OFFSET TO LEFT END OF FIELD (DECIMAL)
*                          MAXIMUM OFFSET IS 4095
*             COL 14     : BLANK
*             COL 15-17  : LENGTH OF FIELD IN BYTES (DECIMAL)
*                          MAXIMUM LENGTH IS 256
*
*
*
*     D. ULABL CARDS. THESE CARDS DEFINE USER LABELS TO BE PLACED
*                   ON STATEMENTS WITHIN THE PROGRAM. IF PROGRAM
*                   BASE REGISTERS ARE SET UP WITH USING CARDS,
*                   THESE WILL ALSO BE GENERATED AS SYMBOLIC
*                   OPERANDS ON INSTRUCTIONS. FORMAT IS:
*
*             COL  1-5   : LITERAL 'ULABL'
*             COL   6    : BLANK
*             COL  7-14  : LABEL NAME
*             COL  15    : BLANK
*             COL 16-21  : OFFSET TO LEFT END OF FIELD, IN HEX.
*             COL  22    : BLANK
*             COL 23-26  : LENGTH OF FIELD IN DECIMAL. 256 IS MAX.
*
*
*
*     E. USING CARDS. THESE CARDS DEFINE BASE REGISTER USAGE.
*                   UP TO 256 USING CARDS MAY BE ENTERED. USE
*                   OF THESE CARDS PERMITS THE DISASSEMBLER TO
*                   CONVERT EXPLICIT BASE-DISPLACEMENT ADDRESSES
*                   TO SYMBOLIC LABELS. LABELS CREATED WITHIN
*                   THE PROGRAM WILL BE 7 CHARACTERS LONG. THE
*                   FIRST CHARACTER IS 'A', FOLLOWED BY THE
*                   6-HEX-DIGIT OFFSET TO THE LABEL. A USING
*                   CARD MUST BE ENTERED FOR EACH DSECT TO
*                   BE USED AND IT MUST BE ENTERED AFTER THE
*                   LAST DSECT FIELD DEFINITION CARD.
*
*       FORMAT:
*
*            COL 1-5   : LITERAL 'USING'
*            COL 6     : BLANK
*            COL 7-12  : OFFSET TO BEGIN LOC FOR USING RANGE IN HEX
*                        (THIS IS WHERE THE USING STATEMENT WILL OCCUR)
*            COL 13    : BLANK
*            COL 14-19 : OFFSET TO ENDING LOC FOR USING RANGE IN HEX
*                        (THIS IS WHERE THE DROP STATEMENT WILL OCCUR)
*                        (IF BLANK OR PAST END OF PROGRAM, NO DROP)
*            COL 20    : BLANK
*            COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)
*            COL 22    : BLANK
*            COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE
*            COL 24    : BLANK
*            COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P IN HEX
*            COL 25-32 : DSECT NAME IF TYPE D
*
*
*
*  4. SUGGESTIONS FOR USE: ON THE FIRST PASS, DO NOT USE A SYSPUNCH
*                 DD CARD, BUT PRINT THE SYSPRINT LISTING. USE THE
*                 LISTING TO DETERMINE WHICH REGISTERS SRE USED AS
*                 PROGRAM BASE REGISTERS, THEIR INITIAL VALUES, AND
*                 THEIR RANGES. MAKE UP USING CARDS FOR THESE. FIND
*                 ANY PLACES WHERE NO INSTRUCTIONS SHOULD BE GENERATED
*                 (ONLY CONSTANTS), AND MAKE UP DATA-ONLY CARDS FOR
*                 THESE RANGES. IF YOU CAN DETERMINE ANY REGISTERS
*                 THAT ARE BASES FOR AREAS WHICH CAN BE USED FOR
*                 DSECTS (CVT REFERENCE, ETC.), DETERMINE THE
*                 RANGE OF VALID USE, AND MAKE UP DSECT DEFIN
*                 ITIONS AND USING CARDS FOR THESE. MAKE A SECOND
*                 RUN, INCLUDING THE ABOVE CARDS, AND CREATING
*                 A SOURCE PROGRAM OUTPUT WITH THE SYSPUNCH
*                 DD CARD.
*
*
*
*  5. OUTPUT DESCRIPTION:
*
*     A. SYSPUNCH: THIS OUTPUT CONTAINS THE DISASSEMBLED SOURCE
*                  PROGRAM. STATEMENT NAMES BEGIN IN COLUMN 1,
*                  MNEMONICS BEGIN IN COLUMN 10, OPERANDS IN COL
*                  16, AND AN OCCASIONAL COMMENT BEGINS IN COL-
*                  UMN 44. A SEQUENCE NUMBER (BY TENS) IS IN
*                  COLUMNS 73-80. COMMENTS ARE INCLUDED TO SHOW
*                  THE MACRO NAME ASSOCIATED WITH SVC'S, AND OTHER
*                  STATEMENTS ARE FLAGGED TO AID IN IDENTIFICATION
*                  OF CERTAIN OPERATIONS:
*                  BALR 14,15              STD LINKAGE
*                  BALR X,0                ADDRESS SET
*                  OTHER BALR'S            NON-STD LINKAGE
*                  BAL 0,XXX AND BAL 1,XXX PARM SET BRCH
*                  BAL X,XXX               PERFORM
*                  STM INSTRUCTIONS        SAVE REGS
*                  LM  INSTRUCTIONS        RESTORE REGS
*                  BR R14                  EXIT
*                  ABS. LOCATION HEX 10    CVT ADDRESS
*                  ABS. LOCATION HEX 4C    CVT ADDRESS
*                  OTHER ABS. LOCATIONS    PSA REFERENCE
*                  WHEN USED IN EXPLICITLY IN INSTRUCTIONS, REGISTERS
*                  ARE SPECIFIED AS R0, R1, R2,... R15. AN REQU MACRO
*                  IS GENERATED AT THE END OF THE PROGRAM TO CREATE
*                  THE APPROPRIATE EQU STATEMENTS. IF ANY DSECTS
*                  WERE DEFINED IN THE SYSIN DATASET, THEY WILL
*                  BE NEAR THE END OF THE SOURCE PROGRAM.
*                  THE EXTENDED MNEMONICS ARE USED FOR CONDITIONAL
*                  BRANCHES WHEREVER POSSIBLE.
*
*
*
*      B. SYSPRINT CONTENT:
*
*         DIRECTORY INFORMATION: CONTAINS DATA FROM THE DIRECTORY
*                                ENTRY OF THE MODULE CONTAINING
*                                THE CSECT TO BE DISASSEMBLED.
*         ESD TABLE: A FORMATTED LIST OF ALL EXTERNAL SYMBOL ENTRIES
*                                FOUND IN THE MODULE.
*         RLD TABLE: A FORMATTED LISTING OF ALL RELOCATION DICTIONARY
*                                ENTRIES PERTAINING TO THIS CSECT.
*         USER ENTERED CARDS: A LIST OF THE CARDS ENTERED BY THE USER,
*                                WITH DIAGNOSTICS, IF APPROPRIATE.
*         PHASE 1 LABEL TABLE: A LIST OF ALL THE LABELS TO BE USED
*                                DURING DISASSEMBLY INCLUDING THOSE
*                                DEVELOPED FROM ESD ENTRIES, RLD
*                                ENTRIES, AND GENERATED NAMES
*                                RESULTING FROM USING CARD PROCESSING.
*         TEXT: A STORAGE-DUMP FORMATTED LISTING OF THE TEXT WHICH
*                                COMPRISES THE CSECT BEING DIS
*                                ASSEMBLED.
*         SOURCE LISTING: A PRINTOUT OF THE GENERATED SOURCE PROGRAM
*                                STATEMENTS, INCLUDING THE HEX VALUE
*                                WHICH RESULTED IN THE INSTRUCTION'S
*                                CREATION.
*
*
*
* 6. PROGRAM PROCESSING DESCRIPTION.
*
*   THE DISASSEMBLER IS COMPOSED OF THREE MODULES. THE FIRST IS
*   CALLED DISASM0. THE SECOND PHASE IS DISASM1, AND THE THIRD IS
*   DISASM2. THE SECOND AND THIRD PHASES ARE LOAD'ED AND PERFORMED
*   BY A BALR 14,15 FROM DISASM0.
*
*
*      DISASM0 FUNCTIONS:
*
*      . PROCESS THE PARM FIELD, IF ANY: SET INDICATORS USED BY
*        DISASM1 AND DISASM2 TO SET UP THEIR INSTRUCTION TABLES.
*      . OPEN ALL FILES.
*      . GET STORAGE FOR THE SYMBOL TABLE, RLD TABLE, AND DATA-ONLY
*        TABLES (109,544 BYTES TOTAL).
*      . PROCESS THE MODULE-CSECT CARD TO OBTAIN THE MEMBER
*        AND CSECT NAMES.
*      . ISSUE BLDL AGAINST SYSLIB TO OBTAIN DIRECTORY INFO FOR
*        THE MEMBER SPECIFIED. IF THE SPECIFIED MEMBER IS AN
*        ALIAS, RE-ISSUE A BLDL FOR THE REAL MEMBER. PRINT
*        DIRECTORY INFORMATION.
*      . POINT TO THE MEMBER IN THE SYSLIB PDS, AND PROCESS THE
*        MEMBER. LOAD MODULES CONTAIN AN EXTERNAL SYMBOL DICTIONARY
*        FOLLOWED BY TEXT AND RELOCATION DICTIONARY INFORMATION.
*        ALL ESD INFO FOR THE MODULE PRECEDES THE FIRST CONTROL
*        RECORD. A CONTROL RECORD PRECEDES EACH BLOCK OF TEXT.
*        RLD INFO FOR THE TEXT FOLLOWS EACH TEXT BLOCK. PROCESSING
*        OF LOAD MODULE INFORMATION IS AS FOLLOWS:
*        A. BUILD AN EXTERNAL SYMBOL TABLE, USING THE CESD BLOCKS.
*        B. SEARCH FOR THE DESIRED CSECT AS THE TABLE IS BEING
*           BUILT. THIS CSECT MUST BE FOUND BEFORE THE FIRST
*           CONTROL RECORD.
*        C. READ BLOCKS UNTIL A CONTROL RECORD FOR THE DESIRED
*           CSECT IS FOUND (BY ESD-ID).
*        D. WHEN FOUND, ISSUE GETMAIN FOR AN AREA LARGE ENOUGH
*           TO CONTAIN THE ENTIRE TEXT.
*        E. PLACE TEXT BLOCKS IN CONTIGUOUS STORAGE LOCATIONS
*           AND MAINTAIN DURING DISASSEMBLY.
*        F. USE RLD INFORMATION FOR THE CSECT TO BUILD THE RLD
*           RLD TABLE.
*      . LOAD AND PERFORM DISASM1.
*      . IF ANY ERRORS FOUND BY DISASM1, TERMINATE PROCESSING.
*      . PRINT THE FINAL LABEL TABLE TO BE USED DURING DISASSEMBLY.
*      . LOAD AND EXECUTE DISASM2.
*      . GENERATE THE DSECT ENTRIES.
*      . GENERATE THE REQU MACRO AND END STATEMENTS
*      . TERMINATE PROCESSING
*
*
*
*       DISASM1 FUNCTIONS:
*
*     DISASM1 IS THE SECOND PHASE OF DISASSEMBLY, AND IS PERFORMED
*     BY DISASM. A COMMON DATA AREA, DEFINED IN DISASM, IS
*     PASSED TO THIS PROGRAM ON ENTRY.
*
*     THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE
*     REFORMATTED AND STORED IN A TABLE - UP TO 256 USING
*     STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE
*     USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE
*     REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS
*     MAY BE ENTERED. DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,
*     OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAM WHERE NO INSTRUCTIONS
*     OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.
*
*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE
*     USING THE TEXT STORED BY DISASM. ANY RESOLVABLE ADDRESS
*     WITHIN THE TEXT IS USED TO CREATE A NEW ENTRY IN THE
*     LABEL TABLE, WHICH WILL BE USED BY DISASM2 IN THE
*     ACTUAL DIS-ASSEMBLY PASS.
*
*     DISASSEMBLY TABLES ARE SET UP SIMILARLY TO THOSE USED BY
*     DISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS
*     MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS
*     ARE ENTERED.
*
*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,
*     AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER
*     AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED
*     IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE
*     PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN
*     TO DISASM.
*
*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED
*     DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR
*     LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES
*     BY DISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED
*     WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL
*     TABLE TO BE USED BY DISASM2.
*
*
*
*       DISASM2 FUNCTIONS:
*
*     THIS SUB-PROGRAM IS CALLED BY DISASM AFTER COMPLETION OF
*     PROCESSING BY DISASM1. THE FINAL LABEL TABLE
*     AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER
*     AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
*     TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,
*     AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN
*     TO THE SYSPUNCH DATASET FOR FURTHER PROCESSING BY OTHER
*     MODULES.
*
*     A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF
*     IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,
*     AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES
*     NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE
*     PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT
*     TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED
*     THEIR INCLUSION AT EXEC TIME.
*
*
*
* 7. INSTALLATION.
*
*     A. ASSEMBLE AND LINK THE THREE PROGRAMS, DISASM, DISASM1, AND
*        DISASM2.
*     B. IF A SINGLE LOAD MODULE IS DESIRED, THE LOAD AND BALR CODE
*        IN PROGRAM DISASM, LINES 10490-10590, AND LINES 11620-11720
*        MAY BE CHANGED TO CALLS, PASSING THE ADDRESS OF THE COMMON
*        PARAMETER AREA AS A PARAMETER. THE THREE PROGRAMS WILL ALL
*        BE LINKED INTO A SINGLE MODULE WITH ENTRY POINT DISASM, IF
*        THIS IS DONE.
*     C. IF STORAGE UTILIZATION IS FOUND TO BE EXCESSIVE, INVESTIGATE
*        THE POSSIBILITY OF REDUCING THE SIZE OF THE TABLE GETMAINS
*        IN DISASM LINES 1360, 1380, 1440, 1500, 5460, AND 9450, AND
*        IN DISASM1 LINES 1520, 1610, 4160. THE PROGRAMS WERE WRITTEN
*        FOR EASE OF USE WITH AN MVS OPERATING SYSTEM, AND MAY CAUSE
*        PROBLEMS IN A STORAGE CONSTRAINED ENVIRONMENT.
*     D. THE SVC TABLE AND INSTRUCTION OP CODE TABLES IN DISASM1 AND
*        DISASM2 SHOULD BE CHECKED FOR OPERATING SYSTEM VALIDITY,
*        AND CURRENCY WITH THE HARDWARE FROM TIME TO TIME.
*     E. MACROS USED BY THE DISASSEMBLER INCLUDE SVLNK AND REQU.
*        SVLNK IS USED TO ESTABLISH ADDRESSABILITY AND CHAIN
*        SAVE AREAS DURING INITIALIZATION IN EACH PROGRAM, AND
*        SET UP REGISTER EQUATES BY USE OF THE REQU MACRO. THE
*        REQU MACRO IS ALSO PLACED IN EACH DISASSEMBLED PROGRAM
*        IF THESE MACROS ARE USED, THEY SHOULD BE PLACED IN A MACRO
*        LIBRARY OR PREFIXED TO THE SOURCE BEFORE ASSEMBLY. IF
*        OTHER MACROS ARE USED IN THEIR PLACE, MAKE APPROPRIATE
*        SOURCE CODE CHANGES IN DISASM, DISASM1, AND DISASM2
*        BEFORE ASSEMBLY.
*     F. DIRECT TECHNICAL INQUIRIES, COMMENTS, SUGGESTIONS FOR
*        IMPROVEMENTS, ETC, TO:
*             DICK THORNTON
*             BLUE CROSS OF VIRGINIA
*             2015 STAPLES MILL ROAD
*             RICHMOND, VA. 23279
*
*             PHONE: (804) 359-7248
./ ADD NAME=DUMPFIL  0100-88043-88043-1408-00182-00182-00000-USER02
* * * *  USE  OF  DUMPFIL  * * *                                      *
* 1.  DUMPFIL IS A GENERAL PURPOSE FILE DUMP UTILITY WHICH WILL PRINT *
*        SEQUENTIAL, ISAM, AND VSAM FILES IN CHARACTER, HEXADECIMAL,  *
*        OR A COMBINATION OF BOTH. ITS OPERATION IS CONTROLLED BY USE *
*        OF TWO CONTROL CARDS, BOTH OF WHICH ARE OPTIONAL. AN OPTIONAL*
*        OUTPUT FILE OF THE RECORDS SELECTED  MAY BE CREATED.         *
* 2.  EXECUTION - A PROC NAMED DUMPFIL IS EXECUTED, WHICH REQUIRES A  *
*        DD CARD FOR THE FILE TO BE DUMPED. THE DDNAME FOR THIS CARD  *
*        MUST BE DUMPIN. DCB PARAMETERS MAY BE SPECIFIED IN THE DD    *
*        CARD, OTHERWISE THE FILE LABEL RECFM, LRECL, AND BLKSIZE WILL*
*        BE USED. IF VSAM IS DUMPED, THEN AMP=(AMORG,'RECFM=FB') MUST *
*        BE CODED. IF NON-STANDARD OR UNLABELLED TAPE IS TO BE DUMPED,*
*        DCB PARAMETERS MUST BE SPECIFIED. IF FILE CHARACTERISTICS ARE*
*        UNKNOWN, ANY FILE MAY BE DUMPED BY SPECIFYING RECFM=U AND    *
*        BLKSIZE=32760 FOR TAPE, OR THE MAXIMUM TRACK SIZE FOR DISK.  *
*        WHEN RECFM=U IS SPECIFIED, THE DUMP OUTPUT WILL BE PHYSICAL  *
*        BLOCKS, RATHER THAN LOGICAL RECORDS. TO CREATE AN OUTPUT FILE*
*        OF THE RECORDS SELECTED, SUPPLY A DUMPOUT DD CARD, WHICH MUST*
*        SPECIFY ALL NECESSARY DCB PARAMETERS, SUCH AS RECFM, LRECL,  *
*        BLKSIZE, RKP, CYLOFL, KEYLEN, DSORG, ETC.                    *
* 3.  IF CONTROL CARDS ARE TO BE USED, THEY ARE ENTERED FOLLOWING A   *
*        //SYSIN DD *                                                 *
*        THE SYSIN DD CARD MAY BE OMITTED IF NO CONTROL CARDS ARE USED*
* 4.  THE PRINT OPTION CARD IS FIXED FORMAT. ONLY ONE IS PERMITTED PER*
*        RUN. IF NO CONTROL CARDS ARE ENTERED, THE DEFAULT VALUES     *
*        ASSUMED ARE: TWO-LINE MIXED CHARACTER/HEX LISTING WITH A LOC-*
*        ATOR BAR BELOW EACH LINE TO IDENTIFY THE POSITION OF CHARAC- *
*        TERS IN THE RECORD. 50 RECORDS WILL BE PRINTED, AND A PHYSIC-*
*        ALLY SEQUENTIAL FILE IS ASSUMED INPUT. THE PRINT OPTION CARD *
*        FORMAT IS:                                                   *
*        COL 1:     *                                                 *
*        COL 2:     H=HEX ONLY, C=CHARACTER ONLY, 3=THREE-LINE        *
*                   COMBINED CHARACTER-HEX PRINTOUT.                  *
*        COL 4:     N=NO PRINT LOCATOR BAR AFTER EACH LINE            *
*        COL 6-10:  NUMBER OF RECORDS TO BE PRINTED, BLANK INDICATING *
*                   DEFAULT. THE NUMBER MUST BE RIGHT JUSTIFIED, WITH *
*                   LEADING ZEROS. IF OVER 1,000 RECORDS ARE REQUESTED*
*                   OPERATOR PERMISSION IS REQUESTED.                 *
*        COL 12-13: FILE TYPE, BLANK=PHYSICALLY SEQUENTIAL,           *
*                   IS=ISAM OR VSAM, VS=VARIABLE SPANNED.             *
*        COL 15-16: OUTPUT FILE TYPE, IS = ISAM, ELSE LEAVE BLANK.    *
*                   OTHER PARAMETERS WILL BE PICKED UP FROM THE DD    *
*                   CARD.                                             *
*        COL 18-22: STARTING RECORD NUMBER IN FILE. IF BLANK, DUMP    *
*                   WILL BEGIN WITH THE FIRST RECORD IN THE FILE.     *
*        COL 24-79: STARTING GROUP KEY FOR ISAM/VSAM. ANY VALUE WITH  *
*                   NO IMBEDDED BLANKS. DEFAULT IS BEGINNING OF FILE. *
* 5.  RECORD SELECTION CARD. THIS CARD IS OPTIONAL, SPECIFIES THE     *
*        CONDITIONS UNDER WHICH RECORDS ARE TO BE PRINTED. IF OMITTED,*
*        ALL RECORDS ARE PRINTED. THE FORMAT IS FIXED, AND UP TO 25   *
*        CARDS MAY BE ENTERED PER RUN.                                *
*        COL 1:     S                                                 *
*        COL 2-9:   IDENTIFIER TO BE PRINTED WHEN THIS RECORD TYPE IS *
*                   FOUND. MAY BE BLANK.                              *
*        COL 11-15: STARTING POSITION IN RECORD OF FIELD TO BE CHECKED*
*                   MUST BE NUMERIC WITH LEADING ZERO, AND GREATER    *
*                   THAN 00. THE FIRST BYTE OF THE RECORD IS SPECIFIED*
*                   AS 00001. DO NOT ADD 4 FOR VARIABLE RECORDS.      *
*        COL 17-18: LENGTH OF FIELD TO BE CHECKED. MUST BE NUMERIC    *
*                   01-16.                                            *
*        COL 20-22: COMPARISON, LEFT JUSTIFIED: EQ, NE, LT, GT, NGT,  *
*                   OR NLT. FOR A TEST UNDER MASK COMPARE, THE VALUES *
*                   O, NO, Z, NZ, OR M MAY BE USED. IN THIS CASE, THE *
*                   LENGTH MUST BE 01, AND THE COMPARISON VALUE MUST  *
*                   BE GIVEN IN HEX: ONE BYTE, WHICH IS TWO HEX DIGITS*
*                   EACH 0-9 OR A-F IN VALUE.                         *
*        COL 23:    BLANK FOR CHARACTER VALUE, X FOR HEXADECIMAL VALUE*
*                   WHEN X IS USED, THE VALUE GIVEN MUST BE IN HEX    *
*                   DIGITS WHOSE VALUES MAY BE 0-9 OR A-F. TWO DIGITS *
*                   REPRESENT ONE BYTE, AND AN EVEN NUMBER OF DIGITS  *
*                   MUST BE ENTERED.                                  *
*        COL 24-39: COMPARISON VALUE - ANY VALUE FOR THE LENGTH IN    *
*                   COLUMNS 17-18. BE SURE TO USE THE SAME DATA TYPE  *
*                   FOUNT IN THE RECORD . PACKED DECIMAL FIELDS MAY BE*
*                   ENTERED BY USE OF THE HEX FEATURE, OR BY MULTI-   *
*                   PUNCHING THE VALUE. SIGNS ARE NOT CHECKED.        *
*                   REMEMBER THAT HEXADECIMAL REQUIRES TWO DIGITS PER *
*                   BYTE, THEREFORE ONLY 8 BYTES OF HEX DATA MAY BE   *
*                   ENTERED.                                          *
*        COL 41-43: RELATIONSHIP, 1ST TO 2ND COMPARISON: 'AND' OR 'OR'*
*                   BLANK IF ONLY ONE FIELD IN CARD.                  *
*        COL 45-49: SAME AS COL 11-15, FOR 2ND FIELD                  *
*        COL 51-52: SAME AS COL 17-18, FOR 2ND FIELD.                 *
*        COL 54-56: SAME AS COL 20-22, FOR 2ND FIELD.                 *
*        COL 57:    SAME AS COL 23, FOR 2ND FIELD.                    *
*        COL 58-73: SAME AS COL 24-39, FOR 2ND FIELD.                 *
*        COL 75-77: BLANK                                             *
*        COL 78-80: NUMBER OF THESE RECORDS TO BE SELECTED.           *
* 6.  IF ANY CONTROL CARD ERRORS ARE FOUND, 'ERROR IN CONTROL CARD'   *
*        WILL BE PRINTED AT THE TOP OF THE FIRST PAGE, AND DEFAULTS   *
*        PER 4., ABOVE, ARE ASSUMED.                                  *
* 7.  THE PROC TO EXECUTE DUMPFIL IS:                                 *
*        //DUMPFIL EXEC PGM=DUMPFIL                                   *
*        //SYSUDUMP DD SYSOUT=A                                       *
*        //SYSPRINT DD SYSOUT=A                                       *
* 8.  EXAMPLES.                                                       *
*     A. DUMP A TAPE IN CHARACTER FORMAT, PRINT FIRST 100 RECORDS WITH*
*        NO LOCATOR BAR:                                              *
*        //DMS0650 EXEC DUMPFIL                                       *
*        //DUMPIN DD DSN=MEDICAID.DSM0650.CLAIMS,DISP=OLD,UNIT=TAPE,  *
*        // VOL=SER=002076                                            *
*        //SYSIN DD *                                                 *
*        *C N 00100                                                   *
*     B. DUMP AN ISAM FILE, PRINTING ONLY RECORDS HAVING 73 IN POS-   *
*        ITIONS 15-16, WHICH ARE IDENTIFIED AS '1973RECD', AND RECORDS*
*        WITH 72 IN POSITIONS 15-16, WHICH ARE IDENTIFIED BY          *
*        '1972RECD'. PROCESSING WILL BEGIN WITH THE FIRST RECORD ON   *
*        THE FILE. SELECTED RECORDS WILL BE PRINTED IN 3-LINE COMBINED*
*        CHARACTER AND HEX. NOTE THE * CONTROL CARD SPECIFIES AN ISAM *
*        FILE IS INPUT.                                               *
*        //DST0410 EXEC DUMPFIL                                       *
*        //DUMPIN DD DSN=GRPMAST,DISP=SHR,DCB=DSORG=IS                *
*        //SYSIN DD *                                                 *
*        *3         IS                                                *
*        S1972RECD 00015    EQ  72                                    *
*        S1973RECD 00015    EQ  73                                    *
*     C. DUMP A CATALOGUED TAPE FILE USING DEFAULT PRINT OPTIONS, AND *
*        PRINTING ONLY RECORDS HAVING A 2 IN POSITION 30, AND A VALUE *
*        LESS THAN 09 IN POSITIONS 3-4:                               *
*        //RSX0500 EXEC DUMPFIL                                       *
*        //DUMPIN DD DSN=SUBSCRIB.MASTAPE,DISP=OLD                    *
*        //SYSIN DD *                                                 *
*        S         00030 01 EQ  2                AND 00003 02 LT  09  *
*     D. DUMP A  VSAM INPUT FILE NAMED SUBSCRIB.CLM, SELECTING ALL    *
*        RECORDS HAVING AN 'A' IN POSITION 3, AND A 'B' IN POSITION 6.*
*        CREATE A SEQUENTIAL OUTPUT FILE OF THE SELECTED RECORDS WHICH*
*        WILL BE CALLED TESTFILE.                                     *
*        //MLR0040 EXEC DUMPFIL                                       *
*        //DUMPIN DD DSN=SUBSCRIB.CLM,DISP=SHR,AMP=(AMORG,'RECFM=FB') *
*        //DUMPOUT DD DSN=TESTFILE,DISP=(NEW,CATLG,DELETE),UNIT=3330, *
*        // DCB=(RECFM=FB,LRECL=140,BLKSIZE=6440),SPACE=(CYL,(2,1))   *
*        //SYSIN DD *                                                 *
*        S         00003 01 EQ  A                AND 00006 01 EQ  C   *
*        SRECDNAME 00009 01 EQ  C                                     *
*     E. DUMP A SEQUENTIAL INPUT FILE CALLED SEQNTL.INPUT, SELECTING  *
*        UP TO 7 RECORDS HAVING 'ABC' IN POSITIONS 10-12, UP TO 99    *
*        RECORDS HAVING THE '80' BIT ON IN POSITION 96, AND ALL       *
*        RECORDS HAVING AN 'R' IN POSITION 18. AN ISAM OUTPUT FILE OF *
*        THE RECORDS SELECTED IS CREATED, CALLED TESTISAM. NOTE THAT  *
*        AN OVERALL MAXIMUM OF 1700 RECORDS WILL BE OUTPUT, AND AN ISAM
*        OUTPUT FILE IS SPECIFIED BY THE * CONTROL CARD.              *
*        //PLS0073 EXEC DUMPFIL                                       *
*        //DUMPIN DD DSN=SEQNTL.INPUT,DISP=SHR                        *
*        //DUMPOUT DD DSN=TESTISAM,DISP=(NEW,KEEP,KEEP),UNIT=SYSTS,   *
*        // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6400,RKP=1,KEYLEN=6,       *
*        // CYLOFL=1,DSORG=IS),SPACE=(CYL,(30,,2),,CONTIG)            *
*        //SYSIN DD *                                                 *
*        *3 N 01700    IS                                             *
*        SPOS7ABC  00010 03 EQ  ABC                                   *
*                                         (POS 78-80):007             *
*        SBIT8ON   00096 01 O  X80                                    *
*                                         (POS 78-80):099             *
*        SR18      00018 01 EQ  R                                     *
*                                                                     *
*                                                                     *
*     F. DUMP A SEQUENTIAL SMF FILE CALLED SYS.SMFDUMP.WEEKLY,        *
*        SELECTING ALL RECORDS FOR THE JOB NAMED VAMT3167 ON DATE     *
*        85/238. AN OUTPUT FILE OF THE SELECTED RECORDS IS CALLED     *
*        T1804.SMFDUMP.DATA.                                          *
*        //DUMPFILE EXEC PGM=DUMPFIL                                  *
*        //SYSPRINT DD   SYSOUT=*,DCB=BLKSIZE=133                     *
*        //DUMPIN   DD DSN=SYS.SMFDUMP.WEEKLY,DISP=SHR                *
*        //DUMPOUT DD DSN=T1804.SMFDUMP.DATA,DISP=(,CATLG),           *
*        //        UNIT=DISK,SPACE=(CYL,(2,1))                        *
*        //        DCB=(RECFM=VBS,LRECL=32756,BLKSIZE=23476)          *
*        //SYSIN    DD *                                              *
*        *3 N 00999    VS                                             *
*        S         00015 08 EQ  VAMT3167       AND 00007 03 EQ X85238F*
*                                                                     *
*                                                                     *
* 9.  NOTES ON USE, AND COMMON ERRORS.                                *
*     A. INCORRECT OUTPUT: CHECK CONTROL CARD(S) FOR ERRORS. CHECK    *
*        FOR ERROR MESSAGE AT TOP OF FIRST PAGE OF OUTPUT. BE SURE    *
*        VS IS SPECIFIED FOR VARIABLE BLOCKED FILES, AND IS FOR ISAM  *
*        OR VSAM FILES ON THE * OPTION CARD.                          *
*     B. THE RECORD COUNTER HAS ONLY 5 POSITIONS, SO RECORDS IN A     *
*        FILE CONTAINING OVER 99,999 RECORDS MAY NOT BE CORRECTLY     *
*        IDENTIFIED BY RECORD NUMBER. THAT IS, RECORD 1,023 MIGHT     *
*        REALLY BE 101,023, 201,023, 303,023, ETC.                    *
*     C. 0C1 ABENDS MAY OCCUR IF THE DUMPIN DD CARD IS MISSING OR IF  *
*        THE DDNAME IS MISSPELLED, OR IF AN ISAM DATASET IS INPUT,    *
*        BUT IS IS NOT SPECIFIED ON THE * OPTION CARD.                *
./ ADD NAME=DYNALOC1 0100-90284-90284-1444-00172-00172-00000-USER02
           ***** DYNALLOC SUBROUTINE *****

 THE DYNALLOC SUBROUTINE IS USED TO ALLOCATE A FILE TO A PROGRAM
 DURING EXECUTION, WITHOUT THE USE OF A DD CARD IN THE EXECUTION
 JCL. THE USER FILLS IN DESIRED DD CARD INFORMATION IN A PARAMETER
 FIELD, AND CALLS THE DYNALLOC SUBROUTINE, PASSING THE DD CARD
 INFORMATION AND A PARAMETER CONTAINING RETURN INFORMATION.
 IN ADDITION, THE USER MAY REQUEST VOLUME SERIAL NUMBER FEEDBACK.


 FOR ALLOCATION, THE SUBROUTINE WILL FREE ANY CURRENT USE OF THE
 DDNAME GIVEN, THEN ALLOCATE THE FILE DESCRIBED BY THE PARAMETER
 FIELDS SUPPLIED. THE RETURN CODE, ERROR RETURN CODE, AND INFORMATION
 REASON CODE FROM DYNAMIC ALLOCATION ARE RETURNED TO THE CALLER.
 THE DYNALLOC SUBROUTINE MAY BE CALLED ANY NUMBER OF TIMES DURING
 EXECUTION OF A JOB STEP. IF THE SAME DDNAME IS TO BE RE-ALLOCATED
 BE SURE TO CLOSE THE FILE BEFORE CALLING DYNALLOC FOR ALLOCATION
 AGAIN.

 FOR VOLUME SERIAL NUMBER FEEDBACK, THE CALLER USES THE 'V' REQUEST
 CODE, AND PLACES THE DDNAME OF THE FILE IN THE FIRST PARAMETER.
 ON RETURN, THE VOLUME SERIAL NUMBER WILL BE IN THE APPROPRIATE
 FIELD IN THE FIRST PARAMETER, OR BLANK IF THE DDNAME COULD NOT
 BE FOUND. IN ADDITION, THE DEVICE ADDRESS WILL BE IN THE FIRST
 PARAMETER UNIT NAME FIELD. THIS CAN BE USED IN SUBSEQUENT CALLS
 TO INSURE ALLOCATION OF THE SAME DRIVE, IF THIS IS DESIRABLE.
 BEFORE CALLING FOR VOLUME SERIAL FEEDBACK, THE FILE MUST BE OPEN.

 THE FIRST PARAMETER PASSED CONTAINS INFORMATION NORMALLY SUPPLIED
 BY A DD CARD. THE USER SHOULD FIRST MOVE BINARY ZEROS TO THE
 FIELD, THEN FILL IN THE FIELDS OF INTEREST. ANY FIELD CONTAINING
 BINARY ZEROS WILL BE IGNORED.

 THE DSNAME FIELD IS USED TO SPECIFY THE DSNAME FOR NORMAL DATASETS,
 AND IS ALSO USED TO ALLOCATE DUMMY DATASETS (MOVE "DUMMY" TO THE
 DSNAME FIELD), OR FOR SYSOUT DATASETS (MOVE "SYSOUT=A" TO THE DSNAME
 FIELD, OR "SYSOUT=B", ETC). IF A SYSOUT DATASET IS SPECIFIED, THE
 MEMBER NAME FIELD MAY BE USED TO SPECIFY THE DESTINATION FOR THE SYSOUT
 DATA. FOR A PDS, PUT THE DSNAME IN THE DSNAME FIELD AND THE MEMBER
 NAME IN THE MEMBER FIELD. FOR A GDG, PUT THE GENERIC DATASET NAME IN
 THE DSNAME FIELD AND THE SIGNED RELATIVE GENERATION NUMBER (WITHOUT
 PARENTHESES) IN THE MEMBER FIELD.


DAPARM1  DS    0F                      * 1ST PARAMETER FOR DYNALLOC *
DDNAME   DS    CL8                     DDNAME
DSNAME   DS    CL44                    DATASET NAME/DUMMY/SYSOUT=A
MEMBER   DS    CL8                     MEMBER NAME/SYSOUT DEST
DISP     DS    CL3                     DISPOSITION:
*                                    BYTE1: 0=OLD,M=MOD,N=NEW,S=SHR
*                                    BYTE2: U=UNCATLG,C=CATLG,D=DELETE
*                                    K=KEEP; BYTE3: SAME AS BYTE2
UNITNAME DS    CL8                     UNIT NAME
UNITCNT  DS    XL2                     UNIT COUNT
VOLSER   DS    CL6                     VOLUME SERIAL NUMBER
LBLTYPE  DS    CL1                     LABEL TYPE:
*                                      N=NL, S=SL, B=BLP
DSSEQ    DS    XL2                     DATASET SEQUENCE NBR (TAPE)
FRECLOS  DS    CL1                     F: FREE=CLOSE
RETPRD   DS    XL2                     RETENTION PERIOD IN DAYS
RECFM    DS    CL3                     RECORDING FORMAT:
*                                      BYTE1: F=FIXED, V=VARIABLE,
*                                      U=UNDEFINED; BYTE2: B=BLOCKED,
*                                      BYTE3: A=ASA CONTROL CHARACTERS
LRECL    DS    XL2                     LOGICAL RECORD LENGTH
BLKSIZE  DS    XL2                     BLOCK SIZE
DEN      DS    CL1                     TAPE DENSITY: 1=1600,6=6250
BUFNO    DS    XL2                     BUFNO
KEYLEN   DS    XL2                     KEY LENGTH
DSORG    DS    CL1                     DATASET ORGANIZATION:
*                                      V=VSAM, P=PDS, D=DIRECT, S=SEQ
SPACETYP DS    CL1                     SPACE TYPE:
*                                      C=CYL, T=TRK
PSPAC    DS    XL2                     PRIMARY SPACE AMOUNT
SSPAC    DS    XL2                     SECONDARY SPACE AMOUNT
RLSE     DS    CL1                     R=RLSE
DRCTYBLK DS    XL2                     NBR DIRECTORY BLOCKS
EXPDATE  DS    CL5                     EXPIRATION DATE, YYDDD
*
*
*
DAPARM2  DS    0F                      2ND PARAMETER FOR DYNALLOC
REQCODE  DS    CL1                     REQUEST CODE:
*                                      A=ALLOCATE A DATASET
*                                      V=VOLSER FEEDBACK
RETCODE  DS    CL2                     DYNALLOC RETURN CODE
ERRRET   DS    CL4                     ERROR RETURN CODE
INFORET  DS    CL4                     INFO RETURN CODE
*
*
*

  THE SECOND PARAMETER IS A SET OF FIELDS IN WHICH THE RESULT OF
  ALLOCATION IS RETURNED. ENVIRONMENT ERROR RESULTS FROM THE CURRENT
  ENVIRONMENT, UNAVAILABILITY OF A SYSTEM RESOURCE, OR SYSTEM ROUTINE
  FAILURE. ENVIRONMENT ERROR IS ACCOMPANIED BY AN ERROR-REASON-CODE.
  VALIDATION-DENIAL IS CAUSED BY THE INSTALLATION VALIDATION ROUTINE
  (SECURITY). PARAMETER-ERROR IS CAUSED BY AN INVALID PARAMETER LIST.
  PARAMETER-ERROR IS ALSO ACCOMPANIED BY AN ERROR-REASON-CODE.
  SUCCESSFUL-ALLOCATION MAY BE ACCOMPANIED BY AN INFORMATION-REASON
  CODE IF A NON-TERMINATING ERROR OCCURRED DURING PROCESSING. SINCE
  INFORMATION CODES ALL APPLY TO UN-ALLOCATION, THEY SHOULD NOT BE
  PERTINENT TO USERS OF THIS SUBROUTINE.
  ERROR-REASON-CODES AND INFORMATION-REASON CODES MAY BE FOUND IN
  IBM MANUAL GC28-0627: JOB MANAGEMENT.



 USE OF THE DYNALLOC SUBROUTINE: FIRST, CLEAR THE PARAMETER FIELDS TO
 LOW-VALUES, THEN FILL IN THE DESIRED FIELDS IN THE ALLOCATE-DATA
 PARAMETER BLOCK. FILL IN ALL THE FIELDS YOU WOULD ON A DD CARD FOR
 THE DESIRED ALLOCATION. DEFAULTS ARE THE SAME AS THOSE USED IF A
 DD CARD HAD BEEN USED. WHEN COMPLETE, CALL THE DYNALLOC SUBROUTINE
 PASSING THE TWO PARAMETER BLOCKS. ON RETURN, CHECK THE RETURN CODE
 FOR ERRORS, AND IF THERE ARE NONE, A DD CARD HAS BEEN CREATED. IF
 A TAPE WAS ALLOCATED, A MOUNT REQUEST WAS GIVEN TO THE OPERATOR.
 AT THIS POINT, AN OPEN MAY BE ISSUED FOR THE FILE, AND PROCESSING
 MAY TAKE PLACE NORMALLY. ANY PREVIOUS DD CARD OR DYNAMIC ALLOCATION
 FOR THE DDNAME GIVEN IS CANCELLED ON ENTRY TO THE DYNALLOC
 SUBROUTINE, SO THE USER SHOULD NOT INCLUDE A DD CARD WITH THE
 REQUESTED DDNAME IN THE EXECUTION JCL FOR THE JOB STEP.

 EXAMPLE1: ALLOCATE THE FOLLOWING DD CARD -
          //OUTPUT1 DD DSN=MTT.PROCESS.TAPE,DISP=(NEW,CATLG,DELETE),
          //          UNIT=TAPE,DCB=(RECFM=VB,LRECL=320,BLKSIZE=3204)
            .
            .
            XC    DAPARM1(DAPARM2-DAPARM1),DAPARM1CLEAR PARM
            MVC   DDNAME,=C'OUTPUT1'              MOVE IN DD NAME
            MVC   DSNAME,=C'MTT.PROCESS.TAPE'     MOVE IN DSNAME
            MVC   DISP,=C'NCD'                    SET NEW,CATLG,DELETE
            MVC   UNITNAME(4),=C'TAPE'            SET UNIT=TAPE
            MVC   RECFM,C'VB '                    RECFM=VB
            MVC   LRECL,=H'320'                   LRECL=320
            MVC   BLKSIZE,=H'3204'                BLKSIZE=3204
            CALL  DYNALLOC,(DAPARM1,DAPARM2)      ALLOCATE THE DATASET
            CLC   RETCODE,=C'00'                  ANY ERROR?
            BE    ALLOCERRS                       YES
            .
            .
            .


 EXAMPLE2: OBTAIN THE VOLUME SERIAL NUMBER OF THE DEVICE ALLOCATED
           FOR DDNAME OUTPUT1:


               .
               .
               MVI   REQCODE,C'V'               VOL SER REQUEST
               MVC   DDNAME,=C'OUTPUT1'         DDNAME TO PARM FIELD
               CALL  DYNALLOC,(DAPARM1,DAPARM2) GET THE VOLUME SERIAL
               MVC   PRTVOL,VOLSER              USE THE VOL SER
               .
               .
               .



 EXAMPLE3: ALLOCATE THE FOLLOWING DD CARD -
           //PRINT1  DD  SYSOUT=B,DEST=R15


            .
            .
            XC    DAPARM1(DAPARM2-DAPARM1),DAPARM1CLEAR PARM
            MVC   DDNAME,=CL8'PRINT1'             MOVE IN DD NAME
            MVC   DSNAME(8),=CL8'SYSOUT=B'        MOVE IN SYSOUT=B
            MVC   MEMBER,=CL8'R15'                SET DEST=R15
            CALL  DYNALLOC,(DAPARM1,DAPARM2)      ALLOCATE THE DATASET
            CLC   RETCODE,=C'00'                  ANY ERROR?
            BE    ALLOCERRS                       YES
./ ADD NAME=DYNALOC2 0100-90284-90284-1513-00207-00207-00000-USER02
           ***** DYNALLOC SUBROUTINE *****

 THE DYNALLOC SUBROUTINE IS USED TO ALLOCATE A FILE TO A PROGRAM
 DURING EXECUTION, WITHOUT THE USE OF A DD CARD IN THE EXECUTION
 JCL. THE USER FILLS IN DESIRED DD CARD INFORMATION IN A PARAMETER
 FIELD, AND CALLS THE DYNALLOC SUBROUTINE, PASSING THE DD CARD
 INFORMATION AND A PARAMETER CONTAINING RETURN INFORMATION.
 IN ADDITION, THE USER MAY REQUEST VOLUME SERIAL NUMBER FEEDBACK.


 FOR ALLOCATION, THE SUBROUTINE WILL FREE ANY CURRENT USE OF THE
 DDNAME GIVEN, THEN ALLOCATE THE FILE DESCRIBED BY THE PARAMETER
 FIELDS SUPPLIED. THE RETURN CODE, ERROR RETURN CODE, AND INFORMATION
 REASON CODE FROM DYNAMIC ALLOCATION ARE RETURNED TO THE CALLER.
 THE DYNALLOC SUBROUTINE MAY BE CALLED ANY NUMBER OF TIMES DURING
 EXECUTION OF A JOB STEP. IF THE SAME DDNAME IS TO BE RE-ALLOCATED
 BE SURE TO CLOSE THE FILE BEFORE CALLING DYNALLOC FOR ALLOCATION
 AGAIN.

 FOR VOLUME SERIAL NUMBER FEEDBACK, THE CALLER USES THE 'V' REQUEST
 CODE, AND PLACES THE DDNAME OF THE FILE IN THE FIRST PARAMETER.
 ON RETURN, THE VOLUME SERIAL NUMBER WILL BE IN THE APPROPRIATE
 FIELD IN THE FIRST PARAMETER, OR BLANK IF THE DDNAME COULD NOT
 BE FOUND. IN ADDITION, THE DEVICE ADDRESS WILL BE IN THE FIRST
 PARAMETER UNIT NAME FIELD. THIS CAN BE USED IN SUBSEQUENT CALLS
 TO INSURE ALLOCATION OF THE SAME DRIVE, IF THIS IS DESIRABLE.
 BEFORE CALLING FOR VOLUME SERIAL FEEDBACK, THE FILE MUST BE OPEN.

 THE FIRST PARAMETER PASSED CONTAINS INFORMATION NORMALLY SUPPLIED
 BY A DD CARD. THE USER SHOULD FIRST MOVE BINARY ZEROS TO THE
 FIELD, THEN FILL IN THE FIELDS OF INTEREST. ANY FIELD CONTAINING
 BINARY ZEROS WILL BE IGNORED.

 THE DSNAME FIELD IS USED TO SPECIFY THE DSNAME FOR NORMAL DATASETS,
 AND IS ALSO USED TO ALLOCATE DUMMY DATASETS (MOVE "DUMMY" TO THE
 DSNAME FIELD), OR FOR SYSOUT DATASETS (MOVE "SYSOUT=A" TO THE DSNAME
 FIELD, OR "SYSOUT=B", ETC). IF A SYSOUT DATASET IS SPECIFIED, THE
 MEMBER NAME FIELD MAY BE USED TO SPECIFY THE DESTINATION FOR THE SYSOUT
 DATA. FOR A PDS, PUT THE DSNAME IN THE DSNAME FIELD AND THE MEMBER
 NAME IN THE MEMBER FIELD. FOR A GDG, PUT THE GENERIC DATASET NAME IN
 THE DSNAME FIELD AND THE SIGNED RELATIVE GENERATION NUMBER (WITHOUT
 PARENTHESES) IN THE MEMBER FIELD.

       01  ALLOCATE-DATA.
           05 DDNAME                   PIC X(8).
           05 DSNAME-DUMMY-SYSOUT      PIC X(44).
           05 MEMBER-NAME-DEST-ID      PIC X(8).
           05 CURRENT-STATUS           PIC X.
              88 STATUS-OLD            VALUE 'O'.
              88 STATUS-MOD            VALUE 'M'.
              88 STATUS-NEW            VALUE 'N'.
              88 STATUS-SHR            VALUE 'S'.
           05 NORMAL-DISPOSITION       PIC X.
              88 NORM-UNCATLG          VALUE 'U'.
              88 NORM-CATLG            VALUE 'C'.
              88 NORM-DELETE           VALUE 'D'.
              88 NORM-KEEP             VALUE 'K'.
           05 CONDITIONAL-DISPOSITION  PIC X.
              88 COND-UNCATLG          VALUE 'U'.
              88 COND-CATLG            VALUE 'C'.
              88 COND-DELETE           VALUE 'D'.
              88 COND-KEEP             VALUE 'K'.
           05 UNIT-NAME                PIC X(8).
           05 UNIT-COUNT               PIC S9(4) COMP.
           05 VOLUME-SERIAL            PIC X(6).
           05 LABEL-TYPE               PIC X.
              88 NO-LABELS             VALUE 'N'.
              88 STANDARD-LABELS       VALUE 'S'.
              88 BYPASS-LABELS         VALUE 'B'.
           05 DATASET-SEQUENCE         PIC S9(4) COMP.
           05 FREE-CLOSE               PIC X.
              88 FREE-WHEN-CLOSED      VALUE 'F'.
           05 RETENTION-PERIOD-DAYS    PIC S9(4) COMP.
           05 RECORDING-MODE           PIC X.
              88 FIXED-RECORDS         VALUE 'F'.
              88 VARIABLE-RECORDS      VALUE 'V'.
              88 UNDEFINED-RECORDS     VALUE 'U'.
              88 FIXED-STANDARD        VALUE 'S'.
           05 BLOCKING                 PIC X.
              88 BLOCKED-RECORDS       VALUE 'B'.
           05 CONTROL-CHARACTERS       PIC X.
              88 ASA-CONTROL-CHAR      VALUE 'A'.
           05 LOGICAL-RECORD-LENGTH    PIC S9(4) COMP.
           05 BLOCK-LENGTH             PIC S9(4) COMP.
           05 TAPE-DENSITY             PIC X.
              88 800-BPI               VALUE '8'.
              88 1600-BPI              VALUE '1'.
              88 6250-BPI              VALUE '6'.
           05 NUMBER-BUFFERS           PIC S9(4) COMP.
           05 KEY-LENGTH               PIC S9(4) COMP.
           05 DATASET-ORGANIZATION     PIC X.
              88 VSAM-DATASET          VALUE 'V'.
              88 PARTITIONED-DATASET   VALUE 'P'.
              88 DIRECT-DATASET        VALUE 'D'.
              88 PHYSICAL-SEQUENTIAL   VALUE 'S'.
           05 SPACE-TYPE               PIC X.
              88 CYLINDER-REQUEST      VALUE 'C'.
              88 TRACK-REQUEST         VALUE 'T'.
           05 PRIMARY-SPACE-AMOUNT     PIC S9(4) COMP.
           05 SECONDARY-SPACE-AMOUNT   PIC S9(4) COMP.
           05 RELEASE-SPACE            PIC X.
              88 RELEASE-UNUSED        VALUE 'R'.
           05 NBR-DIRECTORY-BLOCKS     PIC S9(4) COMP.
           05 EXPIRATION-DATE-YYDDD    PIC X(5).

  THE SECOND PARAMETER IS A SET OF FIELDS IN WHICH THE RESULT OF
  ALLOCATION IS RETURNED. ENVIRONMENT ERROR RESULTS FROM THE CURRENT
  ENVIRONMENT, UNAVAILABILITY OF A SYSTEM RESOURCE, OR SYSTEM ROUTINE
  FAILURE. ENVIRONMENT ERROR IS ACCOMPANIED BY AN ERROR-REASON-CODE.
  VALIDATION-DENIAL IS CAUSED BY THE INSTALLATION VALIDATION ROUTINE
  (SECURITY). PARAMETER-ERROR IS CAUSED BY AN INVALID PARAMETER LIST.
  PARAMETER-ERROR IS ALSO ACCOMPANIED BY AN ERROR-REASON-CODE.
  SUCCESSFUL-ALLOCATION MAY BE ACCOMPANIED BY AN INFORMATION-REASON
  CODE IF A NON-TERMINATING ERROR OCCURRED DURING PROCESSING. SINCE
  INFORMATION CODES ALL APPLY TO UN-ALLOCATION, THEY SHOULD NOT BE
  PERTINENT TO USERS OF THIS SUBROUTINE.
  ERROR-REASON-CODES AND INFORMATION-REASON CODES MAY BE FOUND IN
  IBM MANUAL GC28-0627: JOB MANAGEMENT.

  THE FIELD IS FORMATTED AS FOLLOWS:

       01 ALLOCATION-RESULT.
           05 DYNALLOC-REQUEST         PIC X.
              88 ALLOCATION-REQUEST    VALUE 'A'.
              88 VOLSER-REQUEST        VALUE 'V'.
           05 DYNALLOC-RETURN-CODE     PIC XX.
              88 SUCCESSFUL-ALLOCATION VALUE '00'.
              88 ENVIRONMENT-ERROR     VALUE '04'.
              88 VALIDATION-DENIAL     VALUE '08'.
              88 PARAMETER-ERROR       VALUE '12'.
           05 ERROR-REASON-CODE.
              10 CLASS-7-CODE              PIC X.
              10 ERROR-CLASS               PIC X.
                 88 UNAVAILABLE-RESOURCE   VALUE '2'.
                 88 INVALID-PARAMETER-LIST VALUE '3'.
                 88 ERROR-IN-ENVIRONMENT   VALUE '4'.
                 88 SYSTEM-ROUTINE-ERROR   VALUE '7'.
              10 SPECIFIC-ERROR-CODE       PIC XX.
           05 INFORMATION-REASON           PIC X(4).


 USE OF THE DYNALLOC SUBROUTINE: FIRST, CLEAR THE PARAMETER FIELDS TO
 LOW-VALUES, THEN FILL IN THE DESIRED FIELDS IN THE ALLOCATE-DATA
 PARAMETER BLOCK. FILL IN ALL THE FIELDS YOU WOULD ON A DD CARD FOR
 THE DESIRED ALLOCATION. DEFAULTS ARE THE SAME AS THOSE USED IF A
 DD CARD HAD BEEN USED. WHEN COMPLETE, CALL THE DYNALLOC SUBROUTINE
 PASSING THE TWO PARAMETER BLOCKS. ON RETURN, CHECK THE RETURN CODE
 FOR ERRORS, AND IF THERE ARE NONE, A DD CARD HAS BEEN CREATED. IF
 A TAPE WAS ALLOCATED, A MOUNT REQUEST WAS GIVEN TO THE OPERATOR.
 AT THIS POINT, AN OPEN MAY BE ISSUED FOR THE FILE, AND PROCESSING
 MAY TAKE PLACE NORMALLY. ANY PREVIOUS DD CARD OR DYNAMIC ALLOCATION
 FOR THE DDNAME GIVEN IS CANCELLED ON ENTRY TO THE DYNALLOC
 SUBROUTINE, SO THE USER SHOULD NOT INCLUDE A DD CARD WITH THE
 REQUESTED DDNAME IN THE EXECUTION JCL FOR THE JOB STEP.

 EXAMPLE1: ALLOCATE THE FOLLOWING DD CARD -
          //OUTPUT1 DD DSN=MTT.PROCESS.TAPE,DISP=(NEW,CATLG,DELETE),
          //          UNIT=TAPE,DCB=(RECFM=VB,LRECL=320,BLKSIZE=3204)


       ALLOCATE-THE-FILE.
            MOVE LOW-VALUES TO ALLOCATE-DATA.
            MOVE 'OUTPUT1' TO DDNAME.
            MOVE 'MTT.PROCESS.TAPE' TO DSNAME.
            MOVE 'N' TO CURRENT-STATUS.
            MOVE 'C' TO NORMAL-DISPOSITION.
            MOVE 'D' TO CONDITIONAL-DISPOSITION.
            MOVE 'TAPE' TO UNIT-NAME.
            MOVE 'V' TO RECORDING-MODE.
            MOVE 'B' TO BLOCKING.
            MOVE 320 TO LOGICAL-RECORD-LENGTH.
            MOVE 3204 TO BLOCK-LENGTH.
            CALL 'DYNALLOC' USING ALLOCATE-DATA, ALLOCATION-RESULT.
            IF SUCCESSFUL-ALLOCATION OPEN OUTPUT MTT-TAPE.
               ELSE DISPLAY 'UNABLE TO ALLOCATE OUTPUT1, RETURN CODE '
                            DYNALLOC-RETURN-CODE ' ERROR REASON CODE '
                            ERROR-REASON-CODE,
                            CALL COBABEND.



 EXAMPLE2: OBTAIN THE VOLUME SERIAL NUMBER OF THE DEVICE ALLOCATED
           FOR DDNAME OUTPUT1:

               MOVE 'V' TO DYNALLOC-REQUEST.
               MOVE 'OUTPUT1' TO DDNAME.
               CALL 'DYNALLOC' USING ALLOCATE-DATA, ALLOCATION-RESULT.
               MOVE VOLUME-SERIAL TO PRINT-SERIAL-NUMBER.




 EXAMPLE3: ALLOCATE THE FOLLOWING DD CARD -
          //PRINT1  DD SYSOUT=B,DEST=R15


       ALLOCATE-THE-FILE.
            MOVE LOW-VALUES TO ALLOCATE-DATA.
            MOVE 'PRINT1' TO DDNAME.
            MOVE 'SYSOUT=B' TO DSNAME.
            MOVE 'R15' TO MEMBER-NAME.
            CALL 'DYNALLOC' USING ALLOCATE-DATA, ALLOCATION-RESULT.
            IF SUCCESSFUL-ALLOCATION OPEN OUTPUT MTT-TAPE.
               ELSE DISPLAY 'UNABLE TO ALLOCATE PRINT1, RETURN CODE '
                            DYNALLOC-RETURN-CODE ' ERROR REASON CODE '
                            ERROR-REASON-CODE,
                            CALL COBABEND.
./ ADD NAME=DYNERRS  0103-90213-92038-1133-00349-00171-00000-USER02
Information below is extracted from the ibm manuals:
   GC28-1852 SPL: Application Development Guide
             .Chapter 19, Requesting SVC 99 functions
   SC28-1875 TSO/E Version 2 Programming Services
             .Chapter 17, Reason Codes from Dynamic Allocation
             .Chapter 17, Return Codes From Dair
   SC26-4567 DFP3.3 System Programming Reference
             .Chapter 4, Return Codes From LOCATE
             .Chapter 2, DADSM CREATE Return Codes
             .Chapter 4, Return Codes From CATALOG
             .Chapter 2, Return Codes From OBTAIN

The first table contains informational messages which are not considered
to be terminating errors. The dynamic allocation/unallocation processed
successfully, however an unusual condition occurred.

The second table contains the descriptions of terminating errors. In
these cases, the requested function failed for the reason given. For
error reason codes 035C, 0360, 0374, 0378, 037C, 0380, and 0384, the
information reason code contains the value of the text unit key which
caused the error. The third table contains a description of each of
these text units.

          - - - INFORMATION REASON CODES - - -
0008 OVERRIDING DISPOSITION IGNORED
0021 NOT CATLG/UNCATLG: A CONTROL VOLUME IS REQUIRED.
0022 NOT CATLG/UNCATLG: ALREADY CATALOGED OR NOT FOUND.
0023 NOT CATLG/UNCATLG: SPECIFIED INDEX DOES NOT EXIST.
0024 NOT CATLG: NO SPACE IN CATALOG.
0025 NOT CATLG/UNCATLG: NOT ENOUGH STORAGE AVAILABLE.
0026 NOT CATLG/UNCATLG: IMPROPERLY NAMED GDG.
0027 NOT CATLG: TAPE DENSITY UNKNOWN.
0029 NOT CATLG/UNCATLG: I/O ERROR IN THE CATALOG.
0031 NOT DELETED: EXPIRATION DATE HAS NOT YET OCCURRED.
0034 NOT DELETED: NO DEVICE AVAILABLE TO MOUNT VOLUME.
0035 NOT DELETED: NOT ENOUGH STORAGE AVAILABLE.
0036 NOT DELETED: PROBLEM MOUNTING OR DISMOUNTING VOLUMES.
0038 NOT DELETED: SCRATCH ROUTINE ERROR. SEE IEF283I MESSAGE.
0050 NOT CATLG: DSNAME IS IN APOSTROPHES.
          - - - DYNAMIC ALLOCATION ERROR REASON CODES - - -
0204 VIRTUAL STORAGE UNAVAILABLE.
020C REQUEST FOR EXCLUSIVE USE OF SHARED DS CANNOT BE HONORED.
0210 THE DATA SET REQUESTED ALLOCATED TO ANOTHER JOB OR USER.
0214 A DIRECT ACCESS DEVICE IS NOT AVAILABLE.
0218 THE REQUIRED VOLUME WASNT MOUNTED ON AN AVAILABLE DEVICE.
021C INCORRECT UNIT NAME SUPPLIED.
0220 REQUESTED VOLUME NOT AVAILABLE.
0224 ELIGIBLE DEVICE TYPES DO NOT CONTAIN ENOUGH UNITS.
0228 SPECIFIED VOLUME OR UNIT IN USE BY SYSTEM.
022C VOLUME MOUNTED ON INELIGIBLE PERMANENTLY RSDNT/RSVD UNIT.
0230 PERMANENTLY RSDNT/RSVD VOLUME ON REQUIRED UNIT.
0234 MORE THAN 1 DEVICE REQUIRED FOR REQUEST FOR SPECIFIC UNIT
0238 NO SPACE AVAILABLE IN TASK INPUT OUTPUT TABLE (TIOT).
023C REQUIRED CATALOG NOT MOUNTED, USER UNAUTHORIZED TO MOUNT.
0240 REQUESTED DEVICE IS A CONSOLE.
0244 TELECOMM. DEVICE NOT ACCESSIBLE.
0248 MSS VIRTUAL VOLUME CANNOT BE MOUNTED.
024C OPERATING SYSTEM MANAGED RESOURCE UNAVAILABLE TO SUBSYSTM
0250 SUBSYSTEM RESOURCE NOT AVAILABLE.
0254 THE TIOT RESOURCE IS UNAVAILABLE AND CONDITIONAL ENQ REQ.
0258 INSUFFICIENT NBR OF UNRESTRICTED DEVICES FOR REQUEST.
025C REQUESTED DEVICE IS BOXED DUE TO I/O ERROR OR OPERATOR.
0260 UNIT DOES NOT MEET SPECIFIED STATUS REQUIREMENTS.
0264 INVALID REQUEST DUE TO CURRENT UNIT STATUS.
0268 TAPE DEVICE IS BROKEN.
026C REQUEST REQUIRES MORE SMS-MANAGED VOLUMES THAN ELIGIBLE.
0270 REQUEST NEEDS MORE NON-SMS-MANAGED VOLUMES THAN ELIGIBLE.
0304 THE DDNAME WAS NOT SPECIFIED BY THE CALLING ROUTINE.
0308 THE DDNAME SPECIFIED BY THE CALLING ROUTINE WAS NOT FOUND
0314 RESTORING DDNAMES WOULD RESULT IN DDNAME DUPLICATION.
0318 INVALID CHARACTERS ARE PRESENT IN THE DDNAME.
031C INVALID CHARACTERS ARE PRESENT IN THE MEMBER NAME.
0320 INVALID CHARACTERS ARE PRESENT IN THE DSNAME.
0324 INVALID CHARACTERS ARE PRESENT IN THE SYSOUT PROGRAM NAME
0328 INVALID CHARACTERS ARE PRESENT IN THE SYSOUT FORM NUMBER.
032C AN INVALID SYSOUT CLASS WAS SPECIFIED BY THE CALLER.
0330 A MEMBER NAME WAS SPECIFIED, BUT THE DATA SET IS NOT PDS.
0334 THE SUPPLIED DATA SET NAME EXCEEDED 44 CHARACTERS IN LEN.
0338 THE DATA SET DISPOSITION SPECIFIED IS INVALID.
0358 DELETE CANNOT BE SPECIFIED IF THE DATA SET IS SHARED.
035C INVALID PARM SPECIFIED IN TEXT UNIT: ALL FUNCTIONS.
0360 INVALID KEY SPECIFIED IN TEST UNIT: ALL FUNCTIONS.
0364 JOBLIB/STEPLIB/JOBCAT/STEPCAT DDNAMES NOT ALLOWED.
0368 AUTHORIZED FUNCTION REQUESTED BY UNAUTHORIZED USER.
036C INVALID PARAMETER LIST FORMAT: ALL FUNCTIONS.
0374 INVALID VERB SPECIFIED IN TEXT UNIT.
0378 DUPLICATE KEY SPECIFIED IN TEST UNIT.
037C INVALID LENGTH SPECIFIED IN TEXT UNIT.
0380 MUTUALLY EXCLUSIVE PARAMETERS SPECIFIED.
0384 MUTUALLY INCLUSIVE PARAMETER NOT SPECIFIED.
0388 REQUIRED PARAMETER NOT SPECIFIED.
038C DUPLICATE DDNAME SPECIFIED FOR CONCATENATION.
0390 GDG GROUP NAME SPECIFIED WITH REL. GDG NUMBER > 35 CHARS.
0394 STATUS AND RELATIVE GENERATION NUMBER ARE INCOMPATIBLE.
0398 VOLUME SEQUENCE NUMBER EXCEEDS THE NUMBER OF VOLUMES.
039C DEVICE TYPE AND VOLUME INCOMPATIBLE.
03A0 SUBSYSTEM DETECTED AN INVALID PARAMETER.
03A4 UNABLE TO PROTECT DATASET/VOLUME, CONFLICTING PARAMETER.
03A8 REQUEST BLOCK EXTENSION HAS INVALID FORMAT.
03AC THE CPPL ADDRESS IS NOT SPECIFIED IN REQUEST BLOCK EXTNSN
0410 SPECIFIED DDNAME IS ALLOCATED TO A DATA SET, CANNOT FREE.
0420 THE SPECIFIED DDNAME IS ASSOCIATED WITH AN OPEN DATA SET.
0424 DECONCATENATION WOULD RESULT IN DUPLICATE DDNAMES.
0434 DDNAME SPECIFIED IN DDNAME REQUEST IS CONVERTIBLE.
0438 SPECIFIED DDNAME NOT FOUND.
043C COULD NOT DEALLOCATE ENOUGH RESOURCES FOR CONTROL LIMIT.
0440 SPECIFIED DSNAME NOT FOUND.
0444 RELATIVE ENTRY NUMBER SPECIFIED NOT FOUND.
0448 DATA SET ALREADY EXISTS FOR A NEW ALLOCATION.
044C EXISTING DATA SET REQUESTED FOUND ALLOCATED AS DELETABLE.
0450 REQUEST WOULD EXCEED 1635 CONCURRENT ALLOCATIONS MAX.
0454 DDNAME IN DCB REFERENCE NOT FOUND.
0458 DSNAME IN DCB REFERENCE OR VOLUME REFERENCE IS GDG GROUP.
045C DSNAME TO DEALLOC IS PART OF A CONCATENATED GROUP.
0460 DSNAME TO DEALLOCATE NOT ASSOCIATED WITH SPECIFIED DDNAME
0464 DSNAME TO BE DEALLOCATED IS A PRIVATE CATALOG.
0468 ERROR WHILE ALLOCATING OR OPENING A PRIVATE CATALOG.
046C REMOTE WORKSTATION NOT DEFINED TO JOB ENTRY SUBSYSTEM.
0470 USER UNAUTHORIZED FOR SUBSYSTEM REQUEST.
0474 ERROR WHILE ATTEMPTING TO SELECT OPTIMUM DEVICE.
0478 UNABLE TO PROCESS JOB ENTRY SUBSYSTEM REQUEST.
047C UNABLE TO ESTABLISH ESTAE ENVIRONMENT.
0480 THE NUMBER OF UNITS TO SATISFY THE REQUEST EXCEEDS LIMIT.
0484 REQUEST DENIED BY OPERATOR.
0488 GDG PATTERN DSCB NOT MOUNTED.
048C GDG PATTERN DSCB NOT FOUND.
0490 ERROR CHANGING ALLOCATION ASSIGNMENTS.
0494 ERROR PROCESSING OS CVOL.
0498 MSS VIRTUAL VOLUME NOT ACCESSIBLE.
049C MSS VIRTUAL VOLUME NOT DEFINED.
04A0 SPECIFIED MSVGP NAME NOT DEFINED.
04A4 SUBSYSTEM REQUEST IN ERROR.
04A8 SUBSYSTEM DOES NOT SUPPORT ALLOCATION VIA KEY DALSSNM.
04AC SUBSYSTEM IS NOT OPERATIONAL.
04B0 SUBSYSTEM DOES NOT EXIST.
04B4 PROTECT REQUEST NOT PROCESSED. RACF NOT ACTIVE IN SYSTEM.
04B8 MSS NOT INITIALIZED FOR ALLOCATION.
04BC MSS VOLUME SELECT ERROR.
04C0 PROTECT REQUEST FAILED: USER NOT DEFINED TO RACF.
04C4 REQUEST FOR VOL=REF OR DCB=DSNAME EXCEEDED MAX REFERBACKS
04C8 NON-ZERO RETURN CODE FROM COMMON ALLOCATION OR JFCB INIT.
04CC INVALID OUTPUT DESCRIPTOR OR INVALID DDNAME REFERENCE.
04D0 SMS SUBSYSTEM IS NOT AVAILABLE.
1704 REQUIRED CATALOG CANNOT BE OPENED.
1708 DSNAME NOT FOUND IN CATALOG OR IS A GDG BASE.
170C INDEX, ALIAS, OR GDG NAME WAS FOUND.
1710 A DATASET EXISTS AT SOME LEVEL OF INDEX OTHER THAN LOWEST
1714 A SYNTAX ERROR EXISTS IN THE NAME.
1718 PERMANENT I/O ERROR FOUND WHEN PROCESSING THE CATALOG.
171C RELATIVE TRACK SUPPLIED TO LOCATE IS OUT OF THE CATALOG.
1726 DFHSM LOCATE PREPROCESSOR EXPERIENCED AN ERROR.
4704 DUPLICATE DATA SET NAME.
4708 NO AVAILABLE ROOM IN THE VTOC OR VTOC INDEX.
470C A PERMANENT I/O ERROR IN THE VTOC OR VTOC INDEX.
4710 THE ABSOLUTE TRACK REQUESTED IS NOT AVAILABLE.
4714 THE QUANTITY OF SPACE REQUESTED IS NOT AVAILABLE.
4718 THE RECORD LENGTH SPECIFIED IS GREATER THAN 65,535 BYTES.
471C WRONG DSORG FOR ISAM INDEX REQUEST.
4720 NO PRIME AREA REQUEST FOR ISAM DATA SET.
4724 PRIME AREA MUST BE REQUESTED BEFORE OVFLOW.
4728 ISAM SPACE REQUEST MUST BEGIN ON A CYLINDER BOUNDARY.
472C DUPLICATE ISAM DATASET ELEMENT.
4730 INVALID DADSM REALLOC PARAMETER LIST.
4734 INVALID JFCB OR PARTIAL DSCB POINTER.
4738 NOT ENOUGH SPACE ON VOLUME FOR DIRECTORY.
473C REALLOC ALLOC=ABS IS NOT SUPPORTED.
4740 INVALID USER-LABEL REQUEST.
4744 INVALID UCB POINTER. MUST BE UCB ADDRESS, NOT A COPY.
4748 DOS VTOC CANNOT BE CONVERTED TO AN OS VTOC.
474C NO SPACE PARAMETER GIVEN FOR NEW DATA SET.
4750 INVALID REQUEST FOR ISAM INDEX.
4754 ISAM MULTIVOLUME INDEX NOT ALLOWED.
4758 INVALID ISAM DATASET ELEMENT.
475C ISAM MULTIVOLUME OVFLOW REQUEST NOT ALLOWED.
4760 ABSTR AND CYL REQUESTS CONFLICT (ISAM).
4764 CYL AND CONTIG REQUEST CONFLICT (ISAM).
4768 INVALID SPACE SUBPARAMETER.
476C PRIMARY SPACE REQUEST MAY NOT BE ZERO FOR ISAM.
4770 ISAM INDEX REQUEST DUPLICATION.
4774 USER LABELS NOT SUPPORTED.
4778 INVALID COMBINATION OF DSSIZE AND MINAU IN REALLOC PARAM.
477C DSSIZE NOT A MULTIPLE OF MINAU.
4780 DIRECTORY SPACE REQUEST IS LARGER THAN PRIMARY SPACE.
4784 SPACE REQUEST MUST BE ABSTR FOR A DOS VOLUME.
4788 INVALID FMT3 DSCB POINTER.
478C INDEX REQUEST MUST PRECEDE PRIME FOR ISAM DATA SET.
4790 INVALID THIRD DD CARD FOR ISAM ALLOCATION.
4794 OVERLAPPING DATA SETS IN VTOC.
4798 OVERLAPPING DOS SPLIT CYLINDER EXTENTS IN THE VTOC.
479C DADSM CREATE TERMINATED BECAUSE OF POSSIBLE VTOC ERRORS.
47A0 ISAM CREATE TERMINATED DUE TO POSSIBLE VTOC ERRORS.
47A4 ALLOCATION TERMINATED BECAUSE OF DOS STACKED PACK FORMAT.
47A8 RACDEF FAILED, DATASET ALREADY DEFINED.
47AC USER NOT AUTHORIZED TO DEFINE DATASET.
47B0 INSTALLATION EXIT REJECTED REQUEST WITH RC=08.
47B4 INSTALLATION EXIT REJECTED REQUEST WITH RC=04.
47B8 RACF DEFINE WITH MODELING SPECIFIED AND MODEL NOT FOUND.
47BC INVALID FMT2 DSCB POINTER.
47C0 REQUESTED DATASET CREATION WAS NOT ALLOWED BY SMS.
47C4 REQUESTED DATASET CREATION WAS NOT POSSIBLE.
47C8 THE PDSE DIRECTORY COULD NOT BE BUILT.
5704 THE CATALOG CANNOT BE OPENED.
5708 CATALOG STRUCTURE INCONSISTENT WITH REQUESTED OPERATION.
5710 THE NECESSARY INDEX STRUCTURE DOES NOT EXIST IN CATALOG.
5714 INSUFFICIENT SPACE IN CATALOG.
5718 IMPROPERLY NAMED GDG OR GDG IS FULL AND THIS IS OLD NAME.
571C I/O ERROR IN THE CATALOG.
6704 THE REQUIRED VOLUME WAS NOT MOUNTED.
6708 THE FORMAT 1 DSCB WAS NOT FOUND IN THE VTOC.
670C I/O ERROR IN VTOC OR INVALID FORMAT 1 DSCB.
6710 AN INVALID WORK AREA POINTER WAS SUPPLIED.
7700 SUBSYSTEM ERROR.
7704 SUBSYSTEM INTERFACE ERROR WHILE PROCESSING DALSSNM.
8700 SCHEDULER JCL FACILITY (SJF) ERROR.
8704 SCHEDULER JCL FACILITY ACCESS FUNCTION ERROR.
8708 MUTUAL EXCLUSIVITY CHECKER ERROR.
9700 SEVERE SMS IDAX ERROR.
9704 SEVERE SMS CATALOG ERROR.
9708 SEVERE SMS VOLREF ERROR.
970C SEVERE SMS VTOC ERROR.
9710 SEVERE SMS DISP ERROR.
9714 SEVERE SMS COPY SWB ERROR.
9728 SYSTEM ERROR WHILE ALLOCATING A DEVICE.

     - - - DYNAMIC ALLOCATION TEXT UNIT CODES - - -
     - - - In information reason code for error codes - - -
     - - - 035C, 0360, 0374, 0378, 037C, 0380, and 0384 - - -
0001 DDNAME
0002 DATASET NAME (DSN=)
0003 MEMBER NAME OR RELATIVE GDG NUMBER
0004 STATUS (OLD, NEW, SHR, ETC)
0005 NORMAL DISPOSITION (KEEP, DELETE, CATLG, ETC)
0006 CONDITIONAL DISPOSITION (KEEP, CATLG, DELETE, ETC
0007 SPECIFY SPACE ALLOCATION IS IN TRACKS
0008 SPECIFY SPACE ALLOCATION IS IN CYLINDERS
0009 SPECIFY AVERAGE DATA BLOCK LENGTH USED FOR SPACE REQUEST
000A PRIMARY SPACE QUANTITY
000B SECONDARY SPACE QUANTITY
000C NUMBER OF PDS DIRECTORY BLOCKS
000D DELETE UNUSED SPACE WHEN CLOSED (RLSE)
000E FORMAT OF ALLOCATED SPACE (ALX, MXIG, CONTIG)
000F WHOLE CYLINDER ALLOCATION (ROUND) REQUEST
0010 VOLUME SERIAL NUMBER
0011 REQUEST PRIVATE VOLUME
0012 VOLUME SEQUENCE NUMBER
0013 VOLUME COUNT - MAX NUMBER OF VOLUMES
0014 VOLUME REFERENCE TO A DSNAME (VOL=REF=)
0015 UNIT NAME (DISK, CART, TAPE, ETC)
0016 UNIT COUNT - NUMBER OF DEVICES TO BE ALLOCATED
0017 PARALLEL MOUNT REQUEST - VOLUMES ON SEPARATE DEVICES
0018 SYSOUT CLASS REQUEST (SYSOUT=)
0019 SYSOUT WRITER PROGRAM NAME
001A SYSOUT FORM NUMBER
001B SYSOUT OUTPUT LIMIT - NUMBER OF RECORDS IN DATASET
001C UNALLOCATION AT CLOSE REQUEST (FREE=CLOSE)
001D NUMBER OF SYSOUT COPIES (COPIES=)
001E LABEL TYPE (NL, SL, BLP, ETC)
001F DATASET SEQUENCE NUMBER ON A MULTI-FILE TAPE VOLUME
0020 PASSWORD PROTECTION REQUEST
0021 INPUT ONLY OR OUTPUT ONLY REQUEST (BDAM AND BSAM ONLY)
0022 EXPIRATION DATE AS YYDDD
0023 RETENTION PERIOD - NUMBER OF DAYS BEFORE EXPIRATION
0024 DUMMY DATASET REQUEST
0025 FORMS CONTROL BUFFER (FCB) IMAGE IDENTIFICATION
0026 FORM ALIGNMENT AND IMAGE VERIFICATION (VERIFY OR ALIGN)
0027 QNAME (FOR TCAM TPROCESS)
0028 REQUEST IF FOR A TIME SHARING TERMINAL
0029 UNIVERSAL CHARACTER SET (UCS) REQUEST
002A FOLD MODE REQUEST
002B CHARACTER SET IMAGE VERIFICATION REQUEST
002C DCB REFERENCE TO A DSNAME (MODEL/PATTERN DSCB REFERENCE)
002D DCB REFERENCE TO A DDNAME (TO BE USED AS A MODEL)
002E BUFFER ALIGNMENT (BFALN)
002F BUFFERING TECHNIQUE (BFTEK)
0030 (MAX) NUMBER BYTES PER BLOCK (BLKSIZE)
0031 NUMBER OF BUFFERS INITIALLY ASSIGNED TO A LINE (BUFIN)
0032 BUFFER LENGTH (BUFL)
0033 MAX NBR BUFFERS ALLOCATED AT ONE TIME TO A LINE (BUFMAX)
0034 NUMBER OF BUFFERS TO BE ASSIGNED (BUFNO)
0035 BUFFER OFFSET (BUFOFF)
0036 NUMBER OF OUTPUT BUFFERS FOR A LINE GROUP (BUFOUT)
0037 NBR BUFFERS TO ALLOCATE IN ADVANCE FOR GET MACRO (BUFRQ)
0038 LENGTH IN BYTES FOR BUFFERS (BUFSZ)
0039 PAPER TAPE CODE
003A RELATIVE PRIORITY OF SEND AND RECEIVE (CPRI)
003B TAPE DENSITY (DEN)
003C DATASET ORGANIZATION (DSORG)
003D ERROR OPTION (EROPT)
003E MAX NBR GAM I/O MACROS TO BE ISSUED BEFORE A WAIT (GNCP)
003F POLLING INTERVAL FOR LINES IN A GROUP (INTVL)
0040 KEY LENGTH IN BYTES (KEYLEN)
0041 SEARCH LIMIT (LIMCT)
0042 LOGICAL RECORD LENGTH (LRECL)
0043 MODE OF OPERATION FOR CARD READ/PUNCH
0044 MAX NBR READ/WRITE MACROS ISSUED BEFORE A CHECK (NCP)
0045 OPTION CODE (OPTCD)
0046 RELATION OF PCIS TO BUFFER ALLOCATION/FREE DURING RECEIVE
0047 RELATION OF PIIS TO BUFFER ALLOCATION/FREE DURING SEND
0048 PRINTER LINE SPACING (PRTSP)
0049 RECORD FORMAT (RECFM)
004A BYTES RESERVED IN 1ST BUFFER FOR DATETIME AND SEQUENCE
004B BYTES RESERVED NON-1ST BUFFER FOR DATETIME AND SEQUENCE
004C SIZE OF INPUT WORK AREA FOR TELECOMM JOBS (SOWA)
004D STACKER BIN TO RECEIVE CARDS (STACK)
004E PERCENT OF NONREUS DISK MESSAGE QUEUE USED BEFORE FLUSH
004F RECORDING TECHNIQUE FOR 7-TRACK TAPES
0050 PASSWORD FOR A PROTECTED DATASET
0051 TCAM NETWORK CONTROL PROGRAM NAME
0052 PERMANENTLY ALLOCATED ATTRIBUTE
0053 CONVERTIBLE ATTRIBUTE
0054 OPEN/CLOSE/EOV TRACE REQUEST (DIAGNS=TRACE)
0055 REQUEST RETURN OF ASSOCIATED DDNAME
0056 REQUEST RETURN OF ASSOCIATED DSNAME
0057 REQUEST RETURN OF DATASET ORGANIZATION
0058 SYSOUT REMOTE WORK STATION DESTINATION NODE NAME
0059 SYSOUT HOLD QUEUE REQUEST
005A 3525 CARD READ/PUNCH DATASET TYPE
005B INPUT TO 3886 CHARACTER READER
005C REQUEST ALLOCATION OF A SUBSYSTEM DATASET
005D REQUEST RETURN OF VOLUME SERIAL NUMBER
005E MSS VOLUME GROUP NAME
005F NAME OF SUBSYSTEM TO PROCESS THE DATASET
0060 SUBSYSTEM PARAMETER STRING
0061 PROTECT WHEN CREATED (DASD) OR WHEN USED (TAPE)
0062 REQUEST ALLOCATION OF A SUBSYSTEM DATASET TO SYSIN
0063 SYSOUT USER ID NAME AT A REMOTE LOCATION DESTINATION
0064 BURST REQUEST FOR 3800 PRINTER
0065 CHARACTER ARRANGEMENT TABLE NAME
0066 COPY GROUP SPECIFICATION
0067 FLASH FORMS OVERLAY NAME
0068 FLASH FORMS OVERLAY COUNT
0069 COPY MODIFICATION MODULE NAME
006A COPY MODULE TABLE REFERENCE
006B RECORD LENGTH FOR AN ISO/ANSI/FIPS TAPE DATASET
006C DEFER MOUNT UNTIL DATASET IS OPENED
006D EXPIRATION DATE (YYYYDDD)
8001 ACCESS SPECIFICATION CODE FOR ISO/ANSI/FIPS TAPE DATASETS
8002 OUTPUT STATEMENT NAME REFERENCE
8003 CNTL STATEMENT NAME REFERENCE
8004 STORAGE CLASS
8005 MANAGEMENT CLASS
8006 DATA CLASS
800B RECORD ORGANIZATION SPECIFICATION FOR VSAM
800C RELATIVE KEY OFFSET IN LOGICAL RECORDS FOR VSAM
800D NAME OF JCL DD STATEMENT TO GET ATTRIBUTES
800E COPY RACF PROFILE NAME
800F NAME OF MODEL DATASET WHOSE ATTRIBUTES ARE TO BE COPIED
8010 ALLOCATION UNIT TO BE USED WHEN DATASET IS ALLOCATED
8012 PDS/PDSE SPECIFICATION
./ ADD NAME=ENQLIST  0101-88061-88061-0955-00062-00064-00000-USER02
                  ENQLIST: DISPLAY ENQUEUE INFORMATION
 READS A COMMAND FROM THE SYSIN DATASET, USES THE GQSCAN MACRO TO
 OBTAIN THE REQUESTED INFORMATION CONCERNING ENQ CONTROL BLOCK CHAINS
 AND PRINTS THE RESULTS TO THE SYSPRINT DATASET. ACCEPTABLE COMMANDS
 ARE:
    (1) DISPLAY ENQ CONFLICT INFORMATION
        EXAMPLE:
        COL  1-72 = ALL BLANK

    (2) TERMINATE PROCESSING (END OF JOB REQUEST)
        EXAMPLE: END
        COL  1-3  = "END", REST OF COMMAND IS BLANK

    (3) DISPLAY ENQ INFO FOR THE JOBNAME SPECIFIED
        EXAMPLE: JOB=GMMCPRW6
        COL  1-4  = "JOB="
        COL  5-12 = JOBNAME (1-8 CHARACTERS), REST OF COMMAND BLANK

    (4) DISPLAY ENQ INFO FOR ALL QNAMES IN USE
        EXAMPLE: QNAMES
        COL  1-6  = "QNAMES"

    (5) DISPLAY ENQ INFO FOR THE Q-NAME SPECIFIED
        EXAMPLE: SYSZVOLS
        COL  1-8  = Q-NAME (1-8 CHARACTERS), REST OF COMMAND BLANK

    (6) DISPLAY ENQ INFO FOR THE RESOURCE SPECIFIED
        EXAMPLE: SYSDSN  .SYS1.LINKLIB
        COL  1-8  = Q-NAME (1-8 CHARACTERS)
        COL   9   = "."
        COL 10-80 = R-NAME FOLLOWED BY BLANKS

    (7) DISPLAY HELP PANEL
        EXAMPLE: HELP
        COL  1-4  = "HELP", REST OF COMMAND BLANK

FILES USED BY THE PROGRAM:

     (1) COMMAND INPUT
               DDNAME=SYSPRINT
               RECFM=FB,LRECL=80 HARD-CODED
     (2) LISTING OUTPUT
               DDNAME=SYSIN
               RECFM=FB,LRECL=80 HARD-CODED

EXAMPLE JCL:

//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//ENQLIST  EXEC PGM=ENQLIST
//STEPLIB  DD   DSN=SYS.PROD.LOAD,DISP=SHR
//SYSPRINT DD   SYSOUT=(*,,FMT),DCB=BLKSIZE=80
//SYSUDUMP DD   SYSOUT=(*,,FMT),DCB=BLKSIZE=80
//SYSIN    DD   *,DCB=BLKSIZE=80
QNAMES
JOB=T1804
SYSDSN
SYSDSN  .SYS1.ISRCLIB

HELP
END
./ ADD NAME=EXCHANGE 0100-02092-02092-1415-00084-00084-00000-BC0THOR
             ***** EXCHANGE: DISK FILE INTERCHANGE UTILITY *****

         Exchanges (interchanges) two datasets on the same volume so that the fi
rst DSNAME will
         point to the second dataset, and the second DSNAME will point to the fi
rst dataset. Both
         datasets must exist in the VTOC and neither can be  VSAM. This program
does not make use
         of standard catalog and device allocation or serialization and so can b
e used to rename
         datasets even when they are actively in use by other jobs. To minimize
risk, the
         datasets are interchanged by rewriting the format 1 DSCB's for the two
files so that the
         data records are interchanged while leaving the count and key portions
intact. In this
         way, modifications to the VTOCIX are avoided, and no new records need b
e created in the
         VTOC.

         A VOLUME control card must precede the first EXCHANGE control card. It
specifies the
         volume to be used for the exchanges that follow until the next VOLUME c
ontrol card is
         found. The VOLUME card contains the word VOLUME in columns 1-6, is blan
k in column 7,
         and has the volume serial in columns 8-13 left justified with trailing
blanks. A two-
         card set is required for each dataset pair to be exchanged. The first c
ard contains the
         word EXCHANGE in columns 1-8, a blank in column 9, the word DSN= in col
umns 10-13, and
         the dataset name in columns 14-57 left justified with trailing spaces.
The card
         immediately following the EXCHANGE card is blank in columns 1-9, has th
e word DSN= in
         columns 10-13, and the name of the second dataset in columns 14-57. A c
ard with an
         asterisk in column 1 is treated as a comment.

         When any error is encountered the program stops processing, writes log
records, and
         abends with dump specified. In this case, the log file may be criticall
y important. It
         should be studied in detail to determine whether any VTOC damage must b
e repaired. The
         VTOC repair can be done using IMASPZAP or CHRDUMP using the information
 in the log file.

         A log file is written that contains all messages written to the SYSPRIN
T file as well as
         the content of all VTOC records read and written. The log file can be u
sed to aid in
         VTOC recovery in case of a catastrophic error during processing, as it
contains VTOC
         details. Note that the VTOC records are in hex, so the file must be vie
wed in EDIT or
         BROWSE in hex mode.

         Following is example JCL which interchanges three system datasets on th
e SYSTST volume.
         In each case, a SYS1 and a SYS5 dataset are interchanged.

         //SCRATCH  EXEC PGM=IDCAMS
         //SYSPRINT DD SYSOUT=*
         //SYSIN    DD *
          DELETE USER02.TST.EXCHANGE.SYSLOG NONVSAM
         //*
         //EXCHANGE EXEC  PGM=EXCHANGE
         //STEPLIB  DD    DSN=SYS1.SYSA.HNET.LINKLIB,DISP=SHR
         //SYSUDUMP DD    SYSOUT=*
         //SYSPRINT DD    SYSOUT=*
         //SYSLOG   DD    DSN=USER02.TST.EXCHANGE.SYSLOG,DISP=(,CATLG),
         //         UNIT=DISK,SPACE=(TRK,(10,2),RLSE),
         //         RECFM=FB,LRECL=133,BLKSIZE=0
         //SYSIN    DD    *
         * INSTALL MAINTENANCE FOR SYSTEM B
         VOLUME SYSTST
         EXCHANGE DSN=SYS1.LPALIB
                  DSN=SYS5.LPALIB
         EXCHANGE DSN=SYS1.NUCLEUS
                  DSN=SYS5.NUCLEUS
         EXCHANGE DSN=SYS1.MODGEN
                  DSN=SYS5.MODGEN
./ ADD NAME=EXCPIO   0101-92351-92357-1710-00156-00122-00000-USER02
                ***** EXCPIO: EXCP SUBROUTINE *****

EXCPIO performs EXCP I/O operations to read and rewrite disk records
without use of standard access methods. To use this subroutine, the
caller must define a parameter area (see EXCPARMS, below), and an
error message storage area (see ERRMSGS, below). Before calling
EXCPIO, the caller must set up fields within EXCPARMS to identify the
request and its specifics. The functions performed by EXCPIO include
allocation of a volume or dataset with or without use of the catalog,
reading records by CCHHR disk address or by keys, and rewriting
records. A detailed description of each function, its parameters, and
the data returned follows:
COMMAND=N: Read next block on disk. First, the UCBADDR and CURRXTNT
           fields are moved to the DEB, which allocates the volume and
           sets the extent range. Next, the THISCHR field is set up as
           the search address, and an EXCP is used to read the COUNT-
           KEY-DATA of the record AFTER that specified by THISCHR. The
           entire count-key-data content is made available to the
           caller by placing its address in the CKDADDR field when the
           read is successful. Also, the THISCHR field is updated to
           contain the CCHHR address of this record so that another call
           without changes in EXCPARMS would cause the next record to be
           read. Before issuing the "N" function, you must have a valid
           DASD UCB address in the UCBADDR field, the disk extent range
           in the CURRXTNT field, and the CCHHR address of the record
           PRIOR to the one you want to read in the THISCHR field. To
           read the first record on a track, set THISCHR+4 to binary
           zero.
COMMAND=V: Allocate a disk volume. The caller must put the volume serial
           of the desired disk volume in the VOLSER field before calling
           EXCPIO. The volume is "allocated" by EXCPIO by first locating
           the UCB for the volume using the UCBSCAN service, then moves
           the address to the UCBADDR field. The UCBVTOC field of the
           UCB is used to develop the CCHHR address of the beginning of
           the VTOC, which is then moved to the CURRXTNT and THISCHR
           fields of the EXCPARMS. THISCHR+4 is set to zero so the first
           record on the track will be read. The UCBADDR and CURRXTNT
           fields are then moved to the DEB and an EXCP is issued to
           read the Format 4 DSCB (VTOC descriptor), which is moved to
           a save area. The address of this area is placed in the
           EXCPARMS field FMT4ADDR. Next, the CURRXTNT field is set
           to the correct VTOC extents using the DS4VTOCE field in the
           Format 4 DSCB. Finally, THISCHR is set to the start address
           of the VTOC, record 0. If an "N" function is requested just
           after a "V" request, the Format 4 DSCB should be read.
COMMAND=D: Allocates a dataset on the currently allocated disk volume.
           A valid UCB address must be in the UCBADDR field (normally
           from an earlier "V" function call), and the caller places
           the fully qualified dataset name in the DSNAME field of the
           EXCPARMS left justified with trailing blanks. First the
           volume is reallocated using the "V" function, but bypassing
           the UCBSCAN process. Next, the format 1 DSCB is read from
           the VTOC and is moved to a save area whose address is put
           into the FMT1ADDR field. If a Format 3 DSCB pointer is in
           the Format 1 it is also read and moved to a save area whose
           address is put in the FMT3ADDR field. The CURRXTNT field is
           set to the beginning extent of the file, and the remaining
           extents are set up after it in EXCPARMS. The XTNTS field is
           set to the number of extents. THISCHR is set to record zero
           for the first track in the file. If function "N" is requested
           next, the first record in the file should be read (for a PDS,
           this will be the first directory block).
COMMAND=C: This function allocates a dataset via the catalog, and has no
           prerequisite requirements. First, the catalog entry for the
           file is read using a LOCATE macro. Next, the first (or only)
           volume serial is allocated using the allocate volume routine.
           if successful, the dataset is allocated on the volume using
           the dataset allocation routine. on successful return there
           will be valid addresses in the fmt4addr, fmt1addr, and in
           the fmt3addr if the dataset has more than 3 extents. the
           xtnts field will contain the number of extents in the file
           and the currxtnt and extadnl fields will contain all the
           extents in the file. the thischr field will contain the
           cchhr address for record 0 of the first track in the file.
           An "N" command following the "C" command should return the
           count-key-data for the first data record in the extents for
           the file.
COMMAND=R: This will rewrite the record at the cchhr address given in
           the THISCHR field. The original count record for the record
           to be rewritten must be at the address in the CKDADDR field.
           The key (if any) must immediately follow the count record
           (at the address in CKDADDR +8). The key must be present if
           the record has a key, as it will be rewritten whether or not
           it was changed. If there is no key, the data record to be
           rewritten must immediately follow the key, otherwise it must
           follow the count record. The extents will be set to those in
           the CURRXTNT field, and the THISCHR field will be used to
           locate the record to be rewritten. The volume used will be
           that last used by a former command. An "N" command following
           this should read the record following the one rewritten.
COMMAND=S: This is used to search for the next record by key. The
           key to be used for the search must be left justified in
           the SRCHKEY field, the KEYLENG field must contain the length
           of the key, and the SRCHTYPE must contain EQ for an equal
           search or GE for an equal-or-high search. The same volume
           will be used as last allocated by an earlier command, the
           CURRXTNT will be used for the extents, and THISCHR provides
           the starting point for the search. When successful, the
           address in the CKDADDR field points to the count-key-data
           for the record read.

***********************************************************************
*        EXCPIO PARAMETER AREA (DOUBLEWORD BOUNDARY ALIGNED)          *
***********************************************************************
EXCPARMS DS    0D                      CALLER'S PARAMETER AREA
COMMAND  DS    CL1                     COMMAND (REQUEST) CODE
READNEXT EQU   C'N'                      READ NEXT BLOCK REQUEST
VOLALLOC EQU   C'V'                      ALLOCATE VOLUME REQUEST
DSNALLOC EQU   C'D'                      ALLOCATE DSNAME ON VOLUME
CATALLOC EQU   C'C'                      ALLOCATE DSNAME VIA CATALOG
REWRTLST EQU   C'R'                      REWRITE LAST RECORD READ
SEARCH   EQU   C'S'                      SEARCH USING SRCHKEY
KEYLENG  DS    XL1                     KEY LENGTH IF COMMAND=S
SRCHTYPE DS    CL2                     KEY SEARCH TYPE: EQ OR GE
RETCODE  DS    CL2                     RETURN CODE: BLANK=O.K.,
*                                        BLANK = SUCCESSFUL,
*                                        C1=DATASET NOT IN CATALOG
*                                        D1=DYNALLOC FAIL FOR WORK
*                                        D2=DEB<->DCB PTR ERROR
*                                        E1=END OF ALLOCATED EXTENT
*                                        F1=EOF RECORD READ
*                                        I1=HARD I/O ERROR
*                                        I2=I/O ERROR ON REWRITE
*                                        O1=OPEN FAILED FOR WORK FILE
*                                        O2=EXCP FILE NOT OPEN
*                                        R1=INVALID REQUEST CODE
*                                        R2=VOLUME REQUESTED NOT AVAIL
*                                        R3=UNSUPPORTED DEVICE
*                                        U1=INVALID UCB ADDRESS
*                                        V1=INVALID FORMAT4 DSCB
*                                        V2=DSNAME NOT IN VTOC
*                                        V3=FORMAT3 DSCB I/O ERROR
*                                        V4=DATASET HAS NO EXTENTS
FMT4ADDR DS    A                       ADDRESS OF FORMAT 4 DSCB
FMT1ADDR DS    A                       ADDRESS OF FORMAT 1 DSCB
FMT3ADDR DS    A                       ADDRESS OF FORMAT 3 DSCB
CKDADDR  DS    A                       ADDRESS OF RECORD READ
ERRNLINE DS    H                       NBR LINES OF ERROR MESSAGE
THISCHR  DS    XL5                     CCHHR ADDRESS FOR READ, WRITE
DSNAME   DS    CL44                    DATASET NAME
UCBADDR  DS    AL3                     UCB ADDRESS
VOLSER   DS    CL6                     VOLUME SERIAL NUMBER
XTNTS    DS    XL1                     NUMBER OF EXTENTS REMAINING
CURRXTNT DS    0XL10                   CURRENT EXTENT
CURRBIN  DS    XL2                       BIN NUMBER (ZEROS)
CURRBGNC DS    XL2                       BEGINNING CYLINDER
CURRBGNH DS    XL2                       BEGINNING HEAD (TRACK)
CURRENDC DS    XL2                       ENDING CYLINDER
CURRENDH DS    XL2                       ENDING HEAD (TRACK)
EXTADNL  DS    15XL10                  15 ADDITIONAL EXTENTS BBCCHHCCHH
SRCHKEY  DS    CL256                   KEY FOR SEARCH
EXCPEND  EQU   *                       END OF PARAMETER AREA
***********************************************************************
*        ERROR MESSAGES RETURNED BY THE EXCPIO SUBROUTINE             *
***********************************************************************
ERRMSGS  DS    8CL80                   ERROR MESSAGE LINES FROM EXCPIO
./ ADD NAME=FINDMAC  0100-88061-88061-0956-00029-00029-00000-USER02
*               *** FINDMAC INSTRUCTIONS ***

* THIS PROGRAM SCANS AN ASSEMBLER SOURCE PROGRAM FOR NON-IBM MACROS,
* AND EXPLICIT SVC USAGE. THE INPUT CARD IS SCANNED TO LOCATE THE
* OPERATION CODE MNEMONIC. IF THE MNEMONIC FOUND IS 'SVC', A FURTHER
* SCAN IS MADE TO EXTRACT THE SVC OPERAND. IF NOT SVC, AN OP-CODE
* TABLE LOOP-UP IS PERFORMED TO SEE IF THE MNEMONIC IS AN INSTRUCTION
* OR IBM SUPPLIED MACRO. WHEN THE MNEMONIC IS NOT FOUND IN THE TABLE,
* A USER MACRO IS ASSUMED. AN OUTPUT RECORD IS CREATED FOR EACH
* USER MACRO, CONTAINING MACRO NAME AND SOURCE CARD NUMBER. A RECORD
* IS ALSO CREATED FOR EACH EXPLICIT SVC FOUND, GIVING THE SVC OPERAND
* AND SOURCE CARD NUMBER. SOURCE CARD NUMBER IS TAKEN FROM COLUMNS
* 73-80.
*
* PURPOSE OF THE PROGRAM IS TO LOCATE THE SPECIAL MACROS AND SVC'S
* WHICH WILL BE NECESSARY TO SUCCESSFULLY ASSEMBLE THE PROGRAM. THIS
* IS NECESSARY WHEN PREPARING TO SEND A PROGRAM TO ANOTHER SHOP, OR
* WHEN OBTAINING SOURCE MATERIAL FROM THE SYSTEM OPTIONAL MATERIAL
* TAPES TO ASSEMBLE A SYSTEM COMPONENT.
*
* JCL TO EXECUTE THE PROGRAM IS:
*
//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//FINDMAC EXEC PGM=FINDMAC
//STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR
//INPUT1 DD DSN=SOURCE.ASM(PGMNAME),DISP=SHR
//PRINT1 DD SYSOUT=A,DCB=BLKSIZE=80
./ ADD NAME=FINDSUBR 0100-02092-02092-1415-00046-00046-00000-BC0THOR
*       *** CROSS-REFERENCE SUBROUTINES TO CALLING PROGRAMS ***
*
*      FINDSUBR READS A LOAD MODULE LIBRARY, EXTRACTING SUBROUTINE
* REFERENCES FROM THE CESD RECORDS IN EACH LOAD MODULE. AN OUTPUT
* FILE CONTAINING ONE RECORD FOR EACH SUBROUTINE FOR EACH CALLING
* PROGRAM IS CREATED. THIS FILE IS SORTED IN SUBROUTINE NAME ORDER
* AND PRINTED BY PROGRAM PRINTSUB.
*
*      JCL REQUIREMENTS:
*  FINDSUBR:
*      EXEC CARD FOR PGM=FINDSUBR
*      OUTPUT1 DD CARD FOR OUTPUT FILE. RECFM=FB,LRECL=16 ARE HARD-CODED
*                 BLKSIZE MUST BE PROVIDED ON THE DD CARD.
*      INPUT1 DD CARD FOR INPUT FILE. INPUT MUST BE A LOAD MODULE
*                 LIBRARY CREATED BY THE LINKAGE EDITOR. RECFM=U,
*                 BLKSIZE=13030 ARE HARD-CODED.
*  PRINTSUB:
*      PRINT1 DD CARD FOR PRINTED LISTING. RECFM=FA,LRECL=133,
*                 BLKSIZE=133 ARE HARD-CODED.
*      INPUT1 DD CARD FOR THE SORTED INPUT FILE FROM FINDSUBR. RECFM=FB,
*                 LRECL=16 ARE HARD-CODED.
*
*     JCL EXAMPLE:
*
*     //XREFSUBR JOB (ACCTNG),PGMRNAME,CLASS= .....
*     // EXEC PGM=FINDSUBR
*     //INPUT1 DD DSN=TEST.LOAD,DISP=SHR
*     //OUTPUT1 DD DSN=&&XREF,DISP=(,PASS),UNIT=DISK,DCB=BLKSIZE=(6400),
*     // SPACE=(TRK,(5,1),RLSE)
*     //*
*     //SORTXREF EXEC PGM=SORT
*     //SYSOUT DD SYSOUT=A
*     //SORTIN DD DSN=&&XREF,DISP=(OLD,DELETE,DELETE)
*     //SORTOUT DD DSN=&&SORTED,DISP=(,PASS),UNIT=DISK,DCB=BLKSIZE=6400,
*     // SPACE=(TRK,(5,1),RLSE)
*     //SORTWK01 DD UNIT=DISK,SPACE=(TRK,3)
*     //SORTWK02 DD UNIT=DISK,SPACE=(TRK,3)
*     //SORTWK03 DD UNIT=DISK,SPACE=(TRK,3)
*     //SYSIN DD *
*      SORT FIELDS=(8,8,CH,A)
*     /*
*     //*
*     //PRTXREF EXEC PGM=PRINTSUB
*     //PRINT1 DD SYSOUT=A
*     //INPUT1 DD DSN=&&SORTED,DISP=(OLD,DELETE,DELETE)
*
./ ADD NAME=GENLDAT1 0102-90333-91226-1313-00107-00107-00000-USER02
                      GENLDAT2 SUBROUTINE
        (COBOL description. See member GENLDAT2 for Assembler)

    GENLDAT2 is a rewrite of the older GENLDATE subroutine which only
  handled dates between Jan 1, 1900 and Dec 31, 1999. In order to
  handle multiple centuries, the year fields have been expanded from
  two bytes to four bytes in all cases. In addition, the gregorian
  date format ymd is now supported as well as the mdy format.

    This subroutine provides a table of information on the incoming
  date, which may be supplied in julian or gregorian. Information
  returned includes day-of-week, holiday indication, and formatted
  fields containing the date with literal month, julian date with slash,
  and gregorian date with slashes. The subroutine is valid for all
  dates from Jan 1, 1900 THRU Dec 31,1999.

  A single parameter is supplied. The format is shown here as a copy
  of TEST.FILEDESC(DATEPRM2), which can be used to generate the area:

000020******************************************************************
000030*                   D A T E P A R M                              *
000070*          FOR USE WITH THE DATEPRM2 SUBROUTINE                  *
000080******************************************************************
000200     05  DATE-TYPE                 PIC X(01).
000300         88  JULIAN-SUPPLIED                 VALUE 'J'.
000310         88  GREGORIAN-MDY-SUPPLIED          VALUE 'G'.
000320         88  GREGORIAN-YMD-SUPPLIED          VALUE 'Y'.
000400     05  DATE-ERROR                PIC X(01).
000500         88  NO-DATE-ERROR                   VALUE SPACE.
000510         88  YES-DATE-ERROR                  VALUE 'E'.
000600     05  DAY-OF-WEEK               PIC X(01).
000700         88  MONDAY                          VALUE '1'.
000701         88  TUESDAY                         VALUE '2'.
000702         88  WEDNESDAY                       VALUE '3'.
000703         88  THURSDAY                        VALUE '4'.
000704         88  FRIDAY                          VALUE '5'.
000705         88  SATURDAY                        VALUE '6'.
000706         88  SUNDAY                          VALUE '7'.
000800     05  HOLIDAY-INDICATOR         PIC X(01).
000801         88  NOT-A-HOLIDAY                   VALUE ' '.
000802         88  NEW-YEARS-DAY                   VALUE '1'.
000804         88  GOOD-FRIDAY                     VALUE '3'.
000805         88  MEMORIAL-DAY                    VALUE '4'.
000806         88  INDEPENDENCE-DAY                VALUE '5'.
000807         88  LABOR-DAY                       VALUE '6'.
000808         88  THANKSGIVING-DAY                VALUE '7'.
000809         88  THANKSGIVING-FRIDAY             VALUE '8'.
000810         88  CHRISTMAS-DAY                   VALUE '9'.
000811     05  YEAR-TYPE                 PIC X(01).
000812         88  NOT-LEAP-YEAR                   VALUE '0'.
000813         88  LEAP-YEAR                       VALUE '1'.
000814     05  JULIAN-DATE               PIC 9(07) COMP-3.
000815     05  GREGORIAN-MDY-DATE        PIC 9(08).
000816     05  GREGORIAN-YMD-DATE        PIC 9(08).
000817     05  LITERAL-DATE              PIC X(18).
000818     05  JULIAN-SLASH              PIC X(08).
000819     05  GREGORIAN-SLASH           PIC X(10).
000820     05  DAY-LITERAL               PIC X(09).
000830     05  MONTH-LITERAL             PIC X(09).


   Format of the following fields are:
        JULIAN-DATE: packed decimal, yyyyddd
        GREGORIAN-MDY-DATE: unsigned, unpacked decimal, mmddyyyy
        GREGORIAN-YMD-DATE: unsigned, unpacked decimal, yyyymmdd
        LITERAL-DATE: literal month with commas and formatting,
                      examples are: MAY 5, 1973
                                    SEPTEMBER 17, 2019
        JULIAN-SLASH: julian date with a slash, yyyy/ddd.
        GREGORIAN-SLASH: gregorian date with slashes, mm/dd/yyyy.
        DAY-LITERAL: literal for day of week, example MONDAY.
        MONTH-LITERAL: literal for month, example SEPTEMBER.

   Holidays conform to the Blue Cross defined holidays. When a
   holiday falls on Saturday, the preceding Friday is observed,
   and when the holiday falls on Sunday, the following Monday
   is observed.



                       SUBROUTINE USE:

  The user sets the DATE-TYPE field to 'J' and moves the julian
  date to the julian-date field, or sets the DATE-TYPE field to
  'G' and moves the gregorian date in mmddyyyy format to the
  GREGORIAN-MDY-DATE field, or sets the DATE-TYPE field to 'Y'
  and moves the gregorian date in yyyymmdd format to the
  GREGORIAN-YMD-DATE field before calling GENLDAT2.

  On return, the DATE-ERROR field must be checked for error. If
  there was no error, all fields contain valid data.



            MOVE 'J' TO DATE-TYPE.
            MOVE SOME-DATE-FIELD TO JULIAN-DATE.
            CALL 'GENLDAT2' USING DATEPARM.
            IF NO-DATE-ERROR NEXT SENTENCE, ELSE
               PERFORM ERROR-DATE-ROUTINE
            .
            .
            .

   Use with gregorian date supplied is identical, except that the
   DATE-TYPE field would be set to 'G' or 'Y' and the date would be
   supplied in the GREGORIAN-MDY-DATE or GREGORIAN-YMD-DATE field
   respectively.
./ ADD NAME=GENLDAT2 0107-90333-98236-1125-00090-00087-00000-BC0THOR
                      GENLDAT2 SUBROUTINE
       (Assembler description. See member GENLDAT1 for COBOL)


    GENLDAT2 is a rewrite of the older GENLDATE subroutine which only
  handled dates between Jan 1, 1900 and Dec 31, 1999. In order to
  handle multiple centuries, the year fields have been expanded from
  two bytes to four bytes in all cases. In addition, the gregorian
  date format ymd is now supported as well as the mdy format.

    This subroutine provides a table of information on the incoming
  date, which may be supplied in julian or gregorian. Information
  returned includes day-of-week, holiday indication, and formatted
  fields containing the date with literal month, julian date with slash,
  and gregorian date with slashes. The subroutine is valid for all
  dates from Jan 1, 1900 THRU Dec 31,1999.

  A single parameter is supplied, formatted as follows:



PARMFLD  DS    0CL79        ***** PARAMETER AREA DESCRIPTION*****
DATYP    DS    CL1           .DATE TYPE SUPPLIED: J=JULIAN,
                              G=GREGORIAN MDY, Y=GREGORIAN YMD
DATERR   DS    CL1           .ERROR INDICATOR:  BLANK=SUCCESSFUL
                              PROCESSING. E=ERROR IN DATA SUPPLIED
DAYWK    DS    CL1           .DAY OF WEEK INDICATOR: 1=MONDAY,
                              2=TUESDAY, 3=WEDNESDAY, 4=THURSDAY,
                              5=FRIDAY, 6=SATURDAY, 7=SUNDAY
HOLIDAY  DS    CL1           .HOLIDAY INDICATOR: BLANK=NOT A
                              HOLIDAY, 1=NEW YEAR'S DAY,
                              2=(NOT USED), 3=GOOD FRIDAY
                              4=MEMORIAL DAY, 5=INDEPENDENCE DAY,
                              6=LABOR DAY, 7=THANKSGIVING DAY,
                              8=FRIDAY  AFTER THANKSGIVING,
                              9=CHRISTMAS DAY
YEARTYP  DS    CL1           .0=NOT LEAP YEAR, 1=LEAP YEAR
JULDATE  DS    PL4           .JULIAN DATE. CONTAINS AN UNSIGNED,
                              PACKED DECIMAL DATE OF THE FORM
                              FORM YYYYDDDF, IF DATYP=J. IT WILL
                              CONTAIN THE CORRECT JULIAN DATE ON
                              SUCCESSFUL RETURN.
GREGMDY  DS    CL8           .GREGORIAN DATE. CONTAINS AN UNSIGNED,
                              ZONED DECIMAL DATE OF THE FORM
                              MMDDYYYY, IF DATYP=G. ON SUCCESSFUL
                              RETURN THIS FIELD WILL CONTAIN THE
                              CORRECT GREGORIAN DATE IN THIS FORMAT.
GREGYMD  DS    CL8           .GREGORIAN DATE. CONTAINS AN UNSIGNED,
                              ZONED DECIMAL DATE OF THE FORM
                              YYYYMMDD, IF DATYP=Y. ON SUCCESSFUL
                              RETURN THIS FIELD WILL CONTAIN THE
                              CORRECT GREGORIAN DATE IN THIS FORMAT.
LITDATE  DS    CL18          .A LITERAL DATE, LEFT JUSTIFIED IN AN
                              IN AN 18-BYTE FIELD. EXAMPLES ARE:
                                 JANUARY 16, 1979
                                 MAY 9, 2002
JULSLASH DS    CL8           .JULIAN DATE WITH SLASH: YYYY/DDD
GRGSLASH DS    CL10          .GREGORIAN DATE WITH SLASHES:
                              MM/DD/YYYY
DAYLIT   DS    CL9           .LITERAL DAY OF WEEK
MONTHLIT DS    CL9           .LITERAL MONTH



     Subroutine use: the parameter field may be generated by the program
  by using the macro DATEPRM2, which will copy the area description
  above. The user sets the DATYP field to 'J' and moves the julian
  date to the JULDATE field, or sets the DATYP field to 'G' and moves
  the gregorian date to the GREGMDY field in mmddyyyy format, or sets
  the DATYP field to 'Y' and moves the gregorian date to the GREGYMD
  field in yyyymmdd format before calling GENLDAT2.
    On return, the DATERR field must be checked for error. if no error,
  all fields contain valid data.

                    CALL EXAMPLE

         MVI   DATYP,C'J'          SHOW JULIAN DATE SENT
         ZAP   JULDATE,JULIAN      COPY DATE TO PARM FIELD
         CALL  GENLDAT2,(DATEFLD)  CALL DATE SUBROUTINE
         CLI   DATERR,C'E'         ANY ERROR?
         BE    ERRORDT             YES
         .
         .
         .
  DATEFLD DATEPRM2

   Use with gregorian date supplied is identical, except that DATYP
   would be set to 'G', and the gregorian date would be sent in the
   GREGMDY field, or DATYP would be set to 'Y' and the gregorian
   date would be sent in YYYYMMDD form in the GREGYMD field.
./ ADD NAME=GETDATE2 0101-93301-93301-1014-00050-00013-00000-USER02
The GETDATE2 subroutine reads the date record which was previously
written in a one-record file by the LOADATE program. LOADATE edits the
date for validity: month must be 01-12, day must be 01-31 with the
upper limit depending on the month and year, and year must be numeric.
The date is returned to the caller in a format specified by the caller.

Programs calling GETDATE2 pass a two-address parameter list where the
first parameter is a one-byte field containing a format indicator and
the second parameter is the area which will contain the date on return
from GETDATE2. The size and format of the second parameter is determined
by the format indicator:

   FORMAT    SIZE    DESCRIPTION OF RETURNED DATE
     S         8     Month, slash, day, slash, year. Example: 09/25/93
     A        18     Literal month, numeric day, century 19, numeric
                     year. Example: September 25, 1993
     Y         6     Numeric year, month, day. Example: 930925
   default     6     Numeric month, day, year. Example: 092593

JCL Requirements: a DD statement with DDNAME DATE2 must be included in
the JCL and identify a date file created by the LOADATE program.

Programming requirements. Caller must define the parameters for GETDATE2
in WORKING-STORAGE and include a CALL in the PROCEDURE DIVISION. Length
and format of the date return area vary with the format requested.

WORKING-STORAGE SECTION.
01  GETDATE2-PARAMETER-FIELDS.
    05  GETDATE2-S-RETURN             PIC X(18).
    05  GETDATE2-A-RETURN             PIC X(18).
    05  GETDATE2-Y-RETURN             PIC X(18).
    05  GETDATE2-D-RETURN             PIC X(18).
    05  GETDATE2-FORMAT               PIC X.

PROCEDURE DIVISION.
    MOVE 'Y' TO GETDATE2-FORMAT.
    CALL 'GETDATE2' USING GETDATE2-Y-RETURN,
                          GETDATE2-FORMAT.

    MOVE 'A' TO GETDATE2-FORMAT.
    CALL 'GETDATE2' USING GETDATE2-A-RETURN,
                          GETDATE2-FORMAT.

    MOVE 'S' TO GETDATE2-FORMAT.
    CALL 'GETDATE2' USING GETDATE2-S-RETURN,
                          GETDATE2-FORMAT.

    MOVE 'D' TO GETDATE2-FORMAT.
    CALL 'GETDATE2' USING GETDATE2-D-RETURN,
                          GETDATE2-FORMAT.
./ ADD NAME=GETGDG   0100-90271-90271-0831-00027-00027-00000-USER02
     GETGDG: SUBROUTINE TO GET GENERATION NUMBER FOR A GDG

  READS CATALOG INFORMATION FOR THE (N) VERSION OF A GDG AND RETURNS
  THE GENERATION NUMBER TO THE CALLER. USES THE LOCATE AND CAMLST
  MACROS TO OBTAIN CATALOG DATA. (SEE SC26-4555, MANAGING CATALOGS,
  PAGES 232-238).

  CALLER PASSES A 44 BYTE AREA CONTAINING THE DATASET NAME LEFT
  JUSTIFIED AND PADDED TO THE RIGHT WITH BLANKS. THE DATASET NAME
  SHOULD END IN THE PARENTHESIZED GENERATION NUMBER DESIRED, FOR
  EXAMPLE: NTM.NETMAN.R410.TABLE(0). THE SECOND PARAMETER PASSED IS A
  FOUR-BYTE FIELD WHICH WILL CONTAIN THE CURRENT GENERATION NUMBER IN
  ZONED DECIMAL IF THE CATALOG SEARCH WAS SUCCESSFUL, OTHERWISE IT
  WILL CONTAIN HEX FF'S (HIGH VALUES) TO INDICATE FAILURE.

              COBOL CALLING EXAMPLE:
000900 WORKING-STORAGE SECTION.
001110
001200 01  GETGDG-PARAMETERS.
001300     05 GDG-DSNAME PIC X(44) VALUE 'GDG.DATASET.NAME(0)'.
001400     05 GDG-GENNO  PIC 9(4).
001900
002000 PROCEDURE DIVISION.
002100
002300     CALL 'GETGDG' USING GDG-DSNAME, GDG-GENNO.
002310     IF GDG-GENNO = HIGH-VALUES,
002320         PERFORM GDG-GENERATION-NOT-FOUND-ROUTINE.
./ ADD NAME=ILBCHECK 0102-95047-95047-1100-00073-00077-00000-BC0THOR
             ***** ILBCHECK - VALIDATE COBOL ILBO MODULES *****

 Purpose:    To aid programmers in identifying potential mixtures of
             old and new COBOL ILB..... modules, which will result
             in execution time abends including S0C1, S0C2, S0C4,
             and S0C6.

 Background: Back in 1968, when the VS COBOL compiler was written,
             31-bit addressing was unknown, and the COBOL library
             subroutines were limited to 24-bit RMODE and AMODE.

             Over the years, a number of sub-programs or subroutines
             were written in COBOL. These should have been linkedited
             with NCAL so that any required modules would be included
             when the sub-program was linkedited into an executable
             run unit. However, some of these were put into production
             with the CALL option of LINKEDIT so that they contained
             any ILB..... COBOL library subroutines referenced by the
             sub-program. This set up the current problem.

             When IBM provided the COBOL II compiler, it guaranteed
             compatibility between VS COBOL and COBOL II modules so
             long as all ILB..... routines were obtained from the
             SYS1.COB2LIB library supplied with COBOL II. This library
             contains all the new COBOL II library subroutines (IGZ
             modules) as well as all the VS COBOL library subroutines
             (ILB modules). The ILB modules in SYS1.COB2LIB are
             functionally identical to the original 1968 VS COBOL
             modules, but are modified to provide compatibility with
             COBOL II. None of the SYS1.COB2LIB modules are compatible
             with the original VS COBOL ILB modules, however. When
             a mixture of original ILB modules and new ILB and/or IGZ
             modules occurs in a run unit, various S0C1, S0C2, S0C4,
             and S0C6 abends may occur. These result from "wild"
             branches, and normally are difficult or impossible to
             diagnose from a dump.

  Method:    ILBCHECK reads the SYSIN file for a record containing the
             name of the member to be analyzed in positions 1-8. This
             member is read from the SYSLIB file and each CSECT whose
             name begins with ILB is checked against a hard-coded
             table. The table contains the names of all known ILB
             routines, the SYS1.COB2LIB length, and the old VS COBOL
             release 2.3 length. If the member name is not found in
             the table or neither length matches, an "unidentifiable"
             message is written. This can occur if the ILB module
             came from the VS COBOL release 2.4 library, and may
             occur in the future after maintenance is applied to the
             SYS1.COB2LIB library. When a mixture of COBOL II and
             VS COBOL modules is found, a "danger" message is written.

  Solution:  When a run unit is found to contain a mixture of old and
             new ILB modules, run ILBCHECK against each of the modules
             which were included in the original linkedit until you
             find the one(s) containing old VS COBOL subroutines. To
             cure the problem, subroutines containing old VS COBOL
             library subroutines must be recompiled and linkedited
             with the NCAL linkedit option. After this, the main run
             unit can be safely relinkedited and exectued.

  Execution: Following JCL is an example of an ILBCHECK run to analyze
             program ACX000 in library EMVSP.OUTPUT.LOADLIB:

//BC0THORX JOB (0000000-999CCEX,,HNEX01-XR-XXXX),RTHORNTON,CLASS=A,
//   NOTIFY=BC0THOR,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CHIP46K,DEFAULT=YES,JESDS=ALL
//ILBCHECK EXEC  PGM=ILBCHECK
//STEPLIB  DD    DSN=BC0THOR.LOAD.LOAD,DISP=SHR
//SYSUDUMP DD    SYSOUT=*
//SYSPRINT DD    SYSOUT=*,BLKSIZE=0
//SYSLIB   DD    DSN=EMVSP.OUTPUT.LOADLIB,DISP=SHR
//SYSIN    DD    *
ACX000
./ ADD NAME=IPCS     0100-98252-98252-1019-00235-00235-00000-BC0THOR
                             ***** IPCS *****

         1. IPCS PRELIMINARY STEPS:
            A. You must have a special VSAM dataset allocated for
               use by IPCS before you can invoke IPCS. If you do
               not have a TST.IPCSDDIR dataset allocated:
               1. To make your IPCS VSAM dataset enter TSO
                  MAKEIPCS on the command line of a screen while
                  in the TSO ISPF WorkBench (WB). This will
                  submit a DELETE-DEFINE job to create the VSAM
                  dataset.
               2. Check the output from the DELETE-DEFINE job to
                  insure the dataset was created.
            B. To use IPCS, you must invoke the WorkBench in a
               special way, then select it by use of menus:
               1. Enter the following command at the READY prompt:
                         WB IPCS(Y)
               2. To invoke IPCS from WorkBench choose option 3
                  TEST from the "Programmers Facility Primary
                  Menu", which displays the "TEST FACILITY LEVEL
                  1" screen. Next, enter I for IPCS to get the
                  "IPCS PRIMARY OPTION MENU".

         2. SETTING UP FOR A NEW DUMP:
            A. The dump must be in IPCS format, created by a
               SYSMDUMP DD statement, a console dump, or an MVS
               System dump. Abend-Aid dumps and those created by
               SYSUDUMP or SYSABEND DD statements are not usable
               by IPCS.
            B. At the "IPCS PRIMARY OPTION MENU" choose 0 for
               DEFAULTS, which will bring up the "IPCS Default
               Values" screen.
            C. Tab to the "Source ==>" field and enter the dump
               file dataset name as DSNAME('ffffffffff'), where
               'ffffffff' is the fully qualified dataset name.
               For example, to use IPCS on a dump dataset called
               BC0THOR.TST.DUMP04, you would have:
                 Source  ==> DSNAME('BC0THOR.TST.DUMP04')
            D. Return to the "IPCS PRIMARY OPTION MENU" via PF3.
            E. Choose the COMMAND option by typing 4, which
               brings up the "IPCS Subcommand Entry" screen.
            F. To initialize the dump and produce the Summary
               listing, enter the following command line:
                 ==> SUMMARY FORMAT REGS PRINT NOTERM
            G. This process is rather slow. After a minute or two
               you may be asked for permission to use summary
               dump data. Answer "y". The process continues,
               often for 5-10 minutes, depending on how busy the
               system is. When finished you usually see a message
               that begins "A dataspace name and an owning ASID
               ...". Press PF3 to return to the "IPCS Subcommand
               Entry" screen.
            H. To complete the Summary listing process, enter the
               following command line:
                 ==> CLOSE PRINT
            I. The above has initialized the dump for processing
               by IPCS by writing some information to your
               IPCSDDIR dataset. It also writes a TCB Summary
               report to a dataset named IPCSPRNT under your
               userid. You can split screen to view it in TSO
               BROWSE or EDIT during your IPCS session.

         3. TERMINATING USE OF A DUMP:
            A. When finished with a dump you should drop it from
               IPCS and delete it. By dropping it from IPCS, its
               data is deleted from your IPCSDDIR dataset, which
               will improve response when later viewing other
               dumps.
            B. At the "IPCS PRIMARY OPTION MENU" choose 6 for
               DUMPS, which will bring up the "IPCS DUMP
               INVENTORY" screen.
            C. Tab to the left side of the line that identifies
               the dump you wish to drop and enter DD.
            D. Return to the "IPCS PRIMARY OPTION MENU" via PF3.

         4. BROWSE
            A. You will probably spend more time in BROWSE than
               anywhere else in IPCS. Once you have initialized a
               dump, you can go directly into BROWSE without
               initialization (though it does have to be
               specified in the DEFAULT screen).
            B. At the "IPCS PRIMARY OPTION MENU" choose 1 for
               BROWSE, which will bring up the "IPCS - ENTRY
               PANEL" screen.
            C. Tab to the "Address      ==>" field and enter:
                     0.
            D. This will display the "STORAGE" screen which
               contains an address column, 4 hex fullword data
               columns, and a 16-byte character column. From the
               storage screen you can scroll to any address in
               the dump, find data in either hex or character
               form, and ask IPCS to tell you the name of the
               module containing an address.

            E. Addresses are expressions which may include
               combinations of actual addresses, hex numbers, and
               labels. They may be direct or indirect.
               1. Actual addresses are given as a string of 1-7
                  hexadecimal digits ending with a period.
                  Examples:
                     F730.
                     1609670.
               2. Labels are 1-8 character names given to
                  addresses using the EQ command. Examples:
                     BL1
                     TGT
               3. Hex numbers are simply strings of hexadecimal
                  digits. Examples:
                     C
                     4B952
               4. Addresses can be expressions made up of
                  combinations of the above and the + and -
                  symbols. Examples:
                     E962.+32     (This is the same as E994.)
                     CVT+20
                     DCB-6C
               5. Addresses can be made indirect by following
                  them with a % for 24-bit indirect or ? for 31-
                  bit indirect. When indirect is specified, the
                  address is used to find a location. The data at
                  that location is the address to be used. For
                  example, suppose that the data in memory at
                  address 0012FC90 contains the value 82569144,
                  then:
                     12FC90.        Refers to address 12FC90.
                     12FC90.%       Refers to address 569144.
                     12FC90.?       Refers to address 2569144.

         5. LABELS.
            A. Labels are created using the EQ command. A label
               may be used alone or with other items in an
               address expression.
            B. EQ is a command which can be entered on the
               command line of the "STORAGE" screen. The general
               format is:
                    EQ label address-expression
            C. For example, suppose that the program RP159A00
               begins at address 35FC98 in the dump and you wish
               to refer to that location as RP159. Enter:
                    EQ RP159 35FC98.
            D. If the BL CELLS begin at displacement 3D20 from
               the start of RP159A00 you could set up labels for
               various BL cells to simplify your work. For
               example, to define BL1, BL3, and BL4:
                    EQ BL1 RP159+3D20
                    EQ BL3 RP159+3D28
                    EQ BL4 RP159+3D2C

         6. SCROLLING
            A. Scrolling to a given location in the dump can be
               done by use of the L command or by use of the % or
               ? operators before a hex fullword in the dump.
            B. The L command is entered on the command line of a
               "STORAGE" screen as the letter "L" followed by an
               address expression. For example, to scroll to the
               data at memory address 6B598, enter:
                    L 6B598.
               To see the data at BL cell 3, displacement 2C:
                    L BL3+2C
            C. To use the % and ? operators to scroll from the
               "STORAGE" screen, use the tab key to position the
               cursor to the left of the hex data column
               containing the address you wish to view. If the
               address is 24-bit, enter a "%". If the address is
               31-bit, enter a "?". As example, assume you see
               the following on the screen:

            00853290    83FC1964   0000F288   80196244   00071292

               To cause the display to scroll to the 24-bit
               address FC1964, enter a % to the left of the first
               data column:

            00853290  % 83FC1964   0000F288   80196244   00071292

               To cause the display to scroll to the 31-bit
               address 3FC1964, enter a ? to the left of the first
               data column:

            00853290  ? 83FC1964   0000F288   80196244   00071292

         7. WHERE
            A. The W command is used to identify the module
               containing a given address. This can often be
               quite valuable. Sometimes only limited information
               is available. IPCS can only identify load modules,
               not the programs that are linked together to
               produce the load module, so you must have a link
               edit map or other means to identify programs
               within a load module.
            B. To use the where command, enter a "W" followed by
               an address expression on the command line. For
               example, to identify the memory location 566B48
               you would enter:
                    W 566B48.
               This might result in the message: "ASID(x'00EB')
               00566B48. RP005A00+01E294 in EXTENDED PRIVATE"
               which tells you that the address 566B48 is at
               displacement 1E294 from the load point of load
               module RP005A00.

         8. FIND
            A. The F command is used to find (and scroll to) data
               in memory.
            B. To locate a character string containing only upper
               case characters use the format:
                     F 'ccccc'
               where ccccc is the character string to be found.
               The string is not case sensitive, so ccccc is the
               same as CCCCC. For example, to find the character
               string "ABEND IN" you could enter:
                    F 'AbenD in'
                or  F 'abENd In'
                or other combinations of upper and lower case
                characters. Note that the surrounding apostrophes
                are needed only if the string contains blanks or
                special characters.
            C. To locate a character string containing mixed-case
               letters, use the format:
                     F C'ccccc'
               where ccccc is the character string to be found.
               The string is case sensitive, so ccccc is not the
               same as CCCCC. For example, to find the character
               string "AbenD" you would enter:
                    F C'AbenD'
            D. To find a string of hex characters, use this
               format:
                     F X'xxxxxxxx'
               where xxxxxxxx is the 1-8 character string of
               hexadecimal digits. The string is not case
               sensitive, so that 1b5a is the same as 1B5a. For
               example, to find the hex value "90ECD00C", enter:
                     F X'90ECD00C'
                 or  F x'90ecd00c'

./ ADD NAME=IPOUPDTE 0100-99131-99131-0856-00632-00632-00000-BC0THOR
//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,
//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=4M
//JESOUT OUTPUT GROUPID=HDQTRSF2,DEFAULT=YES,JESDS=ALL,
//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG
//*******************************************************************
//*                 BC0THOR.PDS.JCL(IPOUPINS)                       *
//* INSTRUCTIONS FOR THE IPOUPDTE PROGRAM                           *
//*******************************************************************
//PRINT   EXEC PGM=IEBGENER
//SYSIN    DD DUMMY
//SYSPRINT DD SYSOUT=*
//SYSUT2   DD SYSOUT=*,CHARS=GT15
//SYSUT1   DD DATA
1                                       IPOUPDTE                        PAGE-129
-       A.0  THE IPOUPDTE PROGRAM
+            ___ ________ _______
-       IPOUPDTE is an update program that allows you to change fields in JCL
        and control statements in MVS Custom-Built IPO-provided libraries.  The
        program is used extensively in the Custom-Built IPO installation
        processes and is the primary means by which you can modify these and
        other Custom-Built IPO jobs to implement your system design.  Each of
        the Custom-Built IPO installation guides provides a brief introduction
        to IPOUPDTE so that you can change the supplied IPOUPDTE control
        statements and run the jobs.  The description here is more
        comprehensive.  It tells how the program works, what all of its
        functional capabilities are, and how to set up the JCL for an IPOUPDTE
        job.  Complete lists of IPOUPDTE's messages and return codes are also
        given.
0       NOTE: Under most circumstances, you will not need to know this
        information to run the IPOUPDTE jobs in the CBIPO installation
        processes.  The CBIPO installation guides should be adequate for running
        the installation process for your CBIPO feature.  This appendix is
        provided as a reference for people who run into unusual difficulties in
        the installation processes or who want to make extensive modifications
        to the CBIPO-provided jobstreams.
-
        A.1  METHOD OF OPERATION
+            ______ __ _________
-       IPOUPDTE is a search-and-replace program.  It scans a member of a PDS,
        all the members of a PDS, or all the members of a list of PDSs, and it
        conditionally replaces in place parts of the input records.  Only
        CBIPO-provided libraries are eligible for updating by IPOUPDTE.  The
        data to be replaced, called STRING1, and the replacement data, called
        STRING2, are defined by control statements in a SYSIN data set.  An
        optional third search argument, called STRING3, enables you to make the
        replacement only when STRING3 is present in the input record.
0       The operation is as follows:
0       1.  A data record is read into the input buffer and then copied into the
            output buffer.
0       2.  The optional STRING3 on a control statement causes IPOUPDTE to
            search the input buffer for STRING3.
0           a.  If STRING3 is found, the output buffer is searched for STRING1
                and, if found, STRING2 replaces STRING1 in the output buffer.
0           b.  If there is no STRING3, processing is the same as when STRING3
                is specified and found: The output buffer is searched for
                STRING1 and, if found, STRING2 replaces STRING1.
-
0       Level 87A          MVS CBIPO System Design Reference            Page 129
1                                       IPOUPDTE                        PAGE-130
-       Replacement occurs only in the output buffer.  All the potential updates
        (that is, all the STRING1/STRING2s you specify) are processed against
        one input record before processing the next record.  Updates occur in
        the same sequence in which they are specified in the control statements,
        so the result of one update can be changed by later updates.
0       Figure 34 provides four examples of IPOUPDTE processing.  In each case
        the STRING1, STRING2, and STRING3 on a line go together, and both of the
        sets of STRING1/2/3 operate on each of the four input records before
        proceeding to the next input record.
0       +---------------------------------------------------------+
+                 +         +         +             +
        |         |         |         |             |             |
        | STRING1 | STRING2 | STRING3 | INPUT       | UPDATED     |
        |         |         |         | RECORDS     | RECORDS     |
        |         |         |         |             |             |
        +---------------------------------------------------------+
+       |         |         |         |             |             |
        | ONE     | AAA     | (None)  | ONE ONE ZZZ | AAA AAA ZZZ |
        | TWO     | ONE     | (None)  | ONE TWO     | AAA ONE     |
        |         |         |         | TWO ONE ZZZ | ONE AAA ZZZ |
        |         |         |         | TWO TWO     | ONE ONE     |
        +---------------------------------------------------------+
+       |         |         |         |             |             |
        | ONE     | AAA     | (None)  | ONE ONE ZZZ | AAA AAA ZZZ |
        | TWO     | ONE     | ZZZ     | ONE TWO     | AAA TWO     |
        |         |         |         | TWO ONE ZZZ | ONE AAA ZZZ |
        |         |         |         | TWO TWO     | TWO TWO     |
        +---------------------------------------------------------+
+       |         |         |         |             |             |
        | TWO     | ONE     | ZZZ     | ONE ONE ZZZ | AAA AAA ZZZ |
        | ONE     | AAA     | (None)  | ONE TWO     | AAA TWO     |
        |         |         |         | TWO ONE ZZZ | AAA AAA ZZZ |
        |         |         |         | TWO TWO     | TWO TWO     |
        +---------------------------------------------------------+
+       |         |         |         |             |             |
        | ONE     | AAA     | (None)  | ONE ONE ZZZ | AAA AAA TWO |
        | ZZZ     | TWO     | ONE     | ONE TWO     | AAA TWO     |
        |         |         |         | TWO ONE ZZZ | TWO AAA TWO |
        |         |         |         | TWO TWO     | TWO TWO     |
        +---------------------------------------------------------+
+                 +         +         +             +
0       Figure 34. Examples of IPOUPDTE processing
0       Other rules regarding string replacement are as follows:
0       1.  The string to be replaced, STRING1, must be totally contained in
            positions 1 through 71 of an input record.  Thus, the continuation
            position, position 72, and the sequence number field, positions 73
            through 80, are not affected by any updates.
0       2.  To be eligible for replacement, STRING1 must be a "word," not merely
            a string of characters imbedded within a "word."  A "word" to
            IPOUPDTE is any string of characters bounded on both ends by any of
            several special delimiting characters.  It does not have to be an
            English word in the ordinary sense.  For STRING1 to be a word, it
            must have one of the following characters to its left and one to its
            right:
-       Level 87A          MVS CBIPO System Design Reference            Page 130
1                                       IPOUPDTE                        PAGE-131
-             ' , . / < > ? " : ; ¬ + _ ( ) * % | =
              and blank
0           The only exceptions to this statement are:
0           *   When STRING1 starts at the beginning of the input record or ends
                in the last position (71) of the input record
0           *   When the two characters '.V' occur at the beginning of a string.
                The 'V' is considered part of the delimiter, not of the word,
                and it is not eligible for replacement.
0       3.  When STRING2 is longer than STRING1, blanks are deleted from pools
            of two or more blanks following STRING1 within the record, up to and
            including position 71, thus shifting to the right some non-blank
            characters that follow STRING1.  A field consisting of only one
            blank is not deleted.  If there is no place to delete blanks (that
            is, no place to shift the following non-blank characters into), an
            error message is issued, the record is not updated, and processing
            continues with the next record.  Inability to update within a
            comment record or comment portion of a record produces a return code
            of 4.  Otherwise, the return code is 8.
0       4.  When the length of STRING2 is less than that of STRING1, blanks are
            inserted after the next pool of two blanks following STRING1.
0       5.  Updates to a record occur in the order that the control statements
            were entered.  Each control statement processes the record in its
            entirety before the next control statement processes the record.
-
        A.2  IPOUPDTE CONTROL STATEMENTS
+            ________ _______ __________
-       You tell IPOUPDTE what you want to update in the specified libraries'
        members by specifying STRING1 and STRING2 and optionally STRING3 on
        control statements.  You can supply the control statements either in a
        SYSIN data set or from the system console.  IPOUPDTE has four types of
        control statements: the basic control statement, the extended control
        statement, the END statement, and the comment statement.
0       Only the first 72 positions of the control statement are used; positions
        73 through 80 are ignored.  STRING1 begins in position 1.
0       The maximum length for STRING1, STRING2, or STRING3 is 70 characters.
        The minimum length for STRING1 is 1.  The minimum length for STRING2 and
        STRING3 is zero.  If STRING2 is null--that is, a length of zero--STRING1
        is deleted from the record.
0       If you make a mistake in the syntax of a control statement and you are
        using SYSIN for input, IPOUPDTE writes a error message identifying the
        faulty statement, scans the remaining control statements for errors, and
        then terminates without processing any libraries or making any updates.
-       Level 87A          MVS CBIPO System Design Reference            Page 131
1                                       IPOUPDTE                        PAGE-132
-       A.2.1  THE BASIC CONTROL STATEMENT
-       The syntax of the basic control statement is as follows:
0         STRING1<STRING2<   optional comments
0       where STRING1 and STRING2 are as explained in "Method of Operation" on
        page 129.  The less-than symbol (<) is used to delimit the strings.  The
        basic form causes all occurrences of STRING1 on all records of all
        members of the specified libraries to be replaced by STRING2.
0       For example, if a member contains
0         UNIT=3380,VOL=SER=MVSIPO    /*LIB*/    input record1 before update
          UNIT=3380,VOL=SER=MVSRS1    /*RES*/    input record2 before update
0       and you specify the following on IPOUPDTE control statements:
0         3380<3350<                             first control statement
          MVSIPO<MVSRS1<                         second control statement
0       then the modified records will look like this:
0         UNIT=3350,VOL=SER=MVSRS1   /*LIB*/     resultant record1 after update
          UNIT=3350,VOL=SER=MVSRS1   /*RES*/     resultant record2 after update
-
        A.2.2  THE EXTENDED CONTROL STATEMENT
-       The syntax of the extended form is as follows:
0         STRING1<STRING2<STRING3<   optional comments
0       where STRING1, STRING2 and STRING3 are as explained in "Method of
        Operation" on page 129.  Replacement occurs only on records that have
        STRING3 as well as STRING1.  Furthermore, STRING2 replaces STRING1 only
        when STRING3 was on the original record (as it was before any updates
        took place).  All 80 positions are searched for STRING3.
0       When STRING3 is used in the members of the Custom-Built IPO installation
        process, it is offset with the characters /* - */.
0       For example, if a member contains
0         UNIT=3380,VOL=SER=MVSIPO    /*LIB*/    input record1 before update
          UNIT=3380,VOL=SER=MVSRS1    /*RES*/    input record2 before update
0       and you specify the following on IPOUPDTE control statements:
0         3380<3350</*RES*/<                     first control statement
          MVSRS1<RESPAK</*RES*/<                 second control statement
-       Level 87A          MVS CBIPO System Design Reference            Page 132
1                                       IPOUPDTE                        PAGE-133
-       then the modified records will look like this:
0         UNIT=3380,VOL=SER=MVSIPO    /*LIB*/    resultant record1 after update
          UNIT=3350,VOL=SER=RESPAK     /*RES*/   resultant record2 after update
0       If STRING3 is null, the extended form reverts to the basic form.
-
        A.2.3  THE END CONTROL STATEMENT
-       The END control statement signals the end of control statement input for
        the current run of IPOUPDTE.  The syntax of the END statement is END
        coded in positions 1 through 3 and a blank in position 4.  The remainder
        of the statement is not used and can contain comments.  The END
        statement is equivalent to end-of-file on SYSIN and is, therefore,
        optional.
-
        A.2.4  THE COMMENT STATEMENT
-       A comment statement consists of a </* in positions 1 through 3.  Comment
        statements cannot be continued; a new comment statement must be used on
        the following record.
-
        A.2.5  CONTINUATIONS AND COMMENTS
-       A control statement can be continued only after a less-than symbol (<),
        not in the middle or after one of the strings.  You tell IPOUPDTE that a
        control statement is to be continued by placing a dash (-) or a plus (+)
        immediately following any less-than symbol.  The remainder of the
        statement is not scanned and can contain comments.  When using a dash
        (-) to continue a statement, the control statement scan resumes in
        position 1 of the next statement.  When using a plus (+) to continue a
        statement, the control statement scan resumes at the first non-blank
        character of the next statement.  The continuation character, dash or
        plus, is not considered a part of any of the strings.
0       Comments can be placed after the first blank following the third
        less-than symbol (<) of the control statement or following the
        continuation character of a continued statement.
0       For example, the following IPOUPDTE control statement
0         3380<3350<UNIT=< A COMMENT AFTER THE BLANK
0       can be split across as many as three records, thus providing much more
        room for comments:
-       Level 87A          MVS CBIPO System Design Reference            Page 133
1                                       IPOUPDTE                        PAGE-134
-         3380<+      some more comments on continuation statement
           3350<+     note the plus continuation causes blanks on next
           UNIT=<     statement to be ignored
-
        A.2.6  CONTROL STATEMENT INPUT FROM THE SYSTEM CONSOLE
-       You can enter control statements from the system console as an
        alternative to entering them in a SYSIN data set.  (When you omit the
        SYSIN DD statement, IPOUPDTE goes to the console for control statements.
        See "JCL for IPOUPDTE" on page 136.)  IPOUPDTE uses a WTOR macro for
        this purpose, allowing up to 72 characters in a single reply.  You can
        continue a reply by entering a dash (-) as the last character of your
        response.
0       IPOUPDTE handles control statement errors differently when input is from
        the system console than when it is in SYSIN.  Since console input
        provides an interactive environment, IPOUPDTE allows you to correct
        control statement errors before input ends, and it then processes
        normally.  When IPOUPDTE finds an error in a control statement from the
        console, it writes an error message to the operator, ignores the
        erroneous control statement, and waits for you to enter another control
        statement.
0       When in console input mode, certain messages are logged to the
        operator's console as well as to SYSPRINT.
-
        A.3  THE NO UPDATE/RESUME UPDATE FACILITY
+            ___ __ _____________ ______ ________
-       Sometimes you may not want to replace all occurrences of STRING1 that
        IPOUPDTE finds, and you may not have a convenient way to use STRING3 to
        control updating.  For these occasions IPOUPDTE provides a way for you
        to suspend and later resume updating.  You do this my marking the
        suspension and resumption points within the input library members
        themselves.  You code a .NU. (No Update) marker in the first record of
        the member not to be considered for update, and IPOUPDTE suspends
        updating until end-of-file is reached for the member or until it finds a
        .RU. (Resume Update) marker.  When IPOUPDTE finds the .RU. marker it
        resumes updating on the next record of the member.  Thus, if you have
+                               ____
        only one record that you want to protect from updating, you can code
        both .NU. and .RU. (that is, ".NU..RU.") on that one record.
0       The No Update/Resume Update facility can be overridden by specifying the
        member name of the data set in the DD statement.  However, as explained
        in the section on "Execution Modes" on page 135, you can tell IPOUPDTE
        that you want to honor the .NU./.RU. markers even though you have
        entered a member name on one or more of the specified libraries' DD
        statements.  You do this by specifying one of the EXEC statement PARM
        values that ends in "M."
-       Level 87A          MVS CBIPO System Design Reference            Page 134
1                                       IPOUPDTE                        PAGE-135
-       As an example of the use of the .NU./.RU. facility, suppose you have a
        PDS with the following JCL in one of the members:
0         //SYSPRINT DD SYSOUT=*
          //SYSIN    DD *
           RENAME DSNAME=IPO1.LINKLIB,       .NU..RU.
                  VOL=3380=MVSRS1,NEWNAME=IPO1.LINKLIB
          .
          .
          .
0       If your IPOUPDTE control statement is
0         IPO1<CBIPO<
0       then the IPO1 on the record containing the .NU. and .RU. will not be
        changed, but the IPO1 on the following record will be changed.  The
        result will be as follows:
0         //SYSPRINT DD SYSOUT=*
          //SYSIN    DD *
           RENAME DSNAME=IPO1.LINKLIB,       .NU..RU.
                  VOL=3380=MVSRS1,NEWNAME=CBIPO.LINKLIB
          .
          .
          .
0       However, if you had included the member name on the IPOUPDTE DD
        statement for the library containing this member, both occurrences of
        IPO1 would be changed, and the records would look like this:
0         //SYSPRINT DD SYSOUT=*
          //SYSIN    DD *
           RENAME DSNAME=CBIPO.LINKLIB,         .NU..RU.
                  VOL=3380=MVSRS1,NEWNAME=CBIPO.LINKLIB
          .
          .
          .
-
        A.4  EXECUTION MODES
+            _________ _____
-       You can run IPOUPDTE in any of several different modes, each of which is
        unique in terms of whether actual updating takes place, how the No
        Update/Resume Update facility is handled, and how the libraries to be
        updated are specified to IPOUPDTE.  The mode is specified in the PARM
        field on the EXEC statement you use when you invoke IPOUPDTE.  The six
        modes are as follows:
0       CHECK     Verifies updates to records but does not write any updated
                  records back to the specified libraries.
-
        Level 87A          MVS CBIPO System Design Reference            Page 135
1                                       IPOUPDTE                        PAGE-136
-       UPDATE    Updates the records of the specified libraries.
0       INSTALL   Updates the records of the specified libraries using control
                  statements generated from special DD statements that are
                  required in the job step when this execution mode is used.
                  The special DD statements have DDnames of 'Zvvvvvv', where
                  'vvvvvv' is a volume serial number that is to be replaced in
                  the specified libraries.  'vvvvvv' is replaced by the volume
                  serial number specified in the VOL=SER parameter on the
                  Zvvvvvv DD statement.
0                 For example, if you include the following DD statement in the
                  IPOUPDTE job step:
0                   //ZMVSRS1 DD UNIT=3350,VOL=SER=MVSRES,DISP=OLD
0                 IPOUPDTE generates the following control statements and adds
                  them to the control statements you explicitly provide:
0                   MVSRS1<MVSRES<<               CHANGE VOLUME SERIAL
                    3380<3350<MVSRS1<             CHANGE DEVICE TYPE
0                 These two control statements are generated for each 'Zvvvvvv'
                  DD statement included in the step.
0       CHECKM    Verifies updates to records of the specified libraries, but
                  does not write the updated records back to the data set.  This
                  parameter causes .NU./.RU. markers in a library's member to be
                  honored, even if the member name is specified on the library's
                  DD statement.  In other words, when you specify PARM=CHECKM,
                  IPOUPDTE behaves for the purposes of .NU./.RU. processing as
                  if you had not entered member names on any of the specified
                  libraries' DD statements.
0       UPDATEM   Updates the records of the specified libraries.  This
                  parameter causes .NU./.RU. processing to be the same as that
                  for PARM=CHECKM (see explanation above).
0       INSTALLM  Updates the records of the specified libraries.  PARM=INSTALLM
                  requires the same 'Zvvvvvv' DD statements as PARM=INSTALL does
                  (see explanation above).  Furthermore, this parameter causes
                  .NU./.RU. processing to be the same as that for PARM=CHECKM
                  (see explanation above).
-
        A.5  JCL FOR IPOUPDTE
+            ___ ___ ________
-       IPOUPDTE uses the following JCL statements and parameters:
0       EXEC PGM=IPOUPDTE   The IPOUPDTE load module resides in IPO1.LINKLIB.
                            If this data set is not in the LNKLST of the system
                            on which the job is to be run (it is in the LNKLST
-       Level 87A          MVS CBIPO System Design Reference            Page 136
1                                       IPOUPDTE                        PAGE-137
-                           of MVS Custom-Built IPO systems produced by the
                            Custom-Built IPO installation process), the job
                            should include a JOBLIB statement for IPO1.LINKLIB,
                            or the step should include a STEPLIB statement for
                            IPO1.LINKLIB, or IPOUPDTE should be copied from
                            IPO1.LINKLIB to a load module library that is in the
                            LNKLST of the system on which the job is to be run.
0       PARM=               The PARM field of the EXEC statement is used to
                            specify one of the execution modes of IPOUPDTE.
                            (IPOUPDTE's execution modes are explained in
                            "Execution Modes" on page 135.)  The value of the
                            PARM field must be one of the following:  CHECK,
                            UPDATE, INSTALL, CHECKM, UPDATEM, or INSTALLM.  If
                            no value is specified, PARM=CHECK is the default.
0       SYSPRINT DD         A SYSPRINT DD statement is required.  The SYSPRINT
                            file is used to log all input control statements,
                            output messages, and updates.  Its DCB attributes
                            are RECFM=FBA,LRECL=121.  The default blocksize is
                            121.  If the SYSPRINT DD statement is missing, an
                            error message is issued to the console and
                            processing terminates.
0       @LIBRARY DD         Each library specified for updating must be defined
                            in a DD statements whose DDNAME begins with a
                            commercial (@).  For example:
0                             //@JCLLIB DD DSN=IPO1.JCLLIB,DISP=SHR
0                           Except for the requirements that the DDnames begin
                            with @ and that each one be unique, there are no
                            further requirements on the DDnames for the
                            specified libraries.
0                           A library to be updated must be a partitioned data
                            set (DSORG=PO), RECFM=F or FB, LRECL=80, it must be
                            allocated on a direct access volume, and it must be
                            a CBIPO-supplied library.  If a data set fails to
                            meet these requirements, a warning message is issued
                            and processing continues with the next library.  If
                            no member is specified for the data set on the DD
                            statement, all members of the library are processed
                            by IPOUPDTE.
0       SYSIN DD            Control statements for IPOUPDTE can be entered
                            through file name SYSIN, with DCB attributes RECFM=F
                            or FB, and LRECL=80.  If the SYSIN DD statement is
                            not present and PARM=INSTALL is not specified, the
                            operator is prompted for input through the
                            operator's console via a WTOR sequence.  The SYSIN
                            DD statement is not used when PARM=INSTALL is
                            specified.
-
        Level 87A          MVS CBIPO System Design Reference            Page 137
1                                       IPOUPDTE                        PAGE-138
-       A.6  ONE MORE EXAMPLE OF USING IPOUPDTE
+            ___ ____ _______ __ _____ ________
-       Suppose the following JCL existed in member SAMPLE of library
        IPO1.JCLLIB:
0         //SAMPLE   JOB (ACCT#),'PGMRNAME',
          //         MSGCLASS=X,MSGLEVEL=(1,1),CLASS=A
          //* COMMENT   IPO1 COMMENT IPO1  TWO BLANKS
          //CATLG    EXEC PGM=IEHPROGM
          //SYSPRINT DD   SYSOUT=*
          //MOUNT    DD   UNIT=3380,VOL=SER=MVSRS1,DISP=OLD
          //SYSIN    DD   *
            CATLG DSNAME=IPO1.PROCLIB,VOL=3380=MVSRS1
            CATLG DSNAME=IPO1.LINKLIB,VOL=3380=MVSRS1
          /*
0       Similarly, suppose that the following JCL was used to update
        IPO1.JCLLIB:
0         //IPOUPDTE JOB (ACCT#),'PGMRNAME',
          //         MSGCLASS=X,MSGLEVEL=(1,1),CLASS=A
          //STEP     EXEC PGM=IPOUPDTE,PARM=UPDATE
          //SYSPRINT DD   SYSOUT=*
          //@TEST    DD   DSN=IPO1.JCLLIB,DISP=SHR
          //SYSIN    DD   *
          CLASS=X<CLASS=A<
          *<A<SYSOUT=<
          IPO1<CBIPO<
          /*
0       Member SAMPLE of IPO1.JCLLIB would be changed to the following:
0         //SAMPLE   JOB (ACCT#),'PGMRNAME',
          //         MSGCLASS=X,MSGLEVEL=(1,1),CLASS=A
          //* COMMENT   CBIPO COMMENT CBIPO TWO BLANKS
          //CATLG    EXEC PGM=IEHPROGM
          //SYSPRINT DD   SYSOUT=A
          //MOUNT    DD   UNIT=3380,VOL=SER=MVSRS1,DISP=OLD
          //SYSIN    DD   *
            CATLG DSNAME=CBIPO.PROCLIB,VOL=3380=MVSRS1
            CATLG DSNAME=CBIPO.LINKLIB,VOL=3380=MVSRS1
          /*
0       Some things to notice in this example are:
0       1.  On the JOB statement, MSGCLASS=X did not change to MSGCLASS=A
+                                                ___
            because the string 'CLASS=X' is not properly delimited on the left.
0       2.  The comment statement was used to demonstrate how blanks are deleted
            from a record to expand a field. That is, IPO1 was changed to CBIPO
            requiring one blank to be deleted for each substitution.
-
0       Level 87A          MVS CBIPO System Design Reference            Page 138
1                                       IPOUPDTE                        PAGE-139
-       3.  The extended form of the control statement was used to change the
            SYSOUT class.
-
        A.7  IPOUPDTE MESSAGES
+            ________ ________
-       IPO001    * ERROR * SYSPRINT DD MISSING
0       EXPLANATION: This message is issued via WTO when no SYSPRINT DD
        statement is found in the JOB step.
0       SEVERITY: 16
0       SYSTEM ACTION: The program terminates.  No processing has taken place.
0       USER RESPONSE: Add a SYSPRINT DD statement to the JOB step.
-       IPO002    * ERROR * INVALID PARAMETER FIELD
0       EXPLANATION: This message is issued when an invalid parameter field of
        the EXEC statement is encountered.
0       SEVERITY: 16
0       SYSTEM ACTION: The program terminates.  No processing has taken place.
0       USER RESPONSE: Make sure that the parameter field is null or that one of
        the following is specified: CHECK, UPDATE, INSTALL, CHECKM, UPDATEM or
        INSTALLM.
-       IPO003    ENTER IPOUPDTE CONTROL STATEMENT OR 'END'
0       EXPLANATION: This message is issued during the WTOR control statement
        input sequence.  It is a request for a new control statement or the
        continuation of a previous statement.  If 'END' is entered, further
        input processing is ended.
0       SYSTEM ACTION: Wait for operator's reply.
0       USER RESPONSE: Enter the control statement or 'END'.
-       IPO004    INVALID CONTROL STATEMENT SYNTAX
0       EXPLANATION: This message is issued when a control statement's syntax is
        invalid.
-
-
        Level 87A          MVS CBIPO System Design Reference            Page 139
1                                       IPOUPDTE                        PAGE-140
-       SEVERITY: 16 or 0
0       SYSTEM ACTION: If input is from SYSIN, the remaining control statements
        are read and validated, after which the program terminates with a return
        code of 16.  If input is via the operator's console, the statement in
        error is ignored and processing resumes normally.
0       USER RESPONSE: Correct the control statement syntax.  Ensure that:
0       *   The control statement ends before position 73
        *   None of STRING1, STRING2 or STRING3 is longer than 70 characters
        *   STRING1 is at least 1 character
        *   STRING1, STRING2 and (if used) STRING3 are delimited by '<'
        *   The END control statement (if used) is in positions 1 through 4
        *   Any continued records end with '<-' or '<+' (excluding comments and
            .NU..RU.).
0       IPO005    END OF INPUT CONTROL STATEMENTS
0       EXPLANATION: This message is issued when end-of-file is encountered on
        SYSIN or when an 'END' control statement is encountered.
0       SYSTEM ACTION: If all control statements are valid, processing of the
        libraries begins.
0       USER RESPONSE: None.
-       IPO006    FILE XXXXXXXX INVALID FOR IPOUPDTE
0       EXPLANATION: This message is issued when a DD statement is found
        defining a library to be processed by IPOUPDTE, but the library failed
        to meet the requirements of libraries that can be processed by IPOUPDTE.
        XXXXXXXX is the DDname of the invalid library.
0       SEVERITY: 4
0       SYSTEM ACTION: Processing continues with the next library.
0       USER RESPONSE: Ensure that:
0       *   The data set is a PDS
        *   The record format is F or FB
        *   The logical record length is 80
        *   The data set is on the specified DASD volume.
0       IPO007    I/O ERROR . . . SYNAD ERROR MESSAGE . . .
0       EXPLANATION: This message is issued when an I/O error occurs on the
        library being updated.  The text of the message is that which is
        available to a SYNAD error routine.
-
-       Level 87A          MVS CBIPO System Design Reference            Page 140
1                                       IPOUPDTE                        PAGE-141
-       SEVERITY: 12
0       SYSTEM ACTION: Processing of this library terminates and processing
        resumes with the next library.
0       USER RESPONSE: Check the data set and device for possible errors.
-       IPO008    PROCESSING TERMINATED FOR FILE XXXXXXXX
0       EXPLANATION: This message is issued when processing has ended
        prematurely for a given file.  XXXXXXXX is the DDname of the file.
0       SEVERITY: 12
0       SYSTEM ACTION: Processing continues with the next library.
0       USER RESPONSE: Check previous messages to determine the cause.
-       IPO009    * ERROR * TOO MANY CONTROL STATEMENTS
0       EXPLANATION: This message is issued when too many control statements
        were entered.
0       SEVERITY: 16
0       SYSTEM ACTION: Control statement input ends and processing terminates
        with no updates done.
0       USER RESPONSE: Each control statement requires 8+L1+L2+L3 bytes of
        storage, where L1, L2, and L3 are the lengths of STRING1, STRING2, and
        STRING3, respectively.  The total of all control statements must be less
        than 4092 bytes of storage.  Split the control statements into two or
        more batches and rerun the job until all batches are processed.
-       IPO010    FILE XXXXXXXX HAD NO UPDATES
0       EXPLANATION: This message is issued when no updates were made to a
        library because no text was found that matched any control statements.
0       SEVERITY: 4
0       SYSTEM ACTION: Processing continues with the next library.
0       USER RESPONSE: Make sure all control statements specified the updates
        you intended.
-       IPO011    IPOUPDTE ENDED. CODE=XX
-
-       Level 87A          MVS CBIPO System Design Reference            Page 141
1                                       IPOUPDTE                        PAGE-142
-       EXPLANATION: This message is issued during the termination of IPOUPDTE,
        where XX is the return code.
0       SYSTEM ACTION: None.
0       USER RESPONSE: Check the return code.
-       IPO012    DATA SET NOT APPLICABLE TO IPOUPDTE
0       EXPLANATION: This message is issued when a DD statement was found
        defining a library to be updated, but the library was not supported by
        IPOUPDTE.
0       SEVERITY: 4
0       SYSTEM ACTION: Processing continues with the next library.
0       USER RESPONSE: Ensure that only IPOUPDTE-supported libraries are
        specified.
-       IPO013    DD XXXXXXXX INVALID OR UNKNOWN DEVICE TYPE
0       EXPLANATION: This message can occur only when PARM=INSTALL or
        PARM=INSTALLM is specified on the EXEC statement.  It indicates one of
        the following:
0       *   A DDname beginning with 'Z' does not have the format 'Zvvvvvv',
            where 'vvvvvv' is the volume serial number of a DASD volume.
            References to 'vvvvvv' in the libraries to be updated are to be
            changed to the volume and device type defined by the DD statement
            Zvvvvvv.
        *   DD statement Zvvvvvv does not define a recognized DASD device.
0       SEVERITY: 16
0       SYSTEM ACTION: Processing terminates with no updates done.
0       USER RESPONSE: Correct the faulty DD statement and rerun the job.
-
        A.8  IPOUPDTE RETURN CODES
+            ________ ______ _____
-       RETURN CODE OF 0
0       EXPLANATION: All processing completed with no errors or warnings.
0       USER RESPONSE: None.
-
-       Level 87A          MVS CBIPO System Design Reference            Page 142
1                                       IPOUPDTE                        PAGE-143
-       RETURN CODE OF 4
0       EXPLANATION: One or more of the following occurred:
0       *   One or more of the libraries had no updates
        *   One or more of the libraries was invalid to be processed by
            IPOUPDTE.
        *   A string within a record's comment field could not be replaced
            because too few blanks remained in the record.
0       USER RESPONSE: Check messages logged to SYSPRINT file.
-       RETURN CODE OF 8
0       EXPLANATION: The non-comment text in at least one record could not be
        updated because too few blanks remained in the record.
0       USER RESPONSE: Check messages logged to SYSPRINT file to determine the
        records that could not be updated.
-       RETURN CODE OF 12
0       EXPLANATION: At least one library had an I/O error.
0       USER RESPONSE: Check messages logged to SYSPRINT file to determine where
        the errors occurred.
-       RETURN CODE OF 16
0       EXPLANATION: One of the following occurred:
0       *   The SYSPRINT DD statement was missing
        *   One or more of the control statements were invalid
        *   The PARM field on the EXEC statement contained an invalid parameter
        *   Too many control statements were entered
        *   An invalid Zvvvvvv DD statement was supplied when PARM=INSTALL or
            PARM=INSTALLM was specified on the EXEC statement
0       USER RESPONSE: Check messages logged to SYSPRINT file to determine where
        the errors occurred.
-
-
-
-
0       Level 87A          MVS CBIPO System Design Reference            Page 143
./ ADD NAME=JOBINFO  0100-96010-96010-1200-00020-00020-00000-BC0THOR
                PASS JOBNAME AND JOB NUMBER TO CALLER

 CALLING PROGRAM WHICH MAY RESIDE ABOVE OR BELOW THE 16 MEG LINE.
 JOBINFO PASSES BACK THE JOB NAME (8) BYTES FOLLOWED BY THE JES2
 JOB NUMBER FIELD (8 BYTES) IN A 16-BYTE FIELD SUPPLIED BY THE
 CALLER. THE JOB NUMBER FIELD CONTAINS THE LITERAL "JOB" FOLLOWED BY
 THE 5 DIGIT JOB NUMBER AS PRINTABLE DECIMAL CHARACTERS.

 JOB NAME IS TAKEN FROM THE TIOT, WHILE JOB NUMBER IS FROM THE SSIB.

 THE JOBINFO SUBROUTINE IS WRITTEN IN ASSEMBLER WITH AMODE=31,
 RMODE=ANY, AND IS LINKEDITED REENT.

 CALLING EXAMPLE (FROM A COBOL PROGRAM):

       01  JOB-INFO-AREA.
           05  JOB-NAME          PIC X(8).
           05  JOB-NUMBER        PIC X(8).

       CALL 'JOBINFO' USING JOB-INFO-AREA.
./ ADD NAME=LIBPRNT  0100-88061-88061-1000-00038-00038-00000-USER02
                        PRINT MEMBERS OF A PDS

THIS PROGRAM PRINTS MEMBERS OF A PDS. THE PRINTOUT CONTAINS ONLY THE
DATA IN THE PDS MEMBERS, AND HAS NO HEADINGS. EACH MEMBER BEGINS ON A
PAGE. MEMBERS MAY BE SPECIFIED BY CONTROL CARD, OR ALL MEMBERS WILL BE
PRINTED IF NO MEMBER SELECTION CARDS ARE ENTERED.

DD CARDS USED:

SYSPRINT : SPECIFIES THE PRINTED OUTPUT. RECFM=FBA,LRECL=81 IS
HARD-CODED IN THE PROGRAM, BUT BLKSIZE MUST BE PROVIDED
BY THE USER.

INPUT1   : SPECIFIES THE INPUT PDS (LIBRARY) CONTAINING THE MEMBERS
TO BE PRINTED. THIS PDS SHOULD CONTAIN 80-BYTE FIXED
LENGTH RECORDS.

   SYSIN    : SPECIFIES THE MEMBER SELECTION CARD FILE. ANY NUMBER OF
              CARDS MAY BE ENTERED. A CARD MAY CONTAIN ONE OR MORE
              MEMBER NAMES. THE FIRST NAME MUST BEGIN IN COLUMN 1.
              WHEN MORE THAN ONE MEMBER NAME IS ENTERED ON A CARD,
              SEPARATE NAMES WITH COMMAS, AND DO NOT INCLUDE BLANK
              COLUMNS BETWEEN NAMES, AS CONTROL CARD SCAN STOPS
              WHEN THE FIRST BLANK COLUMN IS FOUND. NAMES MAY
              CONTINUE THROUGH COLUMN 72.


EXAMPLE JCL: PRINT MEMBERS ASMFCL AND COBUCL ON SYS1.PROCLIB

//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//PRTLIB   EXEC PGM=LIBPRNT
//STEPLIB  DD   DSN=SYS1.TECHLOAD,DISP=SHR
//INPUT1   DD   DSN=SYS1.PROCLIB,DISP=SHR
//SYSPRINT DD   SYSOUT=A,DCB=BLKSIZE=81
//SYSIN    DD   *
ASMFCL,COBUCL
./ ADD NAME=LISTPSWD 0100-02092-02092-1415-00021-00021-00000-BC0THOR
*                     ***** LIST THE PASSWORD DATASET *****
*
*      LISTPSWD PROVIDES A FORMATTED LISTING OF THE PASSWORD DATASET
* FOR CONTROL AND MAINTENANCE PURPOSES. THE FILE IS READ USING EXCP
* TO OBTAIN THE KEY AND DATA. PRINTED OUTPUT INCLUDES THE DATASET
* NAME, PASSWORD, TYPE OF PASSWORD PROTECTION (READ, WRITE, ETC),
* AND THE NUMBER OF TIMES USED.
*
*     JCL REQUIREMENTS:
*
*     EXEC CARD FOR PGM=LISTPSWD
*     SYSPRINT DD CARD - RECFM=F,LRECL=80,BLKSIZE=80 ARE HARD-CODED.
*     PASSWORD DD CARD FOR THE SYSTEM PASSWORD DATASET.
*
*      JCL EXAMPLE:
*
*     //LISTPSWD JOB (ACCTG),PGMRNAME,CLASS= .....
*     //LIST  EXEC PGM=LISTPSWD
*     //SYSPRINT DD SYSOUT=A
*     //PASSWORD DD DSN=PASSWORD,DISP=SHR
*
./ ADD NAME=LSTVTOC  0100-88061-88061-1001-00089-00089-00000-USER02
*            *** VTOC LISTING PROGRAM ***
*
*
*
THE VTOC LISTING SYSTEM PRODUCES TWO LISTINGS. THE FIRST IS IN
ALPHANUMERIC ORDER BY DATASET NAME, AND CONTAINS ENTRIES FOR ALL
DATASETS ON ALL VOLUMES INPUT TO THE RUN, WHILE THE SECOND IS A
SERIES OF DISK PACK MAPS, ONE PER VOLUME INPUT.
*
DATASET LISTING:
  THIS LISTING CONTAINS DATASET NAME, CHARACTERISTICS (DSORG, RECFM,
  RKP, KEYLEN, BLKSIZE, ETC), PERCENTAGE TRACK UTILIZATION AT CURRENT
  BLOCKSIZE, AMOUNT OF UNUSED SPACE (INCLUDING ISAM FILES), AND
  VOLSER AND EXTENT RELATED INFORMATION.
*
DISK PACK MAPS:
 THIS LISTING SHOWS ALL DISK EXTENTS, ALLOCATED AND UNALLOCATED, IN
 SEQUENTIALLY ASCENDING DISK ADDRESSES. THE VTOC AND UNALLOCATED
 EXTENTS ARE IDENTIFIED BY A LITERAL. ALLOCATED EXTENTS WILL SHOW
 THE OWNING DATASET NAME. DETAIL FOR EACH EXTENT INCLUDES DSORG,
 RECFM, LRECL, BLKSIZE, KEYLEN, PERCENT OF TRACK UTILIZATION,
 VOLUME SEQUENCE, EXTENT TYPE, EXTENT NBR, BEGIN AND END ADDRESSES,
 NBR CYLINDERS ALLOCATED, AND UNUSED SPACE ALLOCATED.
*
*  JCL EXAMPLE:
*
//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//LSTVTOC1 EXEC PGM=LSTVTOC1
//STEPLIB  DD DSN=SYS1.TECHLOAD,DISP=SHR
//SYSUDUMP DD SYSOUT=(A,,DUMP)
//OUTPUT1  DD DSN=&&LSTVTOC1,DISP=(NEW,PASS,DELETE),UNIT=DISK,
//            SPACE=(CYL,(3,1),RLSE),
//            DCB=(LRECL=210,RECFM=FB,BLKSIZE=5880)
//PRINT1   DD SYSOUT=A
//VTOC2    DD UNIT=DISK,DISP=SHR,VOL=SER=DLIB01
//VTOC3    DD UNIT=DISK,DISP=SHR,VOL=SER=PAGE01
//*
//*
//*
//LVSORT1 EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'
//SORTLIB  DD DSN=SM01.SORTLIB,DISP=SHR
//SYSOUT   DD SYSOUT=A
//SORTIN   DD DSN=&&LSTVTOC1,DISP=(OLD,DELETE,DELETE)
//SORTOUT  DD DSN=&&LVSORT1,DISP=(NEW,PASS,DELETE),UNIT=DISK,
//            SPACE=(CYL,(2,1),RLSE),
//            DCB=(RECFM=FB,LRECL=210,BLKSIZE=5880)
//SORTWK01 DD UNIT=DISK,SPACE=(CYL,3,,CONTIG)
//SORTWK02 DD UNIT=DISK,SPACE=(CYL,3,,CONTIG),SEP=SORTWK01
//SORTWK03 DD UNIT=DISK,SPACE=(CYL,3,,CONTIG)
//SORTWK04 DD UNIT=DISK,SPACE=(CYL,3,,CONTIG),SEP=SORTWK03
//SYSIN DD *
 SORT FIELDS=(1,53,CH,A)
//*
//*
//*
//LSTVTOC2 EXEC PGM=LSTVTOC2
//STEPLIB  DD DSN=SYS1.TECHLOAD,DISP=SHR
//SYSUDUMP DD SYSOUT=(A,,DUMP)
//INPUT1   DD DSN=&&LVSORT1,DISP=(OLD,DELETE,DELETE)
//PRINT1   DD SYSOUT=A
//OUTPUT1  DD DSN=&&LSTVTOC2,DISP=(NEW,PASS,DELETE),UNIT=DISK,
//            SPACE=(CYL,(2,1),RLSE),
//            DCB=(RECFM=FB,LRECL=160,BLKSIZE=5920)
//*
//*
//*
//LVSORT2 EXEC PGM=SORT33,PARM='CORE=MAX,MSG=AP'
//SORTLIB  DD DSN=SM01.SORTLIB,DISP=SHR
//SYSOUT   DD SYSOUT=A
//SORTIN   DD DSN=&&LSTVTOC2,DISP=(OLD,DELETE,DELETE)
//SORTOUT  DD DSN=&&LVSORT2,DISP=(NEW,PASS,DELETE),UNIT=DISK,
//            SPACE=(CYL,(2,1),RLSE),
//            DCB=(RECFM=FB,LRECL=160,BLKSIZE=5920)
//SORTWK01 DD UNIT=DISK,SPACE=(CYL,2,,CONTIG)
//SORTWK02 DD UNIT=DISK,SPACE=(CYL,2,,CONTIG),SEP=SORTWK01
//SORTWK03 DD UNIT=DISK,SPACE=(CYL,2,,CONTIG)
//SORTWK04 DD UNIT=DISK,SPACE=(CYL,2,,CONTIG),SEP=SORTWK03
//SYSIN DD *
 SORT FIELDS=(55,6,CH,A,47,4,CH,A)
//*
//*
//*
//LSTVTOC3 EXEC PGM=LSTVTOC3
//STEPLIB  DD DSN=SYS1.TECHLOAD,DISP=SHR
//SYSUDUMP DD SYSOUT=(A,,DUMP)
//PRINT1   DD SYSOUT=A
//INPUT1   DD DSN=&&LVSORT2,DISP=(OLD,DELETE,DELETE)
./ ADD NAME=MODPSWD  0100-02092-02092-1416-00028-00028-00000-BC0THOR
*       ***** TEMPORARILY REMOVE FILE PASSWORD *****
*
*      TEMPORARILY REMOVES A FILE'S PASSWORD PROTECTION TO FACILITATE
* MULTIPLE FILE UPDATES. ALSO USED TO REPLACE THE PASSWORD WHEN ALL
* MAINTENANCE IS COMPLETE.
*
*     A PARM FIELD ON THE EXEC CARD SPECIFIES WHETHER THE PASSWORD
* IS TO BE REMOVED OR REPLACED. PARM=OFF IS USED TO REMOVE THE PASSWORD,
* WHILE PARM=ON IS USED TO RESET READ PASSWORD PROTECTION, AND PARM=WRT
* IS USED TO RESET PASSWORD PROTECTION FOR WRITE ONLY.
*
*     JCL REQUIREMENTS:
*
*     EXEC CARD FOR PGM=MODPSWD
*     SYSPRINT DD CARD FOR PRINTED MESSAGES
*     MODPSWD DD CARD FOR THE FILE WHOSE PASSWORD IS TO BE REMOVED OR
*                REPLACED. IF MORE THAN ONE FILE IS TO BE CHANGED IN
*                THE RUN, USE DDNAMES BEGINNING WITH MODPSWD, AND HAVING
*                UNIQUE FINAL CHARACTERS, SUCH AS MODPSWD1 MODPSWD2,
*                ETC.
*
*     JCL EXAMPLE:
*
*       //MAINT1 JOB (ACCTG),PGMNAME,CLASS= .....
*       //MODPSWD EXEC PGM=MODPSWD,PARM=OFF
*       //SYSPRINT DD SYSOUT=A
*       //MODPSWD DD DSN=PROTFILE,DISP=SHR
*
./ ADD NAME=MODSCB   0100-02092-02092-1416-00029-00029-00000-BC0THOR
*       ***** TEMPORARILY REMOVE FILE EXPIRATION DATE *****
*
*      MODSCB TEMPORARILY REMOVES A FILE'S EXPIRATION DATE TO FACILITATE
* MULTIPLE FILE UPDATES. ALSO USED TO SET THE EXPIRATION DATE TO 99/365
* WHEN MAINTENANCE IS COMPLETE.
*
*     A PARM FIELD ON THE EXEC CARD SPECIFIES WHETHER THE EXPIRATION DAT
* IS TO BE REMOVED OR RESET. PARM=LO IS USED TO REMOVE THE EXPIRATION
* DATE, WHILE PARM=HI IS USED TO SET IT TO 99/365. IF NO PARM FIELD IS
* SPECIFIED, THE EXPIRATION DATE IS REVERSED: SET TO 00/000 IF IT WAS
* 99/365, OR TO 99/365 IF IT WAS 00/000.
*
*     JCL REQUIREMENTS:
*
*     EXEC CARD FOR PGM=MODSCB
*     SYSPRINT DD CARD FOR PRINTED MESSAGES
*     MODSCB  DD CARD FOR THE FILE WHOSE EXPIRATION DATE IS TO BE
*                CHANGED. IF MORE THAN ONE FILE IS TO BE CHANGED IN
*                THE RUN, USE DDNAMES BEGINNING WITH MODSCB, AND HAVING
*                UNIQUE FINAL CHARACTERS, SUCH AS MODSCB1, MODSCB2,
*                ETC.
*
*     JCL EXAMPLE:
*
*       //MAINT1 JOB (ACCTG),PGMNAME,CLASS= .....
*       //MODSCB  EXEC PGM=MODSCB,PARM=LO
*       //SYSPRINT DD SYSOUT=A
*       //MODSCB  DD DSN=HIEXPDTE,DISP=SHR
*
./ ADD NAME=MODXREF  0100-88061-88061-1002-00036-00036-00000-USER02
            ***** INSTRUCTIONS FOR MODXREF *****

  THIS PROGRAM PRINTS A MODULE MAP SHOWING ALL CSECTS, THEIR LOCATIONS
AND LENGTHS, ENTRY POINTS WITHIN EACH CSECT AND LOCATION, AND ALL
REFERENCES TO OTHER EXTERNAL SYMBOLS FROM WITHIN A CSECT OR ENTRY
POINT.

  A PARM FIELD MAY BE USED TO ELIMINATE COBOL'S LIBRARY SUBROUTINES
FROM PRINTING, TO SHOW ONLY THE APPLICATION COMPONENTS. THE PARM
VALUE FOR THIS OPTION IS: PARM='NOILB'.

  DD CARDS USED:  SYSLIB   - ALLOCATES THE PDS CONTAINING THE MODULE(S)
                             TO BE CROSS-REFERENCED.RECFM=U ISHARD-
                             CODED.
                  SYSPRINT - PRINTED OUTPUT. RECFM=FBA,LRECL=80 IS
                             HARD-CODED.
                  SYSIN    - CONTROL CARD INPUT. RECFM=FB,LRECL=80
                             IS HARD-CODED.

   CONTROL CARDS: ENTER ONE CARD PER MODULE TO BE CROSS-REFERENCED.
                  THE CARD MUST CONTAIN THE MEMBER NAME OF THE
                  MODULE LEFT JUSTIFIED IN COLUMNS 1-8 WITH
                  TRAILING BLANKS IF LESS THAN 8 CHARACTERS.

  JCL FOR EXECUTION:

//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//XREF EXEC PGM=MODXREF,PARM='NOILB'
//STEPLIB DD DSN=TEST.LOAD,DISP=SHR
//SYSUDUMP DD SYSOUT=A
//SYSPRINT DD SYSOUT=A,DCB=BLKSIZE=80
//SYSLIB DD DSN=TEST.LOAD,DISP=SHR
//SYSIN DD *
DXT0025W
./ ADD NAME=PDSPGMS  0101-99126-99126-1418-00286-00286-00000-BC0THOR
                       ====> COBLSETY <====
  READS THE SORTED OUTPUT FILES FROM CSECTLST AND COBLTYPE AND MATCHES
  THEM ON CSECT NAME. WHEN A MATCH IS FOUND, INFORMATION IN THE
  COBLTYPE FILE IS ADDED TO THE CSECTLST FILE RECORD. OUTPUT FILE
  CONTAINS ONE RECORD FOR EACH RECORD IN THE CSECTLST FILE.
  INPUT1 SPECIFIES THE FILE CREATED BY THE CSECTLST PROGRAM
  INPUT2 SPECIFIES THE FILE CREATED BY THE COBLTYPE PROGRAM


                       ====> COBLSUBR <====
  READS FILE OF LOAD LIBRARY CSECT DATA CREATED BY PROGRAM CSECTLST
  AND WRITES A FILE WHICH CAN BE USED TO PRINT THE SUBROUTINE INFO
  LISTING. OUTPUT FROM THIS PROGRAM IS ONE RECORD FOR EACH CSECT WHOSE
  NAME DOES NOT BEGIN WITH "ILB". EACH RECORD CONTAINS THE DSNAME, THE
  THE CSECT NAME, THE MEMBER NAME, AND TWO INDICATORS THAT SHOW
  WHETHER THE MEMBER CONTAINS ANY "ILB" CSECTS AND WHETHER THIS IS A
  MAIN ENTRY POINT OR A SUBROUTINE WITHIN THE MODULE. THE OUTPUT FILE
  IS INTENDED TO BE SORTED IN CSECT ORDER AND WILL THEN BE INPUT TO
  PROGRAM COBSUBPT.


                       ====> COBLTYPE <====
  READS A LOAD MODULE AND PRINTS ONE LINE PER COBOL CSECT SHOWING THE
  MEMBER NAME, CSECT NAME, COBOL VERSION USED TO COMPILE, AND COMPILE
  DATE. FILES USED:
      DDNAME SYSLIB: RECFM=U. INPUT LOAD MODULE LIBRARY.
      DDNAME SYSOUT: RECFM=FB,LRECL=80  OUTPUT FILE OF CSECT DATA


                       ====> COBRDLST <====
  READS THE LISTING FILE OUTPUT FROM COBREAD AND WRITES 3 FILES:
    OUTPUT1: CONTAINS ONE RECORD FOR EACH MEMBER THAT CONTAINS ANY
             COBOL CSECT COMPILED WITH NORES. EACH RECORD HAS THE
             MEMBER NAME, "NORES", AND TYPES OF COBOL CSECTS FOUND,
             "VS" AND/OR "C2"
    OUTPUT2: CONTAINS ONE RECORD FOR EACH VS COBOL CSECT. EACH RECORD
             CONTAINS MEMBER NAME, CSECT NAME, "NORES" OR "     " AND
             "VS".
    OUTPUT3: CONTAINS ONE RECORD FOR EACH NON-COBOL CSECT. EACH RECORD
             CONTAINS MEMBER NAME, CSECT NAME, AND "NON-COBOL"


                       ====> COBREAD <====
  PART OF THE COBREAD PACKAGE FROM CBT MODS TAPE FILE200
  OTHER PARTS OF THIS PACKAGE INCLUDE MACROS CENTER, SYMREGS, AND
  RETRN; INSTRUCT MEMBER COBREAD0, AND ASM SOURCE PROGRAMS COBFMT,
  AND COBREAD
         SEARCH A PDS AND REPORT ON THE ATTRIBUTES
         OF EACH LOAD MODULE CREATED BY COBOL.
         OPTIONALLY READ AND REPORT ON A SINGLE MEMBER OF
         A PDS, TRIGGERED BY PRESENCE OF A PARM (MEMBER NAME)
         THIS VERSION SUPPORTS THE FOLLOWING COBOL COMPILERS
              ANSI VERSION 4, COBOL OS/VS.
         FOR EACH MEMBER, THE FOLLOWING IS LISTED
             BY THE FORMATTER SUBROUTINE COBRPT
                IS PROGRAM MARKED EXECUTABLE
                IS IT COBOL?
                IS IT OBJ360 OR OBJ370
                IS COBOL /TEST/ OPTION SPECIFIED
                IS COBOL /FLOW/ OPTION SPECIFIED
                IS COBOL /STATE/ OPTION SPECIFIED
                IS COBOL /SYMDUMP/ OPTION SPECIFIED
                IS COBOL /RESIDENT/ OPTION SPECIFIED    3/79
                IS COBOL /ENDJOB/ OPTION SPECIFIED
                WAS COBOL /OPTIMIZE/ OPTION SPECIFIED
                WAS CA-OPT OPTIMIZE SPECIFIED
                WAS CA-OPT DTECT OR XCOUNT SPECIFIED  - CA-OPT ONLY
                WAS COBOL V4 OR OS/VS COBOL UTILIZED FOR COMPILE
                WAS COBOL /COUNT/ OPTION SPECIFIED    - VS ONLY
                WAS COBOL /TRACE/ VERB SPECIFIED      - VS ONLY
                DATE LINKEDITED
         MODIFIED 3/10/80
         -     ADDED ADDITIONAL CHECK FOR NON-EXECUTABLE, NOW
               SEPARATES NON-EXEC FROM OTHER LOAD FAILURES
         -     ADDED ADDITIONAL SUMMARY INFORMATION PRINT FROM
               COBFMT
         -     CORRECTED MINOR BUGGIES
         MODIFIED 06/01/90  TCC
         -     ADDED SYSTOT DD FOR PRINTING TOTALS (INSTEAD OF
               SYSPRINT)
         -     ADDED BYPASS FOR "DFH" CSECTS (CICS)
         MODIFIED 07/01/91  TCC
         -     ADDED BYPASS FOR RMODE ANY MODULES (S0C4 ABENDS)
         MODIFIED 06/24/93  FHSC
         -     CHANGED RMODE AND AMODE TO ACCESS 31-BIT MODULES
               CHANGED HEADINGS TO MAKE "FIND" CMDS EASIER WHEN
               VIEWING OUTPUT
         MODIFIED 09/27/95  FHSC
         -     CHANGED TO SUPPORT VS COBOL II, HEADING CHANGES
               FOR VS COBOL II OPTIONS
         JCL REQUIREMENTS
           //S1 EXEC PGM=COBREAD,PARM='MEMNAME'   PARM IS OPTIONAL
           //SYSTOT    DD  SYSOUT=*      FOR THE TOTALS
           //SYSPRINT  DD  SYSOUT=*      FOR THE REPORT
           //PDS   DD  DSN=SYPP.PGMLIB,DISP=SHR   PDS TO ANALYZE


                       ====> COBSUBEM <====
  READS FILE OF LOAD LIBRARY CSECT DATA CREATED BY PROGRAM COBLSUBR
  AFTER IT IS SORTED IN CSECT ORDER. CSECTS NAMED $PRIVATE OR BLANKS
  ARE DROPPED. OTHER CSECTS ARE ALSO IGNORED IF THEY AREN'T INCLUDED
  IN AT LEAST ONE MEMBER WHERE THEY ARE NOT THE MAIN ENTRY POINT. A
  CSECT IS CONSIDERED TO BE A SUBROUTINE WHEN IT IS INCLUDED IN AT
  LEAST ONE MEMBER IN WHICH IT IS NOT THE INITIAL ENTRY POINT. FOR
  EACH "SUBROUTINE" FOUND, IF THERE IS NO MEMBER IN WHICH THE CSECT
  IS THE INITIAL ENTRY POINT A MESSAGE IS PRINTED QUESTIONING THE
  ORIGIN OF THE SUBROUTINE. IF ANY MEMBER IS FOUND IN WHICH THE CSECT
  IS THE INITIAL ENTRY POINT AND IN WHICH ILB MODULES ARE FOUND, A
  WARNING MESSAGE IS PRINTED INDICATING THE SUBROUTINE WAS NOT LINK
  EDITED WITH NCAL.
  A LIBRARY CONTAINING ENDEVOR SYSTEM ID'S IS READ AND STORED. FOR
  EACH LINE PRINTED, THE ENDEVOR SYSTEM ID IS PRINTED, IF FOUND.
  IF A PARM IS INCLUDED ON THE JCL EXEC STATEMENT, A SUMMARY REPORT
  IS GIVEN, SHOWING ONLY ONE LINE PER SUBROUTINE. WITH NO PARM, THE
  REPORT SHOWS ONE LINE FOR EACH SUBROUTINE PLUS ONE LINE FOR EACH
  PROGRAM THAT USES THE SUBROUTINE.
  THE PRINT DATA IS ALSO WRITTEN TO A FILE WHICH CAN BE EDITED TO MAKE
  CORRECTIONS. NO HEADING RECORDS ARE WRITTEN TO THIS FILE,


                       ====> CSECTLST <====
  READS A CONTROL CARD INPUT DATASET. EACH 80-BYTE INPUT RECORD HAS
  A MEMBER NAME IN COLUMNS 1-8. FOR EACH CONTROL CARD MEMBER NAME:
   .ISSUES A BLDL TO THE SYSLIB DATASET TO OBTAIN THE DIRECTORY ENTRY.
   .READS THE LOAD MODULE DATA RECORDS TO BUILD A SYMBOL TABLE.
   .WRITE ONE OUTPUT RECORD FOR EACH CSECT GIVING DSNAME OF THE SYSLIB
    DATASET, MEMBER NAME, CSECT NAME, LENGTH, LANGUAGE, AND AN
    INDICATOR SHOWING WHETHER THIS IS THE ENTRY POINT CSECT OF THE
    MEMBER. OUTPUT FILE IS INTENDED TO BE INPUT TO PROGRAM COBLSUBR.
  FILES USED BY THIS PROGRAM INCLUDE THE FOLLOWING:
      DDNAME SYSIN:    RECFM=FB,LRECL=80 - INPUT CONTROL CARD FILE.
      DDNAME SYSLIB:   RECFM=U. INPUT LOAD MODULE LIBRARY.
      DDNAME SYSOUT:   RECFM=FB,LRECL=80 - MODULE/CSECT RECORDS.
      DDNAME SYSPRINT: RECFM=FBA,LRECL=133 - MESSAGES


                       ====> FINDCALL <====
  FIRST, A CONTROL FILE CONTAINING MEMBER NAMES IS READ AND STORED
  FOR SEARCHES. NEXT, EACH DIRECTORY ENTRY OF THE INPUT PDS FILE
  IS READ USING THE READDIR SUBROUTINE. A FIND MACRO LOCATES THE
  MEMBER, WHICH IS THEN READ USING BPAM READS. THE CESD RECORDS
  ARE PROCESSED TO FIND ALL EXTERNAL REFERENCES MATCHING ANY ENTRY
  IN THE CONTROL TABLE. THE OUTPUT FILE CONTAINS ONE RECORD PER
  FOR EACH EXTERNAL REFERENCE MATCHING A CONTROL TABLE ENTRY.


                       ====> FINDCONT <====
  THIS PROGRAM READS THE DIRECTORY ENTRIES OF AN INPUT PDS
  USING THE SUBROUTINE READDIR, ISSUES A FIND MACRO USING THE
  TTR OF THE MEMBER, AND READS THE LOAD MODULE. THE CESD RECORDS
  ARE PROCESSED TO FIND ALL INCLUDED CSECTS. PROCESSING
  STOPS FOR A MEMBER WHEN THE FIRST CONTROL RECORD IS READ.
  THE OUTPUT FILE CONTAINS ONE RECORD PER MEMBER FOR EACH
  INCLUDED CSECT WITH MEMBER, CSECT, AND CSECT LENGTH.


                       ====> FINDSUBR <====
  THIS PROGRAM READS THE DIRECTORY ENTRIES OF AN INPUT PDS
  USING THE SUBROUTINE READDIR, ISSUES A FIND MACRO USING THE
  TTR OF THE MEMBER, AND READS THE LOAD MODULE. THE CESD RECORDS
  ARE PROCESSED TO FIND ALL EXTERNAL REFERENCES. PROCESSING
  STOPS FOR A MEMBER WHEN THE FIRST CONTROL RECORD IS READ.
  THE OUTPUT FILE CONTAINS ONE RECORD PER MEMBER FOR EACH
  EXTERNAL REFERENCE, WITH CALLING AND CALLED MODULE NAMES.


                       ====> ILBCHECK <====
        A CONTROL CARD IS READ FROM THE //SYSIN DD FILE. THE CONTROL
  CARD CONTAINS THE NAME OF A MEMBER IN THE //SYSLIB DD FILE THAT
  IS TO BE CHECKED.
        NEXT, THE MEMBER IS READ FROM THE SYSLIB LIBRARY, AND EACH
  CSECT IS CHECKED. IF THE CSECT NAME BEGINS WITH ILB IT IS USED
  AS AN ARGUMENT TO SEARCH THE INTERNAL TABLE OF ILB..... SUBROUTINES
  AND THE LENGTHS ARE COMPARED. IF THE CSECT CONTAINED IN THE MEMBER
  IS THE SAME AS THAT IN THE TABLE, IT IS ASSUMED TO BE A VALID
  CURRENT MODULE. IF THE LENGTHS DIFFER, THE ILB..... SUBROUTINE IN
  THE MEMBER IS ASSUMED TO BE AN OLD VERSION, AND A MESSAGE IS
  WRITTEN TO SHOW THE MEMBER NAME, ILB..... NAME, AND SIZES FROM THE
  MODULE AND THE TABLE.
  PURPOSE: TO AID PROGRAMMERS IN IDENTIFYING POTENTIAL MIXTURES OF
  OLD AND NEW COBOL ILB..... MODULES, WHICH WILL RESULT IN VARIOUS
  EXECUTION TIME ABENDS INCLUDING S0C1, S0C2, AND S0C4.


                       ====> LKEDCNTL <====
 THIS PROGRAM PRINTS A MODULE MAP SHOWING ALL CSECTS, THEIR LOCATIONS
 AND LENGTHS, ENTRY POINTS WITHIN EACH CSECT AND LOCATION, AND ALL
 REFERENCES TO OTHER EXTERNAL SYMBOLS FROM WITHIN THE CSECT OR ENTRY
 POINT. IT ALSO CREATES A CONTROL STATEMENT OUTPUT THAT CAN BE USED AS
 INPUT TO THE LINKAGE EDITOR TO REBUILD THE LOAD MODULE.
 A LIST OF CSECTS TO BE REPLACED IS ENTERED VIA SYSUT1. LINKEDIT
 REPLACE STATEMENTS WILL BE GENERATED FOR ANY CSECT IN THIS LIST THAT
 IS FOUND IN THE MODULE.
   DD CARDS USED:  SYSLIB   - ALLOCATES THE PDS CONTAINING THE MODULES
                              TO BE CROSS-REFERENCED.RECFM=U IS
                              HARD-CODED.
                   SYSPRINT - PRINTED OUTPUT. RECFM=FBA,LRECL=80 IS
                              HARD-CODED.
                   SYSIN    - CONTROL CARD INPUT. RECFM=FB,LRECL=80
                              IS HARD-CODED.
                   SYSOUT   - LINK-EDIT CONTROL STATEMENT OUTPUT.
                              RECFM=FB.LRECL=80 IS HARD-CODED.
                   SYSUT1   - LIST OF CSECTS TO BE REPLACED. RECFM=FB,
                              LRECL=80 IS HARD-CODED. THIS FILE MUST
                              BE IN ASCENDING ORDER ON CSECT NAMES IN
                              COLUMNS 1-8
    CONTROL CARDS: ENTER ONE CARD PER MODULE TO BE CROSS-REFERENCED.
                   THE CARD MUST CONTAIN THE MEMBER NAME OF THE
                   MODULE LEFT JUSTIFIED IN COLUMNS 1-8 WITH
                   TRAILING BLANKS IF LESS THAN 8 CHARACTERS.


                       ====> LMODHIST <====
  THIS PROGRAM READS A CONTROL FILE TO OBTAIN THE MEMBER NAMES.
  FOR EACH MEMBER NAME SPECIFIED, A FIND MACRO IS ISSUED TO
  POSITION TO THE TEXT FOR THE MEMBER, AND THE MEMBER IS READ
  UNTIL A TYPE 2 IDR RECORD IS FOUND. THE LINK-EDIT DATE IS TAKEN
  FROM THE IDR RECORD AND PRINTED WITH THE MEMBER NAME. IF NO TYPE
  2 IDR RECORD IS FOUND, THE MEMBER NAME IS NOT PRINTED.


                       ====> LOADDIR <====
  PROGRAM TO READ THE DIRECTORY IN AN INPUT PDS AND PRINT A LISTING
  SHOWING THE MODULE NAME AND LENGTH IN HEX, ONE 80-BYTE LINE PER
  MODULE. INPUT PDS DDNAME IS INPUT1, PRINT DDNAME IS PRINT1.
  RECFM=FB,LRECL=80 IS HARD-CODED FOR PRINT1.


                       ====> MODULENG <====
  PROGRAM TO READ THE DIRECTORY IN AN INPUT PDS AND PRINT A LISTING
  SHOWING THE MODULE NAME AND LENGTH IN HEX.


                       ====> MODXREF <====
   THIS PROGRAM PRINTS A MODULE MAP SHOWING ALL CSECTS, THEIR LOCATIONS
 AND LENGTHS, ENTRY POINTS WITHIN EACH CSECT AND LOCATION, AND ALL
 REFERENCES TO OTHER EXTERNAL SYMBOLS FROM WITHIN THE CSECT OR ENTRY
 POINT. THIS FIRST LIST IS THE "REFERS TO" LISTING. A SECOND LISTING
 PRODUCED TO SHOW "REFERENCED BY" INFORMATION, IN WHICH ALL EXTERNAL
 SYMBOLS ARE LISTED WITH THE REFERENCING LOCATIONS GIVEN. PURPOSE OF
 THE PROGRAM IS TO AID IN DEVELOPMENT OF DOCUMENTATION OF LOAD MODULES
 HAVING COMPLICATED STRUCTURES WITH MANY INCLUDED PROGRAMS.
   A PARM FIELD MAY BE USED TO ELIMINATE COBOL'S LIBRARY SUBROUTINES
 FROM PRINTING, TO SHOW ONLY THE APPLICATION COMPONENTS. THE PARM
 VALUE FOR THIS OPTION IS: PARM='NOILB'.
   DD CARDS USED:  SYSLIB   - ALLOCATES THE PDS CONTAINING THE MODULES
                              TO BE CROSS-REFERENCED.RECFM=U ISHARD-
                              CODED.
                   SYSPRINT - PRINTED OUTPUT. RECFM=FBA,LRECL=80 IS
                              HARD-CODED.
                   SYSIN    - CONTROL CARD INPUT. RECFM=FB,LRECL=80
                              IS HARD-CODED.
    CONTROL CARDS: ENTER ONE CARD PER MODULE TO BE CROSS-REFERENCED.
                   THE CARD MUST CONTAIN THE MEMBER NAME OF THE
                   MODULE LEFT JUSTIFIED IN COLUMNS 1-8 WITH
                   TRAILING BLANKS IF LESS THAN 8 CHARACTERS.


                       ====> PDSDIR <====
  READS THE DIRECTORY OF THE PDS GIVEN BY THE INPUT1 DD CARD AND
  WRITES AN OUTPUT FILE CONTAINING ONE RECORD PER MEMBER WITH
  MEMBER NAME IN COLUMNS 1-8 AND BLANKS IN COLUMNS 9-80. THE OUTPUT
  FILE IS SPECIFIED BY THE OUTPUT1 DD CARD. RECFM=FB,LRECL=80 IS
  HARD-CODED FOR BOTH INPUT1 AND OUTPUT1.


                       ====> PDSDIRC <====
  PROGRAM TO READ THE DIRECTORY IN AN INPUT PDS AND PRINT A LISTING
  CONTAINING THE MEMBER NAME, TTR, MODULE SIZE, AMODE, RMODE, AND
  LINKEDIT ATTRIBUTES.


                       ====> PDSHIST <====
  THIS PROGRAM READS THE DIRECTORY OF A LOAD LIBRARY TO OBTAIN
  THE MEMBER NAMES. FOR EACH MEMBER FOUND, A FIND MACRO IS ISSUED
  TO POSITION TO THE TEXT FOR THE MEMBER, AND THE MEMBER IS READ
  UNTIL A TYPE 2 IDR RECORD IS FOUND. THE LINK-EDIT DATE IS TAKEN
  FROM THE IDR RECORD AND PRINTED WITH THE MEMBER NAME. IF NO TYPE
  2 IDR RECORD IS FOUND, THE MEMBER NAME IS NOT PRINTED.


                       ====> PDSINFO <====
  PROGRAM TO READ THE DIRECTORY OF A LOAD MODULE LIBRARY PDS AND WRITE
  A LISTING SHOWING VARIOUS INFORMATION ABOUT THE MEMBERS INCLUDING
  MEMBER NAME, LENGTH, ATTRIBUTES, ALIAS-OF NAME (IF MEMBER IS AN
  ALIAS)
./ ADD NAME=PDSREAD  0100-00056-00056-1101-00066-00066-00000-BC0THOR
This subroutine reads a PDS directory and the body of members and
returns the address of a storage area gotten in subpool 1 that
contains statistics and tabular member data. Statistics include
the number of directory entries, number of directory entries used,
number of active members in the directory, and number of deleted
members present in the body of the pds. Tabular data includes the
member name (blank if deleted member), TTR of the member, and an
indicator (A=alias, D=deleted member, blank=active member).

On entry, the caller supplies a field containing the DDNAME for the
PDS to be analyzed, and a fullword area to contain the address of
the data area returned. It is the responsibility of the caller to
free the returned data area, if necessary.

Storage subpool 111 is used for blocks read from the PDS during
processing, and also for the TTR-Name-Alias table that is built
during processing. Subpool 111 storage is freed after processing
is complete, so the caller should not use this subpool unless its
loss is acceptable following a call to this subroutine.

Sample call/processing:
(1) Call the PDSREAD subroutine
         .
         CALL  PDSREAD,(DDNAME,DATAADDR) CALL PDSREAD SUBROUTINE
         L     R5,DATAADDR               POINT TO RETURNED DATA AREA
         USING RETHDR,R5
         .
(2) Process the table of member names, TTR's, and alias indicators:
         .
         ZAP   TABLMEM,TABLMEM           ANY TABLE ENTRIES?
         BZ    EMPTYPDS                  NO
         LA    R6,MBRNTRY                POINT TO START OF TABLE
         USING MBRNTRY,R6
CHECKEND CLI   MBRNAME,X'FF'             END OF TABLE?
         BE    endtable                  YES, ALL THROUGH
         .                               process
         .                                 the
         .                                   table
         .                                     entry
         LA    R6,MBREND-MBRNTRY(R6)     STEP TO NEXT ENTRY
         B     CHECKEND                  LOOP TO PRINT TABLE
         .
(3) Parameter areas for the PDSREAD call:
         .
DATAADDR DC    A(0)                    ADDRESS OF PDSREAD DATA AREA
DDNAME   DC    CL8'LIBRARY'  DDNAME FOR THE PDS TO BE ANALYZED
         .
(3) DSECT for the data area returned by PDSREAD:
         .
RETHDR   DSECT ,             DATA AREA RETURNED BY PDSREAD
AREASTRT DC    A(0)             ADDRESS OF RETURNED DATA (SUBPOOL 1)
AREALEN  DC    A(0)             LENGTH OF GOTTEN STORAGE
HDRLENG  DC    AL2(TABLSTRT-RETHDR) OFFSET TO TABLE FROM AREA START
NTRYLENG DC    AL2(MBREND-MBRNTRY) LENGTH OF EACH TABLE ENTRY
DIRBLKS  DC    PL4'0'           NUMBER DIRECTORY BLOCKS TOTAL
USDBLKS  DC    PL4'0'           NUMBER DIRECTORY BLOCKS USED
ACTVMEM  DC    PL4'0'           NUMBER ACTIVE MEMBERS IN PDS
DELEMEM  DC    PL4'0'           NUMBER DELETED MEMBERS IN PDS
TABLMEM  DC    PL4'0'           NUMBER TABLE ENTRIES TOTAL
TABLSTRT EQU   *                BEGINNING OF NAME-TTR-ALIAS TABLE
MBRNTRY  DS    0CL12            TABLE ENTRY DESCRIPTION
MBRNAME  DS    CL8                 MEMBER NAME (BLANK IF DELETED)
MBRTTR   DS    XL3                 TTR TO START OF MEMBER
MBRALIAS DS    CL1                 A = ALIAS, D = DELETED, ELSE BLANK
MBREND   EQU   *                   END OF ENTRY
???????? CSECT                  ???????? = Your CSECT name
./ ADD NAME=PRNTMULT 0101-88061-88256-1340-00043-00043-00000-USER02
            ***** PRINT MULTI-FILE TAPE VOLUMES *****
*
*     PRNTMULT PRINTS THE FIRST THREE BLOCKS ON EACH FILE OF A MULTI-
* FILE TAPE REEL. ANY NUMBER OF FILES MAY BE CONTAINED ON THE
* INPUT VOLUME, LABELS MAY BE STANDARD OR OMITTED, FILES MAY
* BE OF ANY RECFM, LRECL AND BLKSIZE, AND THE VARIOUS FILES MAY
* HAVE DIFFERENT CHARACTERISTICS. A PRINT LINE FOR EACH DATASET SHOWS
* THE INPUT VOLUME SERIAL NUMBER (FROM THE INPUT1 DD CARD), FILE
* SEQUENCE NUMBER ON THE REEL, NUMBER OF BLOCKS, RECFM, AND BLKSIZE.
* RECFM IS SHOWN AS F IF ALL BLOCKS IN THE FILE ARE THE SAME SIZE
* EXCEPT POSSIBLY THE LAST ONE. RECFM=V FOR FILES IN WHICH THE FIRST
* TWO BYTES OF EACH BLOCK ARE EQUAL TO BLOCK LENGTH. RECFM=U IS
* PRINTED WHEN THE ABOVE CONDITIONS ARE NOT MET. BLKSIZE PRINTED
* IS THAT OF THE LONGEST BLOCK FOUND IN THE DATASET.
*
*      JCL TO EXECUTE PRNTMULT IS GIVEN BELOW. AN OPTIONAL PARM FIELD
* MAY BE GIVEN ON THE EXEC CARD TO PROVIDE THE ACTUAL NUMBER OF FILES
* ON THE INPUT TAPE, WHEN KNOWN. THIS SHOULD BE SPECIFIED, IF POSSIBLE,
* AS THE PROGRAM WILL READ INTO I/O ERRORS ON THE INPUT TAPE WHILE
* ATTEMPTING TO FIND ANOTHER DATASET AFTER THE LAST ACTUALLY RECORDED,
* AND WILL ABEND OR HAVE TO BE CANCELLED. IN THIS CASE, THE DATA IS
* GOOD, IT JUST CAUSES OPERATIONAL DIFFICULTIES. THE FILE COUNT IN
* THE PARM FIELD, WHEN SPECIFIED, MUST SHOW THE TOTAL NUMBER OF FILES
* EXISTING BETWEEN TAPE-MARKS ON THE INPUT TAPE. STANDARD LABELS ARE
* NOT RECOGNIZED AS LABELS BY THIS PROGRAM, BUT AS FILES: A STANDARD
* LABELLED TAPE WITH A SINGLE FILE HAS 3 FILES, A HEADER LABEL FILE,
* THE DATA FILE, AND A TRAILER LABEL FILE. THE PROGRAM WILL STOP
* WHEN THE NUMBER OF FILES SPECIFIED IN THE PARM FIELD HAS
* BEEN READ, EVEN IF MORE FILES ARE ON THE TAPE. THERE WILL BE
* NO WARNING SHOULD THIS OCCUR. THE PARM FIELD MUST BE A 1-4 DIGIT
* NUMBER, WHEN PROVIDED. THE INPUT1 DD CARD MUST BE FOR A MAGNETIC
* TAPE, AND THE LABEL=(1,NL) PARAMETER MUST BE CODED AS SHOWN.
*
*
//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//PRNTMULT EXEC PGM=PRNTMULT,PARM=8 <=== PARM IS OPTIONAL !!!!!
//STEPLIB DD DSN=TEST.LOAD,DISP=SHR
//SYSUDUMP DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//INPUT1 DD DSN=PTF7805.TAPE1,VOL=SER=002048,LABEL=(1,NL),DISP=OLD,
// UNIT=TAPE
./ ADD NAME=PRTPCH   0101-90215-95200-1032-00115-00116-00000-BC0THOR
                     *** INSTRUCTIONS FOR PRTPCH ***

 PRTPCH PRODUCES PDS LIBRARY LISTINGS. A CONCISE DIRECTORY LISTING
 MAY BE PRINTED, WHICH SHOWS MEMBER NAMES IN MULTIPLE COLUMNS TO
 REDUCE PAPER. MEMBERS MAY ALSO BE PRINTED, EITHER ALL MEMBERS, OR
 THOSE SELECTED BY CONTROL CARDS. THE MEMBER DATA OUTPUT MAY BE
 PRINTED OR PUNCHED. PRINTED OUTPUT HAS A HEADER FOR EACH MEMBER
 GIVING THE MEMBER NAME AND LIBRARY NAME. MEMBERS MAY BE SEPARATED
 BY A TRIPLE-SPACE, OR A NEW PAGE MAY BE USED FOR EACH MEMBER. THE
 "PUNCHED" OUTPUT WILL HAVE A ./ ADD NAME=CCCCCCCC CARD PRECEDING
 EACH MEMBER OUTPUT TO FACILITATE LOADING BY MEANS OF IEBUPDTE.

 JCL REQUIRED:

      //PRTPCH   EXEC PGM=PRTPCH,PARM='WXYZLLLLLLLLLLLLLLLLL'
      //STEPLIB  DD   DSN=SYS1.TECHLOAD,DISP=SHR
      //INPUT1   DD   DSN=LLLLLLLLLLLLLLLLL,DISP=SHR
      //SYSPRINT DD   SYSOUT=A,RECFM=FBA,LRECL=81,BLKSIZE=0
      //SYSOUT   DD   SYSOUT=B,RECFM=FB,LRECL=80,BLKSIZE=0
      //SYSIN    DD   *
      MEMBER1,MEM2,MBR3,MEMBR4,M5


      THE PARM FIELD OF THE EXEC STATEMENT IS USED AS FOLLOWS:
          W = Y IF PRINT IS DESIRED, N IF OUTPUT IS NOT TO BE PRINTED
          X = Y IF PUNCH IS DESIRED, N IF OUTPUT IS NOT TO BE PUNCHED
          Y = D FOR DIRECTORY LISTING, A FOR ALL MEMBERS, C IF MEMBER
              NAMES ARE SUPPLIED VIA SYSIN
          Z = P FOR EACH MEMBER ON A NEW PAGE, T FOR TRIPLE-SPACE
              BETWEEN MEMBERS
          LLLLLLLLLLL = PDS LIBRARY NAME FOR PRINT HEADINGS

      STEPLIB DD CARD POINTS TO LIBRARY CONTAINING THE PRTPCH PROGRAM

      INPUT1 DD CARD SPECIFIES THE INPUT PDS LIBRARY TO BE LISTED. THE
             LIBRARY MUST HAVE FIXED (BLOCKED OR UNBLOCKED) RECORDS 80
             BYTES LONG.

      SYSPRINT DD CARD SPECIFIES DESTINATION FOR PRINTED OUTPUT. THE
             RECFM MAY BE F, FA, FB, OR FBA. IF FA OR FBA IS USED THE
             FIRST BYTE OF THE PRINT LINES WILL BE AN ASA CONTROL
             CHARACTER AND LRECL SHOULD BE 81. FOR REFCM=F OR FA, LRECL
             SHOULD BE 80. BLKSIZE CAN BE 0 OR A MULTIPLE OF LRECL.
             THIS DD STATEMENT MAY BE OMITTED IF THE FIRST PARM BYTE
             IS N.

      SYSOUT DD CARD SPECIFIES THE DESTINATION FOR PUNCHED OUTPUT. THE
             RECFM MUST BE F OR FB, LRECL MUST BE 80, AND BLKSIZE MAY
             BE ZERO OR A MULTIPLE OF 80. THIS DD STATEMENT MAY BE
             OMITTED IF THE SECOND PARM BYTE IS N.

      SYSIN DD CARD IS USED TO ENTER CONTROL CARDS SPECIFYING THE PDS
             MEMBERS TO BE OUTPUT. THE FILE MUST BE RECFM=F,LRECL=80,
             BLKSIZE=80. THIS CARD MAY BE OMITTED IF THE THIRD PARM
             FIELD BYTE IS A OR D.

      MEMBER NAME CARD FORMAT: IF COLUMN 1 = *, THE CARD IS IGNORED AS
             A COMMENT. MEMBER NAMES MAY BE ENTERED ONE OR MORE PER
             CARD, AND ANY NUMBER OF CARDS MAY BE USED FOR A RUN.
             MEMBER NAMES MAY BE SPECIFIED IN ANY ORDER. WHEN MORE THAN
             ONE NAME IS ENTERED, SEPARATE NAMES WITH COMMAS, BUT NO
             SPACES. THE FIRST BLANK COLUMN TERMINATES CONTROL CARD
             PROCESSING. MEMBER NAMES MUST BEGIN IN COLUMN 1, AND MAY
             USE ALL COLUMNS TO AND INCLUDING COLUMN 80.

      HERE IS A SAMPLE PROC WHICH COULD BE USED WITH PRTPCH:
        //PRTLIB PROC PRT=Y,PUN=N,MEM=A,SEP=T,LIBRY='PROD.PROC'
        //PRTLIB EXEC PGM=PRTPCH,PARM='&PRT&PUN&MEM&SEP&LIBRY'
        //STEPLIB  DD DSN=BC0THOR.LOAD.LOAD,DISP=SHR
        //SYSUDUMP DD SYSOUT=A
        //SYSPRINT DD SYSOUT=A,RECFM=FBA,LRECL=81,BLKSIZE=0
        //SYSOUT   DD DSN=BC0THOR.TST.PRTPCH.SYSOUT,DISP=(,CATLG),
        //         UNIT=DISK,SPACE=(TRK,(15,5),RLSE),
        //         RECFM=FB,LRECL=80,BLKSIZE=0
        //SYSIN    DD DUMMY
        //INPUT1   DD DSN=&LIBRY,DISP=SHR

             THE ABOVE PROC HAS SYMBOLIC PARAMETERS WHICH MAY
             BE OVERRIDDEN FOR OTHER OPTIONS. THESE ARE:

               PRT= : SPECIFY Y TO PRINT, N FOR NO PRINT

               PUN= : SPECIFY Y FOR "PUNCHED" OUTPUT, N FOR NO PUNCH

               MEM= : SPECIFY A FOR ALL MEMBERS, C FOR MEMBER NAMES
                      IN CONTROL CARDS, D FOR A DIRECTORY LISTING.

               SEP= : SPECIFY P FOR PAGE SEPARATION BETWEEN PRINTED
                      MEMBERS, T FOR TRIPLE-SPACING BETWEEN MEMBERS.

               LIBRY= : SPECIFY THE NAME OF THE PDS LIBRARY TO BE USED
                        AS INPUT. THE DSNAME GIVEN WILL BE USED IN THE
                        INPUT1 DD CARD, AND WILL BE PRINTED ON THE
                        HEADING LINE OF EACH MEMBER IF PRINTED OUTPUT
                        IS REQUESTED.

      PROC USAGE EXAMPLES: (A JOB CARD IS REQUIRED, OF COURSE)

           1. PRINT ALL MEMBERS OF PROD.PROC, TRIPLE SPACE BETWEEN
              MEMBERS.
              //PRTPROC EXEC PRTLIB,LIBRY='PROD.PROC'


           2. PRINT ALL MEMBERS OF PROD.PROC, USE A NEW PAGE FOR EACH
              MEMBER.
              //PRTPROC EXEC PRTLIB,SEP=P,LIBRY='PROD.PROC'

           3. PRINT DXT0325P, DSS0010P, AND RXR0340P ON USER99.LIB.COBOL
              WITH A NEW PAGE FOR EACH MEMBER
              //PRTCOBL EXEC PRTLIB,LIBRY='USER99.LIB.COBOL',MEM=C,SEP=P

           4. PRINT A DIRECTORY LISTING OF PROD.FILEDESC
              //PRTDIR  EXEC PRTLIB,MEM=D,LIBRY='PROD.PROC'


./ ADD NAME=QWIKVTOC 0100-02092-02092-1416-00025-00025-00000-BC0THOR
  THE JFCB IS READ FOR DDNAME VTOC. THE DSNAME FIELD OF THE JFCB IS
  SET TO HEX 04'S TO CAUSE THE VTOC TO BE ALLOCATED. THE VTOC IS READ,
  ONE HUNDRED DSCB'S AT A TIME, USING AN EXCP COMMAND CHAIN, UNTIL
  END OF EXTENT IS REACHED.

  ONE LINE IS WRITTEN TO SYSPRINT FOR EACH FORMAT 1 DSCB FOUND. DATA
  PROVIDED INCLUDES THE DATASET NAME, CREATION DATE, NUMBER EXTENTS,
  DATASET ORGANIZATION, RECORD FORMAT, LOGICAL RECORD LENGTH, AND
  BLOCK SIZE.

  FILES USED:
    VTOC:     THIS DDNAME PROVIDES ALLOCATION TO THE VOLUME WHOSE VTOC
              IS TO BE LISTED.
    SYSPRINT: THE OUTPUT DATASET. RECFM=FB,LRECL=80 IS HARD-CODED.

  CLIST USED TO EXECUTE ON TSO:

     PROC 1 VOLID U(3350)
     FREE F(VTOC)
     IF &VOLID = TSOWK4 OR &VOLID = TSOWK5 THEN SET &U = SYSTS
     ALLOC F(VTOC) DA('&SYSPREF..PK&VOLID') NEW TRACK VOLUME(&VOLID) -
     SP(0) DELETE UNIT(&U)
     CALL 'SYS1.CMDLIB(QWIKVTOC)'
     FREE F(VTOC)
     END
./ ADD NAME=RCVRPDS  0100-88061-88061-1009-00045-00045-00000-USER02
                      READ CLOBBERED PDS AND SAVE DATA

   READ A PDS WHOSE DIRECTORY HAS BEEN CLOBBERED, AND WRITE THE DATA
   RECORDS OUT TO A SEQUENTIAL FILE FOR FURTHER PROCESSING AND
   RECONSTRUCTION.

   THE DAMAGED PDS IS READ BLOCK BY BLOCK USING EXCP. EACH BLOCK IS
   CHECKED TO INSURE THAT IT IS A MULTIPLE OF 80 BYTES IN LENGTH, AND
   IF IT IS NOT, AN ERROR MESSAGE IS WRITTEN TO THE SYSPRINT DATASET,
   AND THE JOB TERMINATES ABNORMALLY WITH USER ABEND CODE 333. GOOD
   DATA BLOCKS ARE UN-BLOCKED AND WRITTEN TO THE SYSOUT DATASET IN
   THE ORDER READ IN. AN IEBUPDTE ADD CONTROL RECORD IS WRITTEN
   AS THE FIRST RECORD OF EACH MEMBER WRITTEN TO THE SEQUENTIAL
   SYSOUT FILE.

   WHEN AN END-OF-FILE RECORD IS READ, AN INDICATOR IS SET SO THAT
   A ./ ADD NAME=MBRNNNNN RECORD WILL BE WRITTEN TO THE SYSOUT
   DATASET BEFORE THE NEXT RECORD IS WRITTEN FROM THE SYSIN DATASET.
   THIS APPROACH PERMITS A CODE CHANGE TO BASE THE NAME= PARAMETER
   OF THE ./ ADD RECORD ON DATA IN THE FIRST RECORD OF THE NEW MEMBER
   IF DESIRED. THE DEFAULT MEMBER NAME MBRNNNNN IS MADE UP OF THE
   PREFIXING LETTERS "MBR" FOLLOWED BY A 5-DIGIT NUMBER WHICH STARTS
   AT ONE FOR THE FIRST MEMBER, AND IS INCREMENTED BY ONE FOR EACH
   SUCCEEDING MEMBER.

   JCL REQUIREMENTS ARE AS FOLLOWS:
     SYSPRINT : MESSAGE OUTPUT. SPECIFY BLKSIZE A MULTIPLE OF 80
     SYSIN    : THE DAMAGED INPUT PDS
     SYSOUT   : THE SEQUENTIAL OUTPUT DATASET WHICH WILL CONTAIN THE
                RECORDS RECOVERED FROM SYSIN. SPECIFY BLKSIZE A
                MULTIPLE OF 80


   EXAMPLE JCL:

//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//SEQEXCP  EXEC PGM=RCVRPDS
//STEPLIB  DD   DSN=TEST.LOAD,DISP=SHR
//SYSPRINT DD   SYSOUT=*
//SYSUDUMP DD   SYSOUT=*
//ABNLDUMP DD   DUMMY
//SYSIN    DD   DSN=USER02.TSO.DATA,DISP=SHR
//SYSOUT   DD   DSN=USER02.TSO.SYSOUT,DISP=OLD
./ ADD NAME=READDIR  0100-02092-02092-1416-00034-00034-00000-BC0THOR
         ***** READDIR - READ DIRECTORY OF PDS *****

  PROGRAM TO READ THE DIRECTORY IN AN INPUT PDS AND RETURN
  ENTRIES TO THE CALLING PROGRAM. EACH 11 BYTE ENTRY RETURNED IS
  COMPOSED OF AN 8 BYTE MEMBER NAME FOLLOWED BY THE 3 BYTE TTR
  ADDRESS OF THE BEGINNING OF THE MEMBER. THE USER MUST FIRST
  CALL READDIR TO OPEN THE PDS, THEN ISSUE CALLS TO READ. FINALLY,
  A CALL TO CLOSE THE PDS SHOULD BE MADE.


    COBOL EXAMPLE TO OPEN THE PDS FOR DDNAME INPUT1 (AN INPUT1 DD CARD

          MUST BE INCLUDED IN THE EXECUTION JCL):
            WORKING STORAGE: 77 OPEN-PARM PIC X(9) VALUE 'OINPUT1'.
            PROCEDURES:      CALL 'READDIR' USING OPEN-PARM.


    COBOL EXAMPLE TO READ A DIRECTORY ENTRY:

          WORKING STORAGE: 77 READ-PARM PIC X VALUE 'R'.
                           01 DIRECTORY-RECORD.
                                04 MEMBER-NAME.
                                    08 FILLER PIC X.
                                      88 END-DIRECTORY VALUE HIGH-VALUE.
                                    08 FILLER PIC X(7).
                                04 MEMBER-TTR PIC XXX.
          PROCEDURES: CALL 'READDIR' USING READ-PARM, DIRECTORY-RECORD.
                      IF END-DIRECTORY ... (IMPERATIVE STATEMENT)


    COBOL EXAMPLE TO CLOSE THE PDS:

          WORKING STORAGE: 77 CLOSE-PARM PIC X VALUE 'C'.
          PROCEDURES:      CALL 'READDIR' USING CLOSE-PARM.
./ ADD NAME=READMEM  0100-02092-02092-1416-00061-00061-00000-BC0THOR
          ***** READMEM - SUBROUTINE TO READ MEMBER OF PDS *****

  SUBROUTINE TO FIND, READ, AND PASS RECORDS FOR THE MEMBER OF A PDS
  TO THE CALLING PROGRAM. THE PDS MAY CONTAIN FIXED LENGTH OR VARIABLE
  RECORDS, BLOCKED OR UNBLOCKED. TO USE THE SUBROUTINE, AN OPEN CALL
  IS MADE FIRST, FOLLOWED BY A FIND CALL TO LOCATE THE DESIRED MEMBER.
  READ CALLS ARE THEN ISSUED, WHICH RETURN THE RECORDS IN THE MEMBER,
  ONE AT A TIME. WHEN END OF MEMBER IS REACHED, A HEX "FF" IS RETURNED
  IN THE FIRST BYTE OF THE RECORD AREA. AT THIS POINT, THE USER MAY
  ISSUE ANOTHER FIND CALL TO PROCESS ANOTHER MEMBER, OR A CALL TO
  CLOSE THE FILE.

  STANDARD LINKAGE CONVENTIONS ARE USED WITH THE FOLLOWING PARAMETERS:

  OPEN - FIRST POSITION IS O, NEXT 8 ARE DDNAME. THE DDNAME MUST BE
         THE SAME AS THE DDNAME ON THE DD CARD DEFINING THE PDS IN
         THE JCL FOR THE RUN. COBOL EXAMPLE WITH DDNAME INPUT1:

           WORKING STORAGE:  77 OPEN-PARM PIC X(9) VALUE 'OINPUT1'.
           PROCEDURES:       CALL 'READMEM' USING OPEN-PARM.

  FIND - FIRST POSITION IS F, NEXT IS T IF TTR IS SUPPLIED, OR N IF
         NAME IS SUPPLIED, NEXT 3 ARE TTR OF BEGINNING OF MEMBER FOR
         T REQUESTS, OR NEXT 8 ARE MEMBER NAME IF N IS REQUESTED.
         WHEN THE MEMBER NAME IS PROVIDED, A HEX "00" IS RETURNED
         IN THE FIRST POSITION OF MEMBER NAME IF THE MEMBER DOES
         NOT EXIST. IN THE EXAMPLES BELOW, THE CALLER MUST PLACE THE
         APPROPRIATE VALUE IN FIND-RELTRK OR FIND-MEMBER BEFORE CALLING
         THE READMEM SUBROUTINE.

         COBOL EXAMPLE USING TTR:
            WORKING STORAGE: 01 FIND-TTR.
                                04 FILLER      PIC XX VALUE 'FT'.
                                04 FIND-RELTRK PIC X(3).
            PROCEDURES:      CALL 'READMEM' USING FIND-TTR.

         COBOL EXAMPLE USING MEMBER NAME:
            WORKING STORAGE: 01 FIND-NAME.
                                04 FILLER      PIC XX VALUE 'FN'.
                                04 FIND-MEMBER PIC X(8).
            PROCEDURES:      CALL 'READMEM' USING FIND-NAME.

  READ - FIRST PARAMETER IS R. SECOND PARAMETER IS AREA INTO WHICH THE
         RECORD IS TO BE RETURNED. THE RECORD AREA MUST BE LONG ENOUGH
         TO CONTAIN THE LONGEST RECORD TO BE READ. AT END OF MEMBER, A
         HEX "FF" IS RETURNED IN THE FIRST BYTE OF THE RECORD AREA.

         COBOL EXAMPLE USING 80-BYTE RECORDS:

           WORKING STORAGE: 77 READ-PARM PIC X VALUE 'R'.
                            01 MEMBER-RECORD.
                                 04 FILLER PIC X.
                                      88 MEMBER-END VALUE HIGH-VALUE.
                                 04 FILLER PIC X(79).
           PROCEDURES: CALL 'READMEM' USING READ-PARM, MEMBER-RECORD.
                       IF MEMBER-END ... (IMPERATIVE STATEMENT)

  CLOSE - FIRST PARAMETER IS C.
          COBOL EXAMPLE:
               WORKING STORAGE:   CLOSE-PARM PIX X VALUE 'C'.
               PROCEDURTES:       CALL 'READMEM' USING CLOSE-PARM.
./ ADD NAME=RENSCR   0100-88061-88061-1010-00046-00046-00000-USER02
*               *** RENAME AND SCRATCH PDS MEMBERS ***
*
*  RENAMES AND SCRATCHES MEMBERS ON PARTITIONED DATASETS. ADVANTAGES
*  OF THIS PROGRAM OVER IEHPROGM INCLUDE SIMPLER CONTROL CARDS, MULTIPLE
*  MEMBER NAMES PER CARD, AND DOES NOT REQUIRE SPECIFICATION OF DEVICE
*  TYPE AND VOLUME SERIAL NUMBER. IN ADDITION, IEHPROGM WILL NOT OPERATE
*  ON A DATASET WHICH IS OPEN FOR PROCESSING, WHICH CAUSES PROBLEMS
*  WHEN TRYING TO WORK WITH HEAVILY USED LIBRARIES SUCH AS SYS1.LINKLIB.
*
*  IF ANY ERROR IS FOUND WHILE PROCESSING A CARD, A MESSAGE IS PRINTED,
*  AND THE REST OF THE CARD IS IGNORED. IF ANY ERROR WAS FOUND DURING
*  THE RUN, THE CONDITION CODE IS SET TO 4, OTHERWISE IT WILL BE ZERO
*  AT TERMINATION.
*
*  CONTROL CARD FORMATS ARE AS FOLLOWS:
*
*  SCRATCH CARD -
*     COLUMN   1   = S
*     COLUMNS 2-70 = NAMES OF MEMBERS TO BE SCRATCHED, SEPARATED BY
*                    COMMAS. NO IMBEDDED BLANKS ARE PERMITTED, AS A
*                    BLANK TERMINATES PROCESSING FOR A CARD.
*  RENAME CARD -
*     COLUMN   1   = R
*     COLUMNS 2-18 = CURRNAME,NEWNAME WHERE CURRNAME IS THE CURRENT
*                    MEMBER NAME, AND NEWNAME IS THE NEW NAME FOR THE
*                    MEMBER. A COMMA MUST BE USED TO SEPARATE THE NAMES.
*  EXAMPLES -
*     SCRATCH MEMBERS IEALDOPC, ABAL, AND COLXIT:
*SIEALDOPC,ABAL,COLXIT
*     RENAME MEMBER HASJES20 TO OLDJES20:
*RHASJES20,OLDJES20
*
*
*  EXECUTION JCL:
*
//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//RENSCR EXEC PGM=RENSCR
//STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR
//PRINT1 DD SYSOUT=A,DCB=BLKSIZE=133
//LIBRARY DD DSN=PDS.LIBRARY,DISP=SHR
//READER1 DD *,DCB=BLKSIZE=80
SNOGOOD,MAY,BE,BAD,ROUTINES,BY,NAME
ROLDMEM,NEWMEM
/*
./ ADD NAME=RESOLVE  0100-02092-02092-1416-00433-00433-00000-BC0THOR
                 ***** RESOLVE COMMANDS BY FUNCTION *****

    ASID        CHA(Ops), CDE, CB, CSMON, DON(Ops), DU(TS), EQU, EXI(Ops), MON,
OKS(Ops), PRO,
                SRM, STA, TCB, TIO, TRT


    CONSOLE     CN(Ops), COM(Ops), CON, MCO(Ops), MTP, REP


    CONTROL BLOCKS CB, CDE, TCB, UCB


    CPU         CPU, PCPU, PI


    DASD        DV(TS), MOU(Ops), RES, SMS


    DEVICE      ALL(Ops), DEA(Ops), IO, LAB(Ops), MDEV, MTP, RES, SPA, TIO, TPI,
 UNL(Ops), USI


    DSNAME      APF(TS), DSN, DV(TS), ENQ, RES, TIO


    JOBNAME     CHA(Ops), CDE, CB, CSMON, DON(Ops), DU(TS), EQU, EXI(Ops), MON,
MTP, OKS(Ops),
                PRO, RES, SRM, STA, TCB, TER, TIO, TRT


    MEMORY      ASM, CSA, CSMON, CSSUM, DU(TS), EST, FCOMMON(TS), MS, RSM, ZAP(T
S)


    MODULE      LL(TS), LOA(TS), LPA, NUC


    PAGING      PAG


    PATH        MIO, MLC, MPA


    SYS1.DUMP   CLE(Ops), SD(Ops), SYS


    VOLSER      APF(TS), DV(TS), IO, MTP, RES, SPA, UNL(Ops)


    TS TOOLS    APF(TS), AUTHTSO(TS), DU(TS), DV(TS), FCOMMON(TS), LL(TS), LOA(T
S),
                SMFEXIT(TS), SVCF(TS), ZAP(TS)


    OPS TOOLS   AEW(Ops), ALL(Ops), CHA(Ops), CLE(Ops), CN(Ops), COM(Ops), DEA(O
ps), DEV(Ops),
                DON(Ops),EXI(Ops), LAB(Ops), MCO(Ops), MOU(Ops), OKS(Ops), RT(Op
s), SD(Ops),
                TRA(Ops), UNL(Ops)
                         ***** RESOLVE COMMANDS *****

    Repeat most recent command    *                             *

    Display most recent command   ?                             ?

    Start AEWS using PWSCPMxx     AEW,START,xx                  AEW,START,01
    Stop/start AEWS w/PWSCPMxx    AEW,MOD,xx                    AEW,MOD,00
    Stop Auto Warning System      AEW,STOP                      AEW,STOP
    List active AEWS samplers     AEW                           AEW
    List active sampler param's   AEW,samplername               AEW,SAMPL01
    Set max nondeletable AEWS     AEW,NR=n                      AEW,NR=0

    Allocate a device range to    ALL,cuu[-y]                   ALL,18C-4
       prevent MVS allocation

    List APF libraries            APF                           APF
    List APF libraries w/prefix   APF,dsn-prefix                APF,SYS1
    List APF libraries on volser  APF,,volser                   APF,SYS005
    Add new APF library           APF,dsn,volser,ADD            APF,FDR.LOADLIB,
SYS003,ADD
    Delete an APF library         APF,dsn,volser,DELETE         APF,SPP.RESOLVE,
MVS220,DELETE
    Restore NIP-created APF list  APF,RESTORE                   APF,RESTORE
    Change volser for APF library APF,dsn,volser,CHANGE,newvol  APF,SYS1.HELP,SY
STST,

CHANGE,SYS005

    Display aux storage and page  ASM[,MAP]                     ASM,MAP
       dataset information

    Display IKJTSO00 TSO lists    AU,LIST[,ALL,E2,E8,AP]        AU,LIST,E2
    Build IKJTSO00 TSO lists      AU,BUILD[,ALL,E2,E8,AP]       AU,BUILD,E8
    Restore IKJTSO00 TSO lists    AU,RESTORE[,ALL,E2,E8,AP]     AU,RESTORE

    Display control block         CB,block-name[(index)]        CB,JCT,JES2
       in hex and character          [,jobn/(asid)]

    Display modules for a job     CDE,jobn/(asid)               CDE,DXT0224U

    Change a job's dispatch prty  CHA,jobn/(asid)               CHA,DCT0030A

    Clear a SYS1.DUMP dataset,    CLE,id[,NOPROMPT]             CLE,09
       displays title, prompts

    Simulate MVS operator console CN                            CN
       PF3 exits, PF5 redisplays,
       ENTER refreshes display

    Execute MVS operator commands COM,command                   COM,$TJ205,P=15

    Display # undisplayed console CON                           CON
       messages

    Display cpu utilization by    CPU[,time]                    CPU,10
       job (30 sec default)

    Display CSA utilization       CSA[,MAP]                     CSA

    Display CSA storage by ASID   CSMON,MAP,ASIDxxxx            CSMON,MAP,ASID1
    Display CSA storage by job    CSMON,MAP,jobname             CSMON,MAP,RSM004
0W
    Display CSA/SQA Usage Stats   CSMON,STATUS                  CSMON,STATUS
    Display owner of CSA storage  CSMON,OWNER[,address]         CSMON,OWNER,0194
4100
    Display CSA by SUBPOOL, ASID  CSMON,SUBPOOLS,ASIDxxxx       CSMON,SUBPOOLS,A
SID7
    Display CSA by SUBPOOL, job   CSMON,SUBPOOLS,jobname        CSMON,SUBPOOLS,N
ET
    Display CSA summary (<>       CSMON,SUMMARY[,SQA/CSA/SQA</  CSMON,SUMMARY,SQ
A<,10
       (<> below-above 16M)          SQA>/CSA</,CSA>][,limit]

    Display CSA summary by job    CSSUM[,SQA/CSA/SQA</SQA>/     CSSUM,SQA,5
                                     CSA</CSA>][,limit]

    Deallocate range of devices   DEA,cuu,[-y]                  DEA,650-4
    Deallocate a device and take  DEA,cuu,[-y],OFF              DEA,651,OFF
       it offline. (Reverses the
       ALLOCATE command)

    Display deviation from        DEV[,xx]                      DEV
       SYS1.PARMLIB(CONFIGxx)

    Display domain table          DOM                           DOM

    Make a job non-swappable      DON,jobn/(asid)               DON,MKI3217A

    Display file info             DSN,dsn                       DSN,SYS1.LINKLIB

    Display memory. (Expression   DU,expression[/cpu#][,length] DU,23A4F,16,(1)
        may contain EQUATED name       [,jobn/(asid)]
       and/or *,+,-,%,? as in IPCS)   [,repetition][,offset]
    Display all symbols           DU,LIST                       DU,LIST

    Display a block at CCHHR      DV,CCHHR,volser,cccchhhhrr    DV,CCHHR,SYS004,
00E3000E02
    Display a DSCB for a dataset  DV,DSCB,volser,dsn            DV,DSCB,SYS003,F
EP.MASTER.FILE
    Display DASD dataset extents  DV,EXTENTS,volser,dsn         DV,EXTENTS,IMS00
1,IMSVS.RESLIB
    Display dsn's on disk by prfx DV,FILES,volser,dsn-prefix    DV,FILES,SYS002,
SYS1
    Display disk volume label     DV,LABEL,volser               DV,LABEL,SYS220
    Display blocks from a file    DV,DSN,volser,dsn[(member)]   DV,DSN,SYSTST,SY
S1.LINKLIB,3,1
                                      [,skip-count],[,display-count]

    Show enqueue conflicts        ENQ                           ENQ
    Show ALL enqueues for a file  ENQ,dsn                       ENQ,SYS1.DGTLLIB
    Show minor-major enqueues     ENQ[,minor-name],major-name   ENQ,Q4,SYSIEFSD

    Equate symbol to an address   EQU,@symbol-name,expression   EQU,@MYTCB,10???
,512
                                      [,length][,jobn/(asid)][,repetition][,offs
et]
    Delete an EQUATEd symbol      EQU,@symbol-name,DELETE       EQU,@MYTCB,DELET
E

    Display expanded storage use  EST[,MAP][,time]              EST,,10

    Execute LIB file member       EXE,member-name               EXE,MYCLIST

    Terminate a job after trying  EXI,jobn/(asid)               EXI,RXP0125W
       normal Cancel/Stop first)

    Free CSA or SQA gotten by a   FCOMMON,address,length,spid   FCOMMON,700040,1
44,231,0
       terminated job.                [,key]

    Help for a RESOLVE command    HEL,resolve-command-name      HEL,EXI

    Info on RESOLVE, MVS, and CPU IN                            IN

    Show jobs hung awaiting I/O   IO                            IO
    Outstanding I/O by device     IO,cuu                        IO,880
    Outstanding I/O by volser     IO,volser                     IO,SYS007

    Read, display a tape label    LAB,cuu[,EXT]                 LAB,650

    Lnklst libraries and extents  LL                            LL
    Lnklst lib's having a module  LL,module-name[,FIRST]        LL,IEBGENER
    Rebuild the linklist using    LL,BUILD,xx                   LL,BUILD,05
       SYS1.PARMLIB(LNKLSTxx)

    List modules added by LOA     LOA                           LOA
    Add LPA module from USERLIB   LOA,ADD,module-name           LOA,ADD,IEFSD060
    Delete module added by LOA    LOA,DEL,module-name           LOA,DEL,IEFSD060
    Free storage for a module     LOA,FREE,module-name          LOA,FREE,IEFSD06
0
       deleted by LOA

    Display lock ownership        LOC                           LOC

    Invoke and log RESOLVE cmds   LOG,xx                        LOG,00
       in member $$INLGxx of
       DDNAME LIB
    Stop automatic logging        LOG,STOP                      LOG,STOP
    Spin off SYSOUT for the log   LOG,FREE                      LOG,FREE

    Locate modules in LPA         LPA,module-name               LPA,IEFJRASP
    Locate next copy LPA module   LPA,module-name,SKIP          LPA,IEFJRASP,SKI
P
    Find LPA module from address  LPA,address,LOC               LPA,235C6D8,LOC

    Issue master console command  MCO,command                   MCO,DUMP COMM=(T
ESTING)

    I/O activity, all devices     MDEV[,,time]                  MDEV
    I/O activity, device range    MDEV,cuu[-cuu][,time]         MDEV,650-658,15

    Monitor all path activity     MIO[,,time]                   MIO,,10
    Monitor activity, path range  MIO,path[,-path][,time]       MIO,01,30

    Monitor control unit activity MLC[,,time]                   MLC
    Monitor control units range   MLC,path[-path][,time]        MLC,005-007,10

    Monitor a job for 30 seconds  MON,jobn/(asid)               MON,WKI9850Y

    Mount all DASD devices        MOU                           MOU

    Monitor I/O, all chan paths   MPA[,,time]                   MPA
    Monitor a channel path range  MPA,path[,path][,time]        MPA,30-3F,5

    Display virtual storage map   MS                            MS

    Show pending mount requests   MTP                           MTP

    Info on NUCLEUS CSECT by name NUC,csect-name                NUC,IEAVTRT1
    Info on NUCLEUS CSECT by addr NUC,address,LOC               NUC,11E3238,LOC

    Make a job swappable          OKS,jobn/(asid)               OKS,(128)

    Paging and swapping rates     PAG                           PAG

    List SYS1.PARMLIB members     PLIST,member-name             PLIST,LNKLST00

    CPU and partition usage       PCPU[,time]                   PCPU

    Display RESOLVE PFKEY use     PFK                           PFK
    Alter PFKEY nn for RESOLVE    PFK,nn,new-pfk-definition     PFK,21,CPU,10

    I/O interrupt activity by CPU PI[,time]                     PI,15

    Display job/job step status   PRO,jobn/(asid)               PRO,YKR0005A

    Start CMF-REALTIME services   RT,START                      RT,START
    Stop CMF-REALTIME services    RT,STOP                       RT,STOP
    Request CMF-REALTIME service  RT,rt-command                 RT,DSIO

    Show outstanding MVS replies  REP                           REP

    Display hardware reserves     RES                           RES

    Display use of real storage   RSM[,MAP]                     RSM,MAP

    Take an SVC dump of a job     SD,jobn/(asid)                SD,JES2

    Status of SMF Exits           SMFEXIT                       SMFEXIT
    Load an SMFEXIT               SMFEXIT,LOAD,exit-name,ddname SMFEXIT,LOAD,UJI
,USERLIB
    Delete an SMFEXIT             SMFEXIT,DELETE,exit-name      SMFEXIT,DELETE,U
JI
    Enable an SMFEXIT             SMFEXIT,ENABLE,exit-name      SMFEXIT,ENABLE,U
TL
    Disable an SMFEXIT            SMFEXIT,DISABLE,exit-name     SMFEXIT,DISABLE,
UTL

    SMS groups, status, space     SMS                           SMS
    SMS volumes for a group       SMS,,SG,group-name            SMS,,SG,SGTEST
    SMS Group names on a volume   SMS,,VOL,volser               SMS,,VOL,SM7002
    SMS status, all groups        SMS,ST                        SMS,ST
    Status of volumes for a group SMS,ST,SG,group-name          SMS,ST,SG,SGPROD
    Status of groups on a volume  SMS,ST,VOL,volser             SMS,ST,VOL,SM400
1

    SYS1.LOGREC software stats    SOF                           SOF
    LOGREC records for a module   SOF,module-name[,MAP][,yy.ddd] SOF,IGC0001I,MA
P
    LOGREC records for an errorid SOF,errorid[,MAP][,yyddd]     SOF,21333

    Free space on a device        SPA,cuu                       SPA,880
    Free space on a volume        SPA,volser                    SPA,SYS004
    Free space on a generic group SPA,generic-name              SPA,SYSTS

    System Resources Manager Data SRM[,MAP]                     SRM
    SRM data for a job            SRM,jobn/(asid)               SRM,(05)

    Active subsystems information SSVT                          SSVT

    Current status of active jobs ST[,,SHORT]                   ST,,SHORT
    List status of jobs in memory ST,IN                         ST,IN
    List status of TSO sessions   ST,TSO                        ST,TSO
    List status of a job          ST,jobn/(asid)                ST,RUX1077W

    Submit a job from DDNAME LIB  SUB,member-name               SUB,JOB1

    Information about unused SVCs SVCF                          SVCF
    Unused SVC info for a range   SVCF,type#,starting#[,ending#] SVCF,2,240,255
    Display all SVCs for a range  SVCF,LIST,starting#[,ending#] SVCF,LIST,240,25
5
    Display 1st 64 bytes of SVC's SVCF,DUMP,starting#[,ending#] SVCF,DUMP,103

    Titles of filled SYS1.DUMPs   SYS                           SYS

    TCB, RB's for a job           TCB,jobn/(asid)[,MAP][,address] TCB,QKZ0900P,M
AP

    Jobs in abnormal termination  TER                           TER

    Display date and time         TIM[,GMT]                     TIME

    DDNAMEs, VOLSERs, CUU, EXCPs  TIO,jobn/(asid)               TIO,DXT0230Y
    List above plus DSNAMES       TIO,jobn/(asid),MAP           TIO,USERZQ,MAP
    List above, if EXCPs>0        TIO,jobn/(asid),ACT           TIO,WKI0010A,ACT

    Display ALL outstanding I/O   TPI[,cuu]                     TPI,285

    Invoke tracking for $$INTKxx  TRA,xx[,CLASS/DSNAME]         TRA,24
    Start tracking all services   TRA,ALL                       TRA,ALL
    Terminate tracking            TRA,STOP                      TRA,STOP
    Dynam free tracking output    TRA,FREE                      TRA,FREE

    Summarize system trace table  TRT[,,jobn/(asid)]            TRT
    Display trace table detail    TRT,MAP[,jobn/(asid)]         TRT,MAP,H010932

    TSO users ID, ASID and NODE   TSU                           TSU

    Display a UCB for a device    UCB,cuu[,(exposure number)]   UCB,880
    Display a UCB for a volser    UCB,volser[,number of ucb's]  UCB,TSOWK5

    Force a DASD device to unload UNL,cuu                       UNL,882
    Force DASD unload by volser   UNL,volser                    UNL,SYS008

    Active jobs using a device    USI,cuu                       USI,890
    Active jobs using a volser    USI,volser                    USI,PROD35

    Display usage of VIO slots    VIO[,threshold]               VIO,5

    Modify main memory            ZAP,address[/cpu#],verdata,   ZAP,6E5d,47F0,47
80,WUT0004A
                                      repdata,[,jobn/(asid)]


                                 ***** SYNTAX NOTES *****

    RESOLVE commands may be entered at the TSO READY prompt, on the ISPF COMMAND
 screen, or
    from an MVS operator console. When entered from an MVS console, the commands
 must be
    preceded by F RES. For example, to use the CPU command with 30 seconds colle
ction time,
    you would enter F RES,CPU,30 from an MVS console.


    An interactive panel driven system is also available under TSO, and can be a
ccessed using
    the M choice for the MVS PERFORMANCE MANAGER. On the initial screen, choose
option 2 for
    RESOLVE, and then choose option 1 for SERVICES. Scroll through the list of s
ervices
    using PFK8(20) and PFK7(19), cursor to the desired service, enter an S and p
ress ENTER to
    invoke it. To view the output of any command entered during this session, us
e JOURNAL. At
    any point, PFK1 will provide a tutorial help function.


    Spaces and Commas may be interchanged unless an operand is omitted. Then the
 comma must be
    coded to show the omission. See the APF, CSMON, EST, MDEV, MIO, MLC, MPA, SM
S, ST, and TRT
    commands for examples.


    [] brackets enclose optional parameters. The brackets are never coded. If an
 optional
    parameter is omitted, a comma must be coded to show the omission.


    / separates several parameters, any ONE of which may be coded.


    = coded if shown in the syntax. See WARNING command.


    () coded if shown in the syntax. See UCB command, and all using jobn/(asid)
for examples.


    lowercase in syntax indicates variable data


    UPPERCASE in syntax shows data keyed exactly as shown.


    /cpu# is CPU number


    cccchhhhrr is a DASD cylinder, head, record address in hex


    cuu is a 3-digit hex device number, such as 880, 54D.


    jobn/(asid) indicates either a jobname or a parenthesized decimal ASID may b
e coded *


    -y a number of devices, 2-9


./ ADD NAME=RMFINST  0100-02092-02092-1416-00191-00191-00000-BC0THOR
                          *** RMF MONITOR III ***

 RMF Monitor III is a system monitor particularly valuable for analyzing
 delays in individual jobs, or system-wide bottlenecks. The monitor is
 available under TSO when in ISPF, by going to the COMMAND screen,
 (option 6) and entering RMFWDM. If you have not used RMF before, you will
 see the messages:

    ERBTABL DATASET USERID.RMFISPF.ISPTABLE HAS BEEN CREATED ON SYSDA
    ADMGDF DATASET USERID.RMFISPF.ADMGDF HAS BEEN CREATED ON SYSDA
    ***

 These messages are normal. Just press ENTER at the *** prompt. You should
 next see the following menu:

 -----------------------------------------------------------------------------
                         RMF Monitor III Primary Menu
                                                        Version 4, Rele

 Enter selection number or command on selection line.

   1 DELAY   Delays (DLY)               9 JOBS     Job report selection
   2 DEV     Device delays (DD)        10 PROC     Processor delays (PD
   3 DEVR    Device resource (DR)      11 STORAGE  Storage report selec
   4 ENQ     ENQ delays (ED)           12 SYSINFO  System information (
   5 ENQR    ENQ resource (ER)         13 WFEX     Workflow exceptions
   6 HSM     HSM delays (HD)           DI DSINDEX  Dataset index
   7 JES     JES delays (JD)           OP OPTIONS  Option selection
   8 JOB     Job ===>                   T TUTORIAL Tutorial aid
                                        X EXIT     End display session


 Note: While viewing tabular reports, more information about individual
 fields is available by moving the cursor to the field and pressing ENT

 SELECTION ===>
 -----------------------------------------------------------------------------

 You may type an RMF command or the number of any menu item on the
 SELECTION line and press enter. If you type a menu item number, the
 corresponding display will be presented. Some of the commands you may
 enter include:

 COMMANDS: This provides a menu offering 3 choices: (1) Commands to
           display reports; (2) Commands to display option screens;
           (3) Other RMF Commands.

 FREF and BREF: These commands cause the report to display the next
                interval (FREF) or the previous interval (BREF) for the
                report being viewed. These commands are especially
                useful in doing historical analysis of earlier problems.
                The interval time is that specified by the RANGE, which
                can be set by the ROPTIONS command. To reduce keystrokes
                it is a good idea to set up a PF key for each of these
                commands (use the KEYS command).
 ROPTIONS: This is normally entered while within a report, rather than
           from the primary menu. If entered from the primary menu, you
           will be asked for a report name. The report options permit
           setting the following (press PF3 when finished):
            DATE and TIME: Use this to look back at an earlier time, up
                           to 24-48 hours ago, depending on stored data.
            RANGE: This is the interval between successive displays. The
                   minimum is 100 seconds. Use this with the FREF and
                   BREF commands.
            CLASS: Report on ALL jobs, or only on TSO or STC or BATCH.
            GROUP: Limit the report to a particular domain or perform-
                   ance group.
            SUMMARY: Include summary lines for CLASS or not.
            CRITERION: Specify the lowest delay percentage to be shown
                       for the report display. This defaults to 0% so
                       that everything is shown, whether delayed or not.
                       You may find it better to use 5, 10, or more.
            JOBS: If you say YES, after you press ENTER, you get a full
                  screen showing the jobs in the system. You can use
                  this to specify the job(s) to be included on the
                  report if desired. Place an S to the left of a job
                  to include it on the report, or an X to exclude it.

 GO: This puts you in automatic update mode, and the date/time will be
     set to current time. After each interval of time specified by the
     value of RANGE, an updated screen is displayed. When in this mode
     your PF keys are not recognized, and you cannot enter commands. To
     get out of GO mode, press ATTENTION (twice if in Supersession).

 DSINDEX: This shows you how much data is available for reporting by
          date and time.

 JOB jjjjjjjj: The JOB command followed by a jobname gives an RMF Job
               Delays Display, explaining any delays for the job in
               detail. This is very helpful when a job is "hung" or
               running very slowly.

 Cursor sensitivity: While in reports, you can move the cursor to fields
                     on the screen and press enter. If an expanded
                     display is available for the field, it will be
                     shown. When PF3 is pressed, you will be returned to
                     the display you were on before. If a jobname is
                     selected at the cursor, the RMF Job Delays screen
                     is produced. Other fields result in other displays.

 KEYS: Gives a display showing the values currently associated with the
       PF keys. There are two pages, one for PF1-12, the other for PF13-
       24. Press ENTER to alternate between them. Type any desired value
       (such as FREF or BREF) to the right of a key to set it. When
       finished, press PF3. Be careful in choice of PF keys, as you will
       probably want to leave PF3, PF7, PF8 and others as-is.
 The display below was obtained by entering JOB JES2 on the SELECTION
 line of the PRIMARY MENU. It can also be invoked by placing the cursor
 on the jobname JES2 on any report and pressing ENTER.
 -----------------------------------------------------------------------------
                             RMF Job Delays -- SYSB                 Line
              Samples:    100   Time: 01/24/92 at 09.13.20    Range +

 Job: JES2         Primary delay: Job is waiting to use the processor.

 Probable causes: 1) Higher priority work is using the system.
                  2) Improperly tuned dispatching priorities.

 ------------------------- Jobs Holding the Processor ------------------
 Job:        *MASTER*         Job:          USERKY         Job:
 Holding:          2%         Holding:          1%         Holding:
 PROC Using:       7%         PROC Using:       6%         PROC Using:
 DEV Using:       38%         DEV Using:       12%         DEV Using:
 --------------------------- Job Performance Summary -------------------
                WFL -Using%- DLY IDL UKN ------- % Delayed for -------
 C ASID DMN  PG  %  PROC DEV  %   %   %  PROC  DEV STOR SUBS OPER  ENQ
 S 0020   2   2  81    2  24   5   0  70    4    2    0    0    0    0
 -----------------------------------------------------------------------------

 You must use some judgement in use of these screens. For example, a
 screen will be shown even if there is absolutely nothing delaying the
 job. For example, this report shows only 4% delay for processor, and 2%
 for devices, hardly anything to worry about. Also, the 81% workflow
 indicates the job is getting most of the resources it needs. If the
 WFL (workflow) is low, it indicates the job is suffering, and then you
 should look to the % Delayed for and Primary Reason columns to locate
 the problem.
 The report below was obtained by entering 1 on the Primary Menu. It is
 one of the most valuable of the reports, however all the reports are
 useful for one problem or another. Try them all. For a full description
 of all RMF Monitor III facilities, see IBM Manual GC28-1058.

 -----------------------------------------------------------------------------
                            RMF Delay Report -- SYSB               Line
              Samples:    100   Time: 01/24/92 at 15.16.40    Range +

                    WFL USG DLY IDL UKN  ------- % Delayed for -------
 Name     C DMN  PG  %   %   %   %   %   PROC  DEV STOR SUBS OPER  ENQ

 *SYSTEM             45   3   4  60  33     1    0    0    0    1    1
 *TSO                60   1   1  97   1     0    0    0    0    0    0
 *BATCH              49  13  14   0  74     5    1    0    2    2    5
 *STC                31   1   3  58  38     0    0    0    0    2    1
 USERJ90W B  19  77   0   0  12   0   0     0    0    0   12    0    0
 USERFU   T   4  20   0   0  12   0   0     0    0    0   12    0    0
 SASBILLX B  19  78   0   0  12   0   0     0    0    0   12    0    0
 DHD0070X B  17  74   0   0  12   0   0     0    0    0   12    0    0
 TESTIMSA S   7  50   1   1 100   0   0     1    0    0    0  100    0
 DCP0040B B *** ***   1   1  78   0   0     0    0    0    0    0   78

 COMMAND ===>                                                SCROLL ===> PAGE
 -----------------------------------------------------------------------------

 When in this, or any report, you can scroll forward and back using PF8
 and PF7, just as in TSO Edit. In addition, you can enter a FIND jjjjjjj
 command on the COMMAND line to locate a particular job. The TOP
 command will return you to the beginning of the display.

 The CRITERION was set to 10 using the ROPTIONS command so that only
 those jobs delayed 10% or more are displayed.

 When evaluating job performance, first notice the WFL column. This
 shows the percentage of resources the job wants versus what it gets.
 A 100 here indicates it is getting all it wants and can use. A 0 here
 indicates it is getting nothing. Jobs with low WFL values should be
 evaluated further. If a number of jobs having low WFL values show the
 same Primary Reason, this may indicate a system-wide bottleneck. In
 this case, cursor to the name in the Primary Reason column and press
 ENTER for additional information.

 If an individual job is to be analyzed, move the cursor to its jobname
 and press ENTER to see the RMF JOBS DISPLAY report which includes any
 details concerning its delays.

 When analyzing an earlier time, use the ROPTIONS command to set the
 date and time, them "walk" forward and back in time using the PF keys
 you have set up for FREF and BREF. This can provide a graphic picture
 of the changing environment that often helps understand why a problem
 occurred. This capability can be used with any of the reports, of
 course.

./ ADD NAME=SIRTSO   0100-02092-02092-1416-00064-00064-00000-BC0THOR
*               *** INSTRUCTIONS FOR SIRTSO ***
*
*      SIRTSO IS A TSO UTILITY USED TO CHECK THE PROGRESS OF JOBS IN THE
* SYSTEM. THE JOB IS INVOKED BY ENTERING THE COMMAND: SIRTSO.
* THE DISPLAY USES FULLSCREEN WRITES WITH THE CURSOR POSITIONED AT THE
* TOP OF THE DISPLAY. A ONE-CHARACTER CONTROL CODE MAY BE ENTERED TO
* REQUEST DIFFERENT DISPLAY TYPES. IF THE ENTER KEY IS PRESSED WITHOUT
* ENTERING A CODE, OR IF AN INVALID CODE IS ENTERED, THE SCREEN IS
* REFRESHED WITH AN UPDATED DISPLAY OF THE CURRENT DISPLAY TYPE.
* VALID CONTROL CODES ARE:
*    E  =  TERMINATES THE PROGRAM
*    C  =  CPU MODE SWITCH. MODE ALTERNATES, AND DEFAULTS TO TOTAL CPU
*          TIME AT START. ENTERING C ONCE WILL CAUSE CPU TIME FOR JOBS
*          TO BE THE DIFFERENCE SINCE THE LAST DISPLAY. ENTERING C AGAIN
*          CAUSES TOTAL CPU TIME TO BE DISPLAYED AGAIN, ETC.
*    B  =  BATCH JOBS ONLY TO BE DISPLAYED
*    T  =  TSO USERS ONLY TO BE DISPLAYED
*    A  =  ALL BATCH AND TSO JOBS TO BE DISPLAYED (DEFAULT AT START)
*    O  =  INCLUDE SWAPPED OUT JOBS IN DISPLAY
*    I  =  DO NOT INCLUDE SWAPPED OUT JOBS (DEFAULT AT START)
* THE DISPLAY CONTAINS A NUMBER OF COLUMN HEADINGS WHICH ARE:
*   JOBNAME  =  NAME OF THE JOB OR TSO USER
*   JCLSTEP  =  STEPNAME FROM THE EXEC STATEMENT
*   PROCSTEP =  STEPNAME OF THE STEP IN THE PROC
*   HH:MM:SS =  ELAPSED TIME OF THE STEP BEING EXECUTED. NOTE THAT THIS
*               BEGINS ANEW AT ZERO FOR EACH STEP.
*   SR       =  SWAP REASON CODE:
*                 TO - TERMINAL OUTPUT WAIT
*                 TI - TERMINAL INPUT WAIT
*                 LW - LONG WAIT
*                 XS - PAGING SPACE SHORTAGE
*                 RS - REAL STORAGE SHORTAGE
*                 DW - DETECTED WAIT
*                 RQ - REQSWAP SYSEVENT
*                 NQ - ENQ EXCHANGE
*                 EX - EXCHANGE ON RECOMMENDATION VALUES
*                 US - UNILATERAL SWAP-OUT
*   ST       =  STATUS OF JOB IN THE SYSTEM:
*                 IN - SWAPPED IN
*                 NS - NON-SWAPPABLE
*                 PR - PRIVILEGED JOB
*                 WT - WAITING
*                 OT - SWAPPED OUT
*                 <> - IN TRANSIT, IN-TO-OUT OR OUT-TO-IN
*   SIZ      =    TOTAL PAGES ALLOCATED TO THE PROGRAM.
*   WSS      =    TOTAL PAGES IN THE WORKING SET FOR THE PROGRAM.
*   DP       =    DISPATCHING PRIORITY, IN HEX.
*   SWC      =    SWAP COUNT FOR THE STEP. RESET FOR EACH STEP.
*   PGIN     =    NUMBER OF PAGE-INS FOR THE STEP. RESET EACH STEP.
*   PGOUT    =    NUMBER OF PAGE-OUTS FOR THE STEP. RESET EACH STEP.
*   CPU      =    CPU SECONDS USED BY THE STEP. RESET EACH STEP.
*
* THE TOP LINE OF THE DISPLAY CONTAINS SYSTEM-WIDE INFORMATION:
*
*   CPU=   %     IS THE TOTAL CPU BUSY PERCENT (MOMENTARILY).
*   AVQ=         IS THE NUMBER OF PAGES ON THE AVAILABLE QUEUE,
*                AND AVAILABLE TO EXECUTING PROGRAMS. SHOULD BE
*                GREATER THAN 6 EXCEPT DURING REAL STORAGE SHORTAGE.
*   UIC=         UNREFERENCED INTERVAL COUNT. SHOWS HOW LONG PAGES
*                ARE GOING UNREFERENCED. SHOULD BE LESS THAN 10
*                WHEN STORAGE IS EFFICIENTLY USED.
*   AI           (OR OTHER VALUES) SHOWS THE LAST COMMAND CODES
*                ENTERED.
*   08:56:17     (OR WHATEVER) THE TIME OF DAY IN HOURS:MINUTES:SECONDS.
./ ADD NAME=SLSS     0100-91037-91037-1433-00069-00069-00000-USER02
                 ***** SLSS System *****

     The SLSS system consists of a lot of manual work and several
     computer jobs. A PDS called USER02.TSO.MANUALS contains one
     member for each MACHINE/PROGRAM in the areas of interest. Since
     most of these begin with a numeric, the first character of the
     member name is "S" followed by the machine or program name, thus
     information for 3800 printers is in member s3800, and for
     Assembler H in member S5668962. The MISC member is used for those
     manuals not identifiable with a specific group.

     Periodically, the manuals PDS must be updated with new
     information from the INFONET system. To do this, logon to
     INFOLINK, specify IBM     LINK, then enter PUB on the command
     line. Choose option 4 for all except individual manuals in the
     MISC member. For each MACHINE/PROGRAM, enter the number on the
     screen line provided and press enter. A screen will be returned
     showing one line per publication. Note the number of entries at
     the top of the screen and enter PRINT 1-nnn on the command line
     where nnn is the number of items. Press enter, and on the printer
     screen choose option 2. Make a note of the first few manuals in
     each group so that you can identify it later. For the manuals in
     the MISC member, choose option 1 and individually list and print
     (use PF9) each manual. When finished, logoff IBMLINK and logon to
     TSO.

     On TSO, issue the RECEIVE command, which will respond with a
     request to specify the output parameters for the first available
     INFOLINK file. Enter DS(INFO1.DATA) to cause the first INFOLINK
     file to be written to file INFO1.DATA under your userid. The
     RECEIVE command will copy the file, then return with the next
     available file, or it will state that no more files are
     available. Repeat the DS(INFOn.DATA), where n is 1 greater
     eachtime until there are no more files.  The files may be
     returned in a different order than created, and some may take up
     to 24 hours to be sent.

     Create a PDS to contain the manuals information. Allocate it with
     60 tracks, 20 directory blocks, RECFM=VB,LRECL=83,BLKSIZE=24000.
     Next, edit each of the INFOn.DATA files, identify its content,
     and copy it into the new manuals file using the CREATE subcommand
     of EDIT. For the MISC member it will be necessary to build it
     using the COPY subcommand to gather all the individual files,
     then do a final CREATE.

     When the manuals PDS is complete, run USER02.TSO.JCL(SLSSSTRP) to
     strip manual number, current suffix number, number TNL's,
     ships-with-product indication, manual title, and name of the
     member for each manual in the entire PDS. Note that the DSN
     parameter of the INPUT1 DD statement MUST contain a member name,
     which can be any name. The program reads the READER1 file to get
     the member names to be processed, and reads all of the specified
     members using OPEN TYPE=J.

     The job in USER02.TSO.JCL(SLSSPRNT) can now be run to print the
     updated SLSS.  This job reads its INPUT1 dataset to get the
     manual number, SLSS order quantity, and individual member
     quantities, locates each manual in the strip file from SLSSSTRP
     (INPUT2 dataset) , and prints a listing showing manual number,
     current suffix number, number TNL's, ships-with-product
     indication, SLSS quantity, individual member quantities, and
     manual title. Only manuals in the INPUT1 file are listed.

     The job in USER02.TSO.JCL(SLSSSUBJ) may be run to produce a
     listing of all manuals in the manuals PDS. If desired, only
     selected members may be printed by including only the desired
     member name control cards in the READER1 control card file. These
     records contain mamber name in columns 1-8 and a heading in
     columns 10-72.
./ ADD NAME=SMODE    0100-02092-02092-1416-00058-00058-00000-BC0THOR
                                                                        0000000
                                                                        0000000
                                                                        0000000
                                                                        0000000
                                                                        0000000
     DOCUMENTATION FOR MACRO     SMODE                                  0000000
                                                                        0000000
                                                                        0000000
         SMODE EXPANDS TO ISSUE SVC 243 FOR CHANGING PROTECTION KEY     0000000
          AND PROGRAM STATE                                             0000000
                                                                        0000000
         SMODE FORMAT IS                                                0000000
                                                                        0000000
     LABEL    SMODE KEY=NNN,STATE=Z                                     0000000
                                                                        0000000
          WHERE      NNN IS THE PROTECT KEY YOU WANT, 0 - 255, OR       0000000
                        N OR NZERO TO RETURN YOUR ORIGINAL PROTECT      0000000
                        KEY. NUMERIC VALUES GREATER THAN 255 ALSO       0000000
                        CAUSE RETURN TO ORIGINAL PROTECT KEY.           0000000
                        NONNUMERIC VALUES OTHER THAN N OR NZERO         0000000
                        WILL CAUSE ASSEMBLER ERROR OR UNPREDICTABLE     0000000
                        RESULTS.                                        0000000
                                                                        0000000
                     Z IS THE PROGRAM STATE YOU DESIRE, P-PROGRAM STATE 0000000
                       S-SUPERVISOR STATE. IF S IS NOT SPECIFIED, P IS  0000000
                       ASSUMED.                                         0000000
                                                                        0000000
                                                                        0000000
          ON FIRST EXECUTION OF SMODE IN A PROGRAM                      0000000
                                                                        0000000
                     KEY= DEFAULTS TO NZERO                             0000000
                     STATE= DEFAULTS TO P                               0000000
                                                                        0000000
          ON SUBSEQUENT EXECUTIONS, KEY= AND STATE= DEFAULT TO THE      0000000
           VALUES USED IN THE LAST PREVIOUS EXECUTION. DEFAULTS ARE     0000000
           TAKEN ONLY IF THE KEY WORD, OR KEY WORD VALUE IS OMMITTED.   0000000
                                                                        0000000
                                                                        0000000
          EXAMPLE:                                                      0000000
                                                                        0000000
            SMODE KEY=0,STATE=S                                         0000000
                                                                        0000000
               YOU ARE NOW IN PROTECT KEY ZERO, SUPERVISOR STATE        0000000
                                                                        0000000
            SMODE KEY=N                                                 0000000
                                                                        0000000
               YOU ARE NOW BACK TO YOUR ORIGINAL PROTECT KEY, AND       0000000
                STILL IN SUPERVISOR STATE                               0000000
                                                                        0000000
                                                                        0000000
          LITTLE EDITING IS PERFORMED BY SMODE. IF KEY=NNN IS           0000000
           SPECIFIED, AND NNN IS NOT = TO N OR NZERO, NNN IS USED AS    0000000
           ENTERED. IF STATE=Z IS SPECIFIED AND Z = S, SUPERVISOR STATE 0000000
           IS USED,  OTHERWISE, PROGRAM STATE IS USED.                  0000000
                                                                        0000000
                                                                        0000000
                                                                        0000000
                                                                        0000000
./ ADD NAME=SNAPDUMP 0100-93301-93301-0906-00011-00011-00000-USER02
SNAPDUMP is a subroutine written in COBOL II which can be called to
produce an ABEND-AID formatted dump without terminating the calling     00
program. The user must supply a //ABENDAID DD SYSOUT=* DD statement
in the execution JCL. The SNAPAID subroutine called by this subroutine
is supplied by COMPUWARE with the ABEND-AID dump product and is
located in the SYS1.ABENDAID.PROD.LOAD library, which must be included
in the SYSLIB concatenation for the linkedit when this subroutine is
link-edited. The only programming requirement for use of this
subroutine is a CALL at the point where a dump is to be taken:

         CALL 'SNAPDUMP'.
./ ADD NAME=SRBINST  0100-93194-93194-1031-00291-00291-00000-USER02
*            *** USE OF THE SRB MACROS ***
*
*      THIS DESCRIBES THE USE OF THE MACROS BCBLDSRB, BCGETRTN, BCSRBFRE
*      BCSRBDEF, BCSRBENT, AND BCSRBPST, IN SHEDULING AND WRITING SERVIC
*      ROUTINES.
*
*
* 1. SCHEDULING A SERVICE ROUTINE:
*    A. LOCATE THE ADDRESS OF THE TARGET MEMORY'S ASCB, AND PLACE IT IN
*       A REGISTER.
*    B. GET INTO SUPERVISOR STATE, PROTECT KEY ZERO, USING MODESET OR
*       SMODE.
*    C. ISSUE THE BCBLDSRB MACRO, SPECIFYING THE TGTASCB AND SRBASE
*       PARAMETERS.
*    D. ISSUE THE BCGETRTN MACRO, SPECIFYING EITHER THE NAME PARAMETER
*       IF THE ROUTINE IS EXTERNAL TO THE PROGRAM, OR THE ADDR AND LENG
*       PARAMETERS IF IT IS WRITTEN WITHIN THE PROGRAM.
*    E. SCHEDULE THE SERVICE ROUTINE FOR EXECUTION:
*          LA    R1,SRBSECT
*          SCHEDULE SRB=(1),SCOPE=LOCAL
*    F. AWAIT SERVICE ROUTINE COMPLETION:
*          LA    R1,SRBECB
*          WAIT  ECB=(1)
*    G. PROCESS AS NECESSARY, USING THE WORK AREA PORTION OF THE SRB AS
*       COMMUNICATION AREA BETWEEN THE SERVICE ROUTINE AND THE SCHEDULIN
*       PROGRAM.
*    H. ISSUE THE BCSRBFRE MACRO TO FREE THE STORAGE GOTTEN FOR THE SRB
*       AND SERVICE ROUTINE.
*    I. COMPLETE OTHER PROCESSING.
*    J. ISSUE THE BCSRBDEF MACRO TO GET AN SRB DSECT, AND FOLLOW IT WITH
*       ANY DESIRED WORK/COMMUNICATION FIELDS TO BE USED BY THE PROGRAM
*       AND SERVICE ROUTINE. FINISH SRB DEFINITION WITH SRBEND EQU *,
*       AND RETURN TO IN-LINE CODE WITH A CSECT STATEMENT.
*
*
*
* 2. CODING REQUIREMENTS FOR THE BCBLDSRB MACRO:
*
*    BCBLDSRB GETS STORAGE FOR THE SRB IN THE REQUESTED SUB-POOL, AND
*    BUILDS AN SRB IN THE GOTTEN STORAGE. AN SRB BASE REGISTER IS SET
*    UP FOR THE SRB. REGISTERS 0, 1, 14, AND 15 WILL BE CHANGED BY THIS
*    MACRO. THE STORAGE AREA FOR THE SRB IS CLEARED TO BINARY ZEROS
*    BEFORE THE FORMAT BEGINS. THE END OF THE SRB IS EXPECTED TO BE
*    IDENTIFIED BY AN INSTRUCTION NAMED SRBEND, AND IS USED IN LENGTH
*    COMPUTATION (SEE THE BCSRBDEF MACRO). THE USER MUST BE IN PROTECT
*    KEY ZERO AND IN SUPERVISOR STATE TO EXECUTE CODE GENERATED BY THIS
*    MACRO.
*
*
*          NAME  BCBLDSRB  TGTASCB=REGNO,SP=NBR,SRBBASE=REGNO
*
*     A. THE NAME FIELD IS OPTIONAL.
*     B. TGTASCB IS AN OPTIONAL PARAMETER. WHEN CODED, SPECIFY A REGISTE
*        CONTAINING THE ADDRESS OF THE ASCB FOR THE TARGET MEMORY. THE
*        REGISTER PROVIDED WILL BE STORED IN THE SRBASCB FIELD. IF THIS
*        PARAMETER IS OMITTED, THE USER MUST PLACE THE ADDRESS OF THE
*        TARGET ASCB IN SRBASCB BEFORE ISSUING THE SCHEDULE MACRO.
*     C. SP= IS USED TO SPECIFY THE SUB-POOL NUMBER TO BE USED FOR THE
*        GETMAIN. IF OMITTED, SUB-POOL 228 IS USED.
*     D. THE SRBBASE= PARAMETER SPECIFIES THE REGISTER TO BE USED AS A
*        BASE REGISTER FOR THE SRB. IF SPECIFIED, THE ADDRESS OF THE SRB
*        WILL BE PLACED IN THE REGISTER, AND A USING INSTRUCTION WILL
*        BE GENERATED. WHEN OMITTED, THE ADDRESS OF THE SRB WILL BE
*        PLACED IN REGISTER 2, AND NO USING INSTRUCTION WILL BE ISSUED.
*
*     E. EXAMPLE:
*
*                    BCBLDSRB  TGTASCB=R12,SRBBASE=R5
*
*
*
* 3. CODING REQUIREMENTS FOR THE BCGETRTN MACRO:
*
*    THIS MACRO GETS STORAGE FROM A COMMONLY ADDRESSABLE SUB-POOL, AND
*    MOVES THE SERVICE ROUTINE TO THE GOTTEN STORAGE, IF IT IS NOT
*    ALREADY IN COMMON STORAGE. IF THE ROUTINE IS NOT WRITTEN IN-LINE
*    IN THE SCHEDULING PROGRAM, A LOAD MACRO IS EXECUTED TO GAIN ACCESS
*    TO THE SERVICE ROUTINE. WHEN A LOAD'ED MODULE MUST BE MOVED TO
*    COMMONLY ADDRESSABLE STORAGE, IT WILL BE DELETED AFTER THE MOVE.
*    THE ADDRESS OF THE MODULE WILL BE PLACED IN THE SRBEP FIELD. TO
*    USE THIS MACRO, THE USER MUST BE IN SUPERVISOR STATE, PROTECT KEY
*    ZERO, WITH ADDRESSABILITY FOR THE SRB. REGISTERS 0, 1, 14, AND
*    15 WILL BE CHANGED BY THIS MACRO.
*
*       NAME   BCGETRTN  NAME=EXTSYM, ADDR=INLINE,LENG=RTNLENG,SP=NNN
*
*     A. THE NAME FIELD IS OPTIONAL.
*     B. WHEN THE ROUTINE IS CODED IN-LINE IN THE ISSUING PROGRAM:
*        SPECIFY THE ROUTINE ENTRY POINT NAME IN THE ADDR= PARAMETER,
*        AND ITS LENGTH IN THE LENG PARAMETER. THE NAME= PARAMETER
*        MUST BE OMITTED. ENTRY POINT OF THE ROUTINE MUST BE THE FIRST
*        BYTE OF THE ROUTINE, AS THE MOVE TO COMMONLY ADDRESSABLE
*        STORAGE WILL BEGIN HERE. LENGTH MAY BE GIVEN AS THE DIFFERENCE
*        BETWEEN THE LABELS ON THE END AND BEGINNING OF THE ROUTINE.
*     C. WHEN THE ROUTINE IS NOT INCLUDED IN THE ISSUING PROGRAM, CODE
*        THE NAME= PARAMETER, GIVING THE SYMBOLIC NAME OF THE ROUTINE
*        TO BE USED. THE ROUTINE WILL BE FOUND USING A LOAD MACRO. IF
*        FOUND IN COMMONLY ADDRESSABLE STORAGE (PLPA, ETC), NO GETMAIN
*        OR MOVE WILL OCCUR. IF NOT IN COMMON STORAGE, A GETMAIN AND
*        MOVE WILL BE DONE, AND A DELETE MACRO WILL BE ISSUED FOR THE
*        MODULE. WHEN THE NAME= PARAMETER IS CODED, THE ADDR= AND LENG=
*        PARAMETERS ARE INVALID.
*     D. THE SP= PARAMETER IS USED TO SPECIFY THE SUB-POOL TO BE USED
*        TO CONTAIN THE SERVICE ROUTINE WHEN MOVEMENT IS NECESSARY. IF
*        OMITTED, SUB-POOL 228 WILL BE USED.
*     E. EXAMPLES:
*         1. ROUTINE CODED IN-LINE IN THE ISSUING PROGRAM:
*
*                    BCGETRTN   ADDR=SERVCRTN,LENG=ENDLBL-SERVCRTN
*
*         2. ROUTINE NOT IN THE ISSUER'S PROGRAM:
*
*                    BCGETRTN   NAME=XTRNSYM
*
*
*
* 4. CODING INSTRUCTIONS FOR THE BCSRBFRE MACRO:
*
*    THE BCSRBFRE MACRO IS USED TO FREE THE STORAGE USED BY THE SRB
*    AND SERVICE ROUTINE, AND DELETE THE SERVICE ROUTINE IF IT WAS
*    LOCATED IN COMMONLY ADDRESSABLE STORAGE, AND NOT MOVED BY THE
*    BCGETRTN MACRO. SINCE SUB-POOL 228 STORAGE MUST BE EXPLICITLY
*    FREED, IT IS IMPORTANT THAT A FREEMAIN BE ISSUED BEFORE PROGRAM
*    TERMINATION.
*
*        NAME   BCSRBFRE   SRB=
*
*     A. THE NAME OPERAND IS OPTIONAL.
*     B. THE SRB OPERAND IS ALSO OPTIONAL, AND HAS TWO POSSIBLE OPERANDS
*        WHEN CODED:
*            SRB= OMITTED  -> ALL STORAGE GOTTEN FOR BOTH SRB AND SERVIC
*                             ROUTINE IS FREED, AND SERVICE ROUTINE IS
*                             DELETED IF NECESSARY.
*            SRB=NO        -> ONLY THE SERVICE ROUTINE STORAGE IS DELETE
*                             AND USER MAY RETAIN SRB FOR USE BY ANOTHER
*                             SERVICE ROUTINE TO BE SCHEDULED.
*            SRB=ONLY      -> ONLY THE SRB STORAGE IS FREED, AND THE
*                             SERVICE ROUTINE STORAGE IS RETAINED.
*     D. EXAMPLE:
*
*                   BCSRBFRE
*
*
*
* 5. CODING REQUIREMENTS FOR THE BCSRBDEF MACRO:
*
*    THIS MACRO GENERATES A DSECT FOR AN SRB, AND SEVERAL EQUATES FOR US
*    BY THE SCHEDULE MACRO. THESE EQUATES ARE IN LIEU OF THE CVT MACRO,
*    AND WILL CAUSE DUPLICATE NAMES IF THE CVT MACRO IS USED IN THE SAME
*    ASSEMBLY. THE USER SHOULD CODE FIELDS FOLLOWING THE STANDARD SRB
*    FOR WORK AREAS TO BE USED BY THE SERVICE ROUTINE, AND COMMUNICATION
*    BETWEEN THE SCHEDULER AND SERVICE ROUTINE. THIS ELIMINATES THE NEED
*    FOR GETMAINS BY THE SERVICE ROUTINE, AND SIMPLIFIES PASSING
*    INFORMATION AND PARAMETERS BETWEEN SCHEDULER AND SERVICE ROUTINE.
*
*           BCSRBDEF  END=YES
*
*    A. NOTE THAT NO NAME MAY BE CODED ON THIS MACRO.
*    B. END=YES IS OPTIONAL. WHEN INCLUDED, THE MACRO GENERATES
*         SRBEND   EQU   *
*         &SYSECT  CSECT
*       AT THE END OF THE SRB CREATED. THIS PREVENTS THE USER FROM
*       ADDING WORK/COMMUNICATION FIELDS TO THE SRB, AND SHOULD
*       NORMALLY NOT BE USED. WHEN END=YES IS OMITTED, THE USER MAY
*       DEFINE FIELDS FOR COMMUNICATION BETWEEN THE SCHEDULING AND
*       SERVICE ROUTINES, AND FOR WORK FIELDS NEEDED BY THE SERVICE
*       ROUTINE.
*    C. EXAMPLE:
*
*                 BCSRBDEF ,           DEFINE STANDARD SRB
*        WKFLD1   DS    XL3
*        WKFLD2   DS    CL8
*        WKFLD3   DS    AL3
*        SRBEND   EQU   *              END OF SRB
*        PGMNAM   CSECT ,              RETURN TO SERVICE ROUTINE CSECT
*
*
*
* 6. CONSIDERATIONS WHEN WRITING A SERVICE ROUTINE:
*
*    A. ISSUE THE BCSRBENT MACRO TO ESTABLISH THE ROUTINE BASE REGISTER
*       SRB ADDRESSABILITY, AND SAVE THE RETURN ADDRESS. DO NOT USE
*       REGISTERS 10-15 AS BASES.
*    B. IF WRITTEN AS A SEPARATE PROGRAM, INCLUDE THE REQU MACRO FOR
*       REGISTER EQUATES.
*    C. ON ENTRY, THE ROUTINE WILL BE IN SUPERVISOR STATE, PROTECT KEY
*       ZERO, WITH NO LOCKS HELD. THE ROUTINE CANNOT ISSUE ANY SVC'S
*       (THIS PRECLUDES ANY I/O). THE ROUTINE CANNOT ENTER THE WAIT
*       STATE, EXPLICITLY, OR IMPLICITLY.
*    D. PROCESS AS NECESSARY, USING THE WORK AREA EXTENSION OF THE SRB
*       AS A COMMUNICATION AND WORK AREA.
*    E. ON COMPLETION, ISSUE THE BCSRBPST MACRO TO POST THE SCHEDULING
*       PROGRAM AND RETURN CONTROL TO THE OPERATING SYSTEM.
*
*
*
* 7. CODING REQUIREMENTS FOR THE BCSRBENT MACRO:
*
*    THE BCSRBENT MACRO GENERATES ENTRY STATEMENTS FOR THE SERVICE
*    ROUTINE. THE BASE REGISTERS FOR THE ROUTINE AND FOR SRB
*    ADDRESSABILITY ARE LOADED, AND USING STATEMENTS ARE GENERATED.
*    A PROGRAM NAME LITERAL IS INCLUDED. THE RETURN ADDRESS IS SAVED IN
*    SRBSV14 FOR RETURN TO THE OPERATING SYSTEM ON COMPLETION.
*           PROGRAMMING NOTES:
*      A. SERVICE ROUTINES ARE ENTERED IN SUPERVISOR STATE, PROTECT KEY
*         ZERO, WITH NO LOCKS HELD, AND MUST RETURN TO THE OPERATING
*         SYSTEM ON COMPLETION IN THE SAME STATE.
*      B. ON ENTRY, REGISTERS 0 AND 1 WILL BOTH CONTAIN THE ADDRESS OF
*         THE SRB, REGISTER 15 WILL CONTAIN THE ADDRESS OF THE FIRST
*         BYTE OF THE SERVICE ROUTINE, AND REGISTER 14 WILL CONTAIN THE
*         RETURN ADDRESS. THE SERVICE ROUTINE MUST BRANCH TO THE ADDRESS
*         IN REGISTER 14 ON COMPLETION.
*      C. SERVICE ROUTINES MUST BE CODED RE-ENTRANTLY. USE OF WORK AREAS
*         IN THE SRB FACILITATES THIS, AND REDUCE OR ELIMINATE THE NEED
*         FOR GETMAIN'ED AREAS IF PROPERLY DEFINED.
*      D. SERVICE ROUTINES CANNOT ENTER PROBLEM STATE, AS THEY MUST
*         RETURN TO THE OPERATING SYSTEM IN SUPERVISOR STATE.
*      E. SERVICE ROUTINES CANNOT EXECUTE ANY SVC'S.
*      F. AT NO TIME CAN A SERVICE ROUTINE ENTER THE WAIT STATE, EITHER
*         THRU BRANCH ENTRY TO THE SYSTEM WAIT ROUTINE, OR INDIRECTLY
*         AS THE RESULT OF AN ACTION THAT WILL CAUSE SOME OTHER AGENCY
*         TO ATTEMPT TO PLACE THE CALLER IN THE WAIT STATE.
*      G. WHEN THE SERVICE ROUTINE IS WRITTEN IN-LINE IN THE SCHEDULING
*         PROGRAM, IT SHOULD INCLUDE A LTORG STATEMENT TO CAPTURE ANY
*         NECESSARY LITERALS, AND SHOULD HAVE A FINAL EQU * STATEMENT
*         TO PERMIT SIMPLE ROUTINE LENGTH CALCULATION. THE SERVICE
*         ROUTINE WILL BE MOVED TO COMMONLY ADDRESSABLE STORAGE BY THE
*         BCGETRTN MACRO, AND SO MUST BE FULLY SELF-CONTAINED.
*
*
*
*        NAME   BCSRBENT    BASE=REGNO,CSECT=YES,SRB=REGNO
*
*     A. THE NAME FIELD IS REQUIRED.
*     B. THIS PARAMETER IS USED TO SPECIFY THE PROGRAM BASE REGISTER,
*        AND IS OPTIONAL. DEFAULT IS REGISTER 3. BE CAUTIOUS WHEN USING
*        REGISTERS 10-15, AS THEY ARE USED BY THE BCSRBPST MACRO.
*     C. CSECT=YES IS OPTIONAL. WHEN CODED, THE NAME WILL BE PLACED
*        ON A CSECT STATEMENT. THIS WOULD BE USED WHEN THE SERVICE
*        ROUTINE IS SEPARATELY ASSEMBLED. WHEN CSECT=YES IS OMITTED,
*        THE NAME IS PLACED ON AN EQU * STATEMENT ON THE ASSUMPTION
*        THE SERVICE ROUTINE IS BEING WRITTEN IN-LINE IN THE SCHEDULING
*        PROGRAM. WHEN SEPARATELY ASSEMBLED, INCLUDE THE REQU MACRO
*        TO GENERATE REGISTER EQUATES, AS STANDARD REGISTER NOTATION
*        IS USED IN GENERATED INSTRUCTIONS.
*     D. THE SRB= PARAMETER IS USED TO SPECIFY THE REGISTER TO BE USED
*        AS A BASE FOR THE SRB DSECT. DEFAULT IS REGISTER 9, IF THE
*        PARAMETER IS OMITTED. AGAIN, REGISTERS 10-15 SHOULD BE USED
*        WITH CAUTION. ALSO, ONLY R9 AND R14 ARE RETAINED ACROSS THE
*        BRANCH ENTRY TO CROSS-MEMORY POST. BECAUSE OF THIS, THE
*        REGISTER USED MUST BE SPECIFIED ON THE BCSRBPST MACRO IF R9
*        IS NOT USED.
*     E. EXAMPLE:
*
*         SRVRTN   BCSRBENT   BASE=R6
*
*
* 8. CODING REQUIREMENTS FOR THE BCSRBPST MACRO:
*
*    THIS MACRO IS USED BY A SERVICE ROUTINE TO POST THE SCHEDULING
*    PROGRAM ON COMPLETION OF PROCESSING, AND RETURN CONTROL TO THE
*    OPERATING SYSTEM. REGISTER VALUES ARE OBTAINED FROM THE SRB, AS
*    INITIALIZED BY THE BCBLDSRB MACRO. THE OPERATING SYSTEM'S POST
*    ROUTINE IS BRANCH-ENTERED, SINCE SVC USE IS ILLEGAL. REGISTERS
*    10-15 ARE CHANGED BY THIS MACRO. THE POST GENERATED IS FOR A
*    CROSS-MEMORY POST. IF THE SERVICE ROUTINE IS SCHEDULED IN THE
*    SCHEDULER'S OWN MEMORY, THE USER MUST TURN OFF THE HIGH-ORDER
*    BIT OF SRBPR11 AND OBTAIN THE LOCAL LOCK BEFORE ISSUING
*    BCSRBPST. ALSO, EXIT=NO MUST THEN BE CODED TO PERMIT THE SERVICE
*    ROUTINE TO RELEASE THE LOCAL LOCK PRIOR TO RETURNING CONTROL
*    TO THE OPERATING SYSTEM. IF THE BASE USED FOR THE SRB IS OTHER
*    THAN R9, THE SRB= PARAMETER MUST BE CODED TO PERMIT SAVING AND
*    RESTORING THE SRB BASE VIA R9 ACROSS THE CROSS MEMORY POST. ALL
*    REGISTERS EXCEPT R9 AND R14 ARE DESTROYED BY CROSS MEMORY POST,
*    SO THAT ANY PROCESSING FOLLOWING THE EXECUTION OF BCSRBPST MUST
*    RESTORE THE PROGRAM BASE REGISTER FROM SRBEP BEFORE PROCESSING.
*    THE USER MUST ALSO FIND A MEANS OF SAVING ANY OTHER REGISTERS
*    WHICH MUST BE AVAILABLE AFTER THE CROSS MEMORY POST.
*
*    NAME   BCSRBPST   EXIT=NO,ERR=ERRTN,SRB=
*    A. NAME PARAMETER IS OPTIONAL.
*    B. EXIT PARAMETER IS OPTIONAL. IF OMITTED, THE GENERATED CODE WILL
*       INCLUDE A RETURN TO THE OPERATING SYSTEM. IF USED, CODE AS SHOWN
*       EXIT=NO, AND ONLY POST CODE WILL BE GENERATED WITH A FALL-THRU
*       FOR CONTINUED SERVICE ROUTINE PROCESSING.
*    C. THE SRB PARAMETER IS OPTIONAL IF R9 IS USED AS THE SRB BASE REG-
*       ISTER. WHEN ANOTHER SRB BASE IS USED, IT MUST BE SPECIFIED HERE
*       SO THAT THE SRB BASE CAN BE SAVED IN R9 BEFORE THE BRANCH ENTRY
*       TO CROSS-MEMORY POST.
*    D. EXAMPLE:
*                 SRBEXIT BCSRBPST ,        POST THE SCHEDULER AND RETUR
./ ADD NAME=SYSLOGDT 0100-88061-88061-1011-00059-00059-00000-USER02
         STRIP RECORDS FROM A SYSLOG DATASET FOR A DATE-TIME RANGE

READS BEGINNING AND ENDING DATE/TIMES FROM THE SYSIN DATASET. CREATES
AN OUTPUT DATASET WHICH CONTAINS ALL INPUT RECORDS WHICH WERE CREATED
CREATED ON OR BETWEEN THE SPECIFIED DATE/TIMES. IEE104I AND IEE136I
MESSAGES ARE USED TO LEARN THE DATE, SO VALID OUTPUT IS DEPENDENT ON
FREQUENT OCCURRENCE OF THESE RECORDS.

DATE/TIME ENTRY BEGINS IN COLUMN 1 OF THE SYSIN RECORD, AND HAS THE
FOLLOWING FORMAT:

        YY.DDD/HH:MM-YY.DDD/HH:MM

        WHERE YY IS YEAR, DDD IS JULIAN DAY, HH IS HOUR, AND MM IS
        MINUTES AFTER THE HOUR. THE FIRST DATE/TIME IS THE BEGINNING
        AND THE SECOND THE ENDING DATE/TIME. THE FIRST DATE/TIME
        MUST BE LESS THAN THE SECOND.

FILES USED ARE AS FOLLOWS:
        (1) DATE-TIME CONTROL CARD INPUT
                DDNAME=SYSIN
                RECFM=FB, LRECL=80 HARD-CODED
        (2) LISTING OUTPUT
                DDNAME=SYSPRINT
                RECFM=FB,LRECL=80,BLKSIZE=80 HARD-CODED
        (3) FULL SYSLOG INPUT TO BE SUBSET
                DDNAME=SYSUT1
                RECFM=VB,LRECL=255
        (4) OUTPUT SYSLOG SUBSET
                DDNAME=SYSUT2
                RECFM=VB,LRECL=255 HARD-CODED

EXAMPLE JCL IS AS FOLLOWS:

//RUX1077W JOB (1100303-9900085,,BC8H01-UR-XXXX),RTHORNTON,CLASS=B,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=CMP2F5,DEFAULT=YES,JESDS=ALL
//*
//*        EXTRACT SYSLOG RECORDS FOR THE SPECIFIED DATE/TIMES
//*
//SYSLOGDT EXEC PGM=SYSLOGDT
//STEPLIB  DD   DSN=SYS.PROD.LOAD,DISP=SHR
//SYSUDUMP DD   SYSOUT=(*,,FMT)
//SYSPRINT DD   SYSOUT=(*,,FMT)
//*SYSUT1   DD DSN=SYS.SYSLOG.BDAILY,DISP=SHR
//SYSUT1   DD DSN=SYS.SYSLOG.BWEEKLY(-1),DISP=OLD
//SYSUT2   DD DSN=T1804.SYSLOG.DATA,UNIT=DISK,DISP=(,CATLG),
//         SPACE=(TRK,(100,10),RLSE),
//         DCB=(RECFM=VB,LRECL=255,BLKSIZE=9442)
//SYSIN    DD *
85.102/05:00-85.103/00:05
//*
//*        PRINT THE RESULTING SYSLOG SUBSET
//*
//PRTLOG   EXEC PGM=IEBGENER
//SYSPRINT DD   SYSOUT=(*,,FMT)
//SYSUT1   DD   DSN=T1804.SYSLOG.DATA,DISP=OLD
//SYSUT2   DD   SYSOUT=(*,,FMT)
//SYSIN    DD DUMMY
./ ADD NAME=TAKETEST 0100-02092-02092-1417-00042-00042-00000-BC0THOR
                                 BEATING TESTS


         1) Leave no question without an answer. One of every five
            guesses will be right.

         2) If you are feel you can't answer a question correctly, try
            to eliminate as many answers as possible, then guess from
            those that are left. This increases your chances of
            guessing correctly.

         3) Read the questions carefully to be sure you understand
            EXACTLY what is asked. Don't be afraid to re-read the
            question to be sure you answered correctly.

         4) Don't spend too much time on a question. If it is taking a
            long time, choose the best answer you can and go on. Write
            the question number so you can come back to it after
            finishing.

         5) Keep track of your time. At the half-way point in time you
            should be about half-way through the test.

         6) At about 5 minutes left, quickly put answers on all the
            remaining questions, then go back and continue working
            from where you were.

         7) If you finish the test, go back over the questions you
            wrote down in step 3. When these are finished, start back
            at the beginning and work problems over until all the time
            is used.

         8) Read ALL the answers before choosing one. The first one
            may be right, the second better, and the fifth one BEST!

         9) Get a good night's sleep before the test and try to see
            the test as a fun challenge.

        10) If there is some fact you have trouble with, study it up
            until you go into the test room. As soon as you are given
            paper, write the information down.

./ ADD NAME=TRACE    0100-91361-91361-0800-00300-00300-00000-USER02
FOLLOWING IS AN APAR MADE BY IBM TO DESCRIBE THE GETMAIN/FREEMAIN TRACE
FACILITY BUILT INTO THE OPERATING SYSTEM. THIS PROVIDES A MUCH MORE
COMPLETE TRACE THAN DOES GTF TRACING OF SVC'S, AS MANY STORAGE REQUESTS
ARE DONE BY BRANCH ENTRY, AND WILL NOT BE SEEN BY GTF.

  APAR Identifier ...... OY19890      Last Changed ........ 91/10/28

  GETMAIN FREEMAIN TRACE NOT DOCUMENTED IN JBB3311

  PROBLEM CONCLUSION:
  THE GETMAIN FREEMAIN TRACE IN MVS/ESA (ALL RELEASES) IS
  INCLUDED IN THE MVS NUCLEUS CODE. IT IS ONLY NECESSARY TO
  ENABLE THE TRACE VIA EITHER THE 'TRACEON' AND 'TRACEOFF'
  PROGRAMS AVAILABLE VIA IBMLINK (APARFIX PANEL), OR VIA SZAP
  AND REIPL. THIS REPLACES APAR 'AZ93349' FOR MVS/XA.

  THE GETMAIN, FREEMAIN, STORAGE TRACE IS A DIAGNOSTIC TOOL THAT
  COLLECTS INFORMATION ABOUT REQUESTS FOR VIRTUAL STORAGE.
  INFORMATION ABOUT EVERY USE OF THE GETMAIN, FREEMAIN, OR
  STORAGE MACROS CAN BE COLLECTED.

  THIS TRACE IS NOT INTENDED TO BE USED IN DEBUGGING PROBLEMS
  INTERNAL TO THE VSM COMPONENT OF MVS. IT IS INTENDED TO BE
  USED TO ANALYZE THE ALLOCATION OF VIRTUAL STORAGE AND CAN BE
  USED TO IDENTIFY PROBLEMS. FOR INSTANCE, IT CAN BE USED TO
  IDENTIFY USERS OF LARGE AMOUNTS OF VIRTUAL STORAGE.

  THE GM/FM TRACE WILL BE STARTED, STOPPED AND MODIFIED VIA
  DIRECT MODIFICATION OF NUCLEUS RESIDENT CONTROL STRUCTURES.
  THE SUGGESTED METHOD OF ACCOMPLISHING THIS MODIFICATION VIA
  PROGRAMS TRACEON AND TRACEOFF AVAILABLE IN IBMLINK (CAN BE
  PULLED ON IBMLINK ON THE APARFIX PANEL OF THE SRD OPTION).

  NOTE: THE TRACEON AND TRACEOFF PROGRAMS ARE SUPERVISOR STATE
  KEY0 PROGRAMS THAT NEED TO BE MODIFIED TO TRACE THE PROPER
  ASID (IF KNOWN, DEFAULT IS TRACE ONLY ASID1) AND PROPER
  SUBPOOLS (DEFAULT IS GLOBAL SUBPOOLS). THE PROGRAMS THEN NEED
  TO BE ASSEMBLED AND LINKED INTO AN AUTHORIZED LIBRARY, AND
  EXECUTED. THE TRACEON PROGRAM WHEN EXECUTED WILL GO TO THE MVS
  NUCLEUS AND TURN ON THE TRACE CONTROL BITS TO TURN ON THE
  TRACE, AND SET THE ASID/SUBPOOLS TO TRACE FIELDS. THE CHANGES
  MADE VIA THE TRACEON PROGRAM WILL ONLY BE IN AFFECT FOR THE
  CURRENT IPL.

  GENERALIZED TRACE FACILITY (GTF) WILL BE USED TO RECORD THE
  DATA COLLECTED ABOUT EACH REQUEST TO GET OR FREE STORAGE. GTF
  WILL ASSIGN THE USER EVENT ID 'F65' TO VSM. THIS IS AN ID FROM
  THE RANGE RESERVED FOR IBM COMPONENTS AND SUBSYSTEMS. THE
  GM/FM TRACE RECORDS WILL BE PRODUCED ONLY WHEN GTF IS ACTIVE
  AND IS TRACING EVENT NUMBER 'F65'.

  THE USER WILL HAVE THE ABILITY TO CONTROL WHAT THE GM/FM TRACE
  PRODUCES. THE USER CAN:

  +  TURN THE TRACE ON AND OFF. (INITIAL STATE IS "OFF")

  +  REQUEST THAT ONLY THOSE ATTEMPTS TO GET OR FREE STORAGE
     THAT INVOLVE A USER DEFINED SET OF SUBPOOLS BE TRACED.
     (THE DEFAULT IS TO PRODUCE A TRACE ENTRY FOR ONLY THE CSA
     SUBPOOLS.)

  +  REQUEST THAT ONLY THOSE ATTEMPTS TO GET OR FREE STORAGE IN
     THE USER DEFINED SET OF ADDRESS SPACES BE TRACED. (DEFAULT
     IS TO PRODUCE A TRACE ENTRY ONLY FOR ASID 1.)

  +  REQUEST THAT THE TRACE RECORD CONTAIN ANY COMBINATION OF
     THE FOLLOWING DATA: (A DEFAULT TRACE RECORD WILL CONTAIN
     ALL)
     - REGISTERS AT ENTRY TO VSM
     - RETURN ADDRESS OF CALLER
     - VSM INTERNAL RETURN CODE
     - REQUEST TYPE
       -GET/FREE
       -LIST/VARIABLE/ELEMENT
       -BRANCH/SVC/PC
     - ASSOCIATED SVC NUMBER
     - STARTING ADDRESS OF STORAGE BEING OBTAINED OR FREED
     - ACTUAL, MINIMUM AND MAXIMUM LENGTH OF THE STORAGE BEING
       OBTAINED OR FREED
     - SUBPOOL AND KEY
     - FLAGS FROM THE VSWK
     - ASID
     - TCB ADDRESS
     - TIME STAMP

  THE DATA LISTED ABOVE WILL BE WRITTEN IN A 'KEY/LENGTH/DATA'
  FORMAT. THIS WILL ALLOW THE USER TO RECORD ONLY DATA THEY
  CONSIDER PERTINENT. THIS SHOULD HELP PERFORMANCE WHEN THE
  TRACE IS ON, AND HELP DEBUGGING BY ELIMINATING SUPERFLUOUS
  INFORMATION.

  *** INVOKING THE GETMAIN/FREEMAIN TRACE ***

  THE USER WILL CONTROL THE GM/FM TRACE BY ALTERING INFORMATION
  CONTAINED IN THE NUCLEUS AND THE GDA. A BIT IN THE GDA WILL
  TURN ON AND OFF, AND A NUCLEUS RESIDENT, DATA-ONLY CSECT NAMED
  IGVTRCTL WILL CONTAIN THE GM/FM TRACE CONTROL DATA. (TRACE
  CONTROL DATA CONSISTS OF AN ASID LIST, A SUBPOOL LIST,
  'WHAT-TO-TRACE' INDICATORS, AND A ZAPABLE ON/OFF BIT.).

  *** HOW TO MODIFY THE GETMAIN/FREEMAIN TRACE ***

  THE GM/FM TRACE DATA AREAS RESIDE IN THE DATA-ONLY CSECT
  IGVTRCTL, WHICH IS IN THE NUCLEUS. TO CONTROL THE GM/FM TRACE,
  THE USER CAN USE SUPERZAP TO MODIFY THE GM/FM TRACE DATA, AND
  THEN RE-IPL. MODIFICATIONS MADE TO THE GM/FM TRACE IN THIS WAY
  WILL PERSIST ACROSS IPLS.

  IT IS ALSO POSSIBLE TO UPDATE THE DATA AREAS IN STORAGE BY
  WRITING A SUPERVISOR STATE, KEY ZERO PROGRAM. (THIS AVOIDS AN
  IPL.) THE GM/FM TRACE ANCHOR BLOCK (TRAC), WHICH MUST BE USED
  TO FIND THE OTHER GM/FM TRACE DATA STRUCTURES, IS POINTED TO
  BY GDATRAC. MODIFICATIONS MADE TO THE GM/FM TRACE IN THIS WAY
  WILL NOT PERSIST ACROSS IPLS.

  NOTE THAT USING EITHER ONE OF THESE METHODS IS ACCEPTABLE -
  THERE IS NO NEED TO USE BOTH.

  *** STARTING AND STOPPING THE GETMAIN/FREEMAIN TRACE ***

  THE SUGGESTED METHOD OF STARTING/STOPPING THE GETMAIN/
  FREEMAIN TRACE IS BY EXECUTING PROGRAM 'TRACEON' (AVAILABLE
  VIA IBMLINK). THIS PROGRAM IS A SUPERVISOR STATE/KEY0 PROGRAM
  WHICH (WHEN EXECUTED) WILL ZAP THE TRACE CONTROL BITS ON IN
  THE MVS NUCLEUS AND ALSO SET THE ASID TO BE TRACED AND
  SUBPOOLS TO BE TRACED FIELDS. IF YOU ARE USING TRACEON AND THE
  TRACEOFF PROGRAMS, THE REMAINDER OF THE INSTRUCTIONS FOR
  ZAPPING DO NOT NEED TO BE USED, THE PROGRAM(S) DO THE UPDATES
  TO THE APPROPRIATE FIELDS FOR YOU WHEN FILLED IN.

  HOWEVER, IF YOU WISH TO ZAP THE TRACE ON, PER THE FOLLOWING
  INSTRUCTIONS, PLEASE NOTE THAT BIT 'TRAC_GFSTR' TO '1'(START)
  OR '0' (STOP) IN CSECT IGVTRCTL IN SYS1.NUCLEUS MUST BE
  MODIFIED AND AFTER MODIFICATION OF THE TRACE OPTIONS, AN IPL
  MUST BE DONE.

  NOTE: THE GM/FM TRACE USES GTF TO RECORD ITS DATA. THUS, GTF
  MUST BE STARTED IN ORDER TO ALLOW THE GM/FM TRACE TO PRODUCE
  OUTPUT. THE GTF USER EVENT ID ASSIGNED TO THE GM/FM TRACE IS
  X'F65', AND NEEDS TO BE ACTIVE WHEN THE TRACE IS ON.

  *** FILTERING BY ASID ***

  THE GM/FM TRACE CAN BE PREVENTED FROM TRACING ATTEMPTS TO GET
  AND FREE STORAGE THAT INVOLVE ASIDS OF NO INTEREST. TO DO
  THIS, THE USER MUST TELL THE GM/FM TRACE WHICH ASIDS ARE OF
  INTEREST. DO THIS BY MODIFYING THE GM/FM TRACE ASID LIST
  (TRAS). (SEE FIGURE 1) THE GM/FM TRACE COLLECTS DATA ABOUT A
  PARTICULAR ATTEMPT TO GET OR FREE STORAGE ONLY IF THE ATTEMPT
  INVOLVES AN ASID ON THIS LIST.

  MODIFY THE TRAS BY INSERTING THE ASIDS OF INTEREST IN THE LIST
  IN HEXIDECIMAL. THE NUMBER OF ASIDS (IN DECIMAL), TO BE TRACED
  MUST BE PLACED IN THE COUNT FIELD.

  A COUNT FIELD OF ZERO IN THE LIST CAUSES NO FILTERING BY ASID
  TO OCCUR. ALL ATTEMPTS AT GETTING OR FREEING STORAGE ARE
  TRACED, REGARDLESS OF THE ASID INVOLVED.

  *** FILTERING BY SUBPOOL ***

  THE GM/FM TRACE CAN BE PREVENTED FROM TRACING ATTEMPTS TO GET
  AND FREE STORAGE THAT INVOLVE SUBPOOLS OF NO INTEREST. TO DO
  THIS, THE USER MUST TELL THE GM/FM TRACE WHICH SUBPOOLS ARE
  OF INTEREST. DO THIS BY MODIFYING THE GM/FM TRACE SUBPOOL LIST
  (TRSP) AND/OR THE GM/FM TRACE SUBPOOL RANGE LIST (TRSR) (SEE
  FIGURE 1). THE GM/FM TRACE COLLECTS DATA ABOUT A PARTICULAR
  ATTEMPT TO GET OR FREE STORAGE ONLY IF THE ATTEMPT INVOLVES A
  SUBPOOL ON ONE OF THESE LISTS.

  MODIFY THE TRSP BY INSERTING THE SUBPOOLS OF INTEREST IN THE
  LIST. THE NUMBER OF SUBPOOLS (IN DECIMAL) MUST BE PLACED IN
  THE COUNT FIELD.

  MODIFY THE TRSR BY INSERTING THE PAIRS OF SUBPOOLS IN THE
  LIST. EACH PAIR DEFINES A RANGE OF SUBPOOLS. ATTEMPTS TO GET
  OR FREE STORAGE THAT ARE ASSOCIATED WITH A SUBPOOL IN A RANGE
  DEFINED BY ANY OF THE SUBPOOL PAIRS ON THE LIST PRODUCES A
  TRACE RECORD. THE NUMBER OF SUBPOOL PAIRS (IN DECIMAL) MUST BE
  PLACED IN THE COUNT FIELD.

  A COUNT FIELD OF ZERO IN BOTH LISTS (TRSP AND TRSR) CAUSES NO
  FILTERING BY SUBPOOL TO OCCUR.  ALL ATTEMPTS AT GETTING OR
  FREEING STORAGE ARE TRACED, REGARDLESS OF THE SUBPOOL
  INVOLVED.

  *** CHOOSING THE DATA THAT THE GETMAIN/FREEMAIN TRACE COLLECTS

  A BITSTRING, TRAC_WFLG, CONTROLS WHAT DATA THE GM/FM TRACE
  COLLECTS. TURNING A PARTICULAR BIT ON ('1'B) CAUSES THE GM/FM
  TRACE TO INCLUDE THE PIECE OF DATA ASSOCIATED WITH THAT BIT IN
  THE TRACE RECORDS IT CREATES. THE LIST BELOW DESCRIBES WHAT
  DATA IS ASSOCIATED WITH EACH BIT. SEE FIGURE 2 FOR THE LAYOUT
  OF THE OUTPUT.

  BIT00 - REGISTERS AT ENTRY TO VSM
  BIT01 - RETURN ADDRESS OF CALLER
  BIT02 - VSM INTERNAL RETURN CODE
  BIT03 - REQUEST TYPE
  BIT04 - ASSOCIATED SVC NUMBER
  BIT05 - STARTING ADDRESS OF STORAGE BEING OBTAINED OR FREED
  BIT06 - ACTUAL, MINIMUM AND MAXIMUM LENGTH OF THE STORAGE
          OBTAINED OR FREED
  BIT07 - SUBPOOL AND KEY
  BIT08 - FLAGS FROM THE VSWK
  BIT09 - ASID
  BIT10 - TCB ADDRESS
  BIT11 - TIME STAMP

  THE REMAINING BITS ARE RESERVED AND UNUSED AT THIS TIME.

                      FIGURES 1 AND 2 FOLLOW

              FIGURE 1: ASID AND SUBPOOL LIST LAYOUT

  NOTE: OFFSETS ARE FROM CSECT IGVTRCTL IN SYS1.NUCLEUS(IEANUC01)

  OFFSET:
  18      1C         20    22    24        3E
  ---------------------------------------------------
  |T R A S|# OF ASID'S|ASID|ASID|ASID|     |ASID
  |       |  ON LIST  |01  |02  |03  |.....|16
  |       |(DECIMAL)  |HEX |HEX |HEX |     |HEX
  |-------|-----------|----|----|----|-----|----------


  OFFSET:
  40      44        48     49    50         57
  ----------------------------------------------------
          |PAIRS ON  |01   |02   |           |31  |32   |
          |LIST      |HEX  |HEX  |...........|HEX |HEX  |
          |(DECIMAL) |     |     |           |    |     |
  --------|----------|-----|-----|-----------|----|-----|


  OFFSET:
  80      84                8C     90    94    98
  -------------------------------------------------------
  T R A C |'WHAT TO TRACE'  |TRAS  |TRSP |TRSR |B
          |     FLAGS       |ADDR  |ADDR |ADDR |I
          |                 |      |     |     |T
          |                 |      |     |     |0
  --------|-----------------|------|-----|-----|----------
                                                |
                                                |
                             TRAC_GFSTR  --------
                            (START/STOP BIT)

  FIGURE 2:LAYOUT OF GTF RECORD PRODUCED BY THE GM/FM TRACE

           LENGTH
           OF
  EBCIDC   RECORD                     DATA
  KEY (4   (2-BYTES)
  BYTES)   HEX
  -------------------------------------------------------------
  R E G S |0040|REG13|REG14|REG15|REG0|                    |REG12
          |    |     |     |     |    |....................|
  --------|----|-----|-----|-----|----|--------------------|-----
  R E T A |0004| CALLERS RETURN ADDRESS
          |    |
  --------|----|-------------------------------------------------
  R E T C |0001| VSM
          |    | RETURN
          |    | CODE
  --------|----|-------------------------------------------------
  ENTRY   |0000| ENTRY TYPE IS EITHER:
  TYPE    |    | 'SVC'  => SVC ENTRY      'PC' => STORAGE REQUEST
          |    | 'GLBR' => GLOBAL BRANCH  'LCBR'=> LOCAL BRANCH
  --------|----|-------------------------------------------------
  'GET'   |    |
   OR     |0000| DENOTES A GETMAIN OR FREEMAIN ENTRY
  'FREE'  |    |
  --------|----|-------------------------------------------------
  REQUEST |0000| REQUEST TYPE IS EITHER:
   TYPE   |    | 'LIST'=> LIST REQUEST       'ELE'=> ELEMENT
          |    | 'VAR' => VARIABLE LENGTH            REQUEST
          |    |           REQUEST
  --------|----|-------------------------------------------------
  S V C N |0001|SVC NUMBER (HEX 78 FOR PC ENTRY)
  --------|----|-------------------------------------------------
  S T G A |0004|STORAGE ADDRESS (ADDRESS RETURNED FROM VSM ON
          |    |GETMAIN, OR ADDRESS TO BE FREEMAINED)
  --------|----|-------------------------------------------------
  S T G L |000C|ACTUAL LENGTH|MINIMUM|MAXIMUM|
          |    |             |LENGTH |LENGTH |
          |    |             |OR 0   |OR 0   |
  --------|----|-------------------------------------------------
  S P K Y |0003|SP/KEY
  --------|----|-------------------------------------------------
  P F L G |0001|FLAGS FROM VSWKPFLG
  --------|----|-------------------------------------------------
  A S I D |0002|ASID #
  --------|----|-------------------------------------------------
  T C B   |0004|TCB ADDRESS
  --------|----|-------------------------------------------------
  T I M E |0004|TIMESTAMP
  --------|----|-------------------------------------------------

  SRLS:      LY28-1809-0
./ ADD NAME=TRACEBR  0100-02092-02092-1417-00043-00043-00000-BC0THOR
                        Tracing Wild Branches Using SLIP and GTF

         1. Build an SBT SLIP trap to trace all branches to a
            particular location. An example, which would show all
            branches to offset +AC in a module named DXT0230U in the
            private area running under the jobname RUX1077W and
            writing trace records containing standard data (STD) and
            registers (REGS) would be:

                 SLIP SET,SBT,A=TRACE,TRDATA=(STD,REGS),J=RUX1077W,
                      PVTMOD=(DXT0230U,AC,AC),ID=RNT1,END

         2. If a dump is desired in addition, use A+TRDUMP and add the
            dump condition (such as C=0C4). A range of offsets may be
            traced. To trace all references between +86 and +148, use
            PVTMOD=(DXT0230U,86,148).

         3. When the SLIP trap is entered, a message will indicate it
            is active, but that GTF is not active.

         4. Start GTF and specify:
                 TRACE=SLIP,JOBNAMEP
                 JOBNAME=RUX1077W
                 END

         5. On completion, stop the GTF run (and the SLIP trap, if
            necessary). The SLIP trap will notify you the first time
            there is a hit, but not after that.

         6. Using IPCS, point to the GTF trace dataset and on the
            COMMAND screen (4) enter GTF. Say yes when asked if the
            dataset contains only trace data.

         7. The standard SLIP trace records (S+U) contain the branch
            information as follows:

               IADR: The address of the branch instruction to
                     DXT0230U+AC
               INS:  The branch instruction itself, in hex.
               OPSW: The PSW, as updated by the branch instruction.
                     The PSW address should therefore be the address
                     of the instruction being traced.

./ ADD NAME=UPDMEM   0100-02092-02092-1417-00056-00056-00000-BC0THOR
                             UPDMEM
                      READ/REWRITE PDS (IN PLACE)

  PERMITS ACCESS TO A PDS HAVING 80-BYTE LOGICAL RECORDS. CALLER MUST
  CALL FIRST TO OPEN THE PDS, THEN CALL TO FIND (POSITION TO) THE
  DESIRED MEMBER, THEN CALL TO READ 80-BYTE LOGICAL RECORDS FROM THE
  PDS MEMBER. IF A RECORD IS TO BE UPDATED, THE CALL FOLLOWING THE
  READ MUST BE A CALL TO UPDATE, PASSING THE UPDATED RECORD. WHEN END
  OF MEMBER IS FOUND WHILE READING, THIS ROUTINE RETURNS X'FF' IN THE
  FIRST POSITION OF THE RECORD AREA.

  TWO PARAMETERS ARE PASSED AT EACH CALL. THE FIRST CONTAINS THE
  REQUEST CODE, AND IS FOLLOWED BY ANOTHER FIELD FOR OPEN AND FIND.
  THE SECOND PARAMETER IS THE USER'S RECORD AREA IN WHICH THE RECORD
  IS RETURNED FOR A READ, AND WHICH CONTAINS THE UPDATED RECORD FOR
  AN UPDATE CALL.

  REQUEST CODES AND CALLING CONVENTIONS ARE, WHERE DOTS INDICATE THE
  INDICATED PARAMETER IS NOT REQUIRED FOR THE CALL:

   REQ   FIELD     RECORD
   CODE  AFTER     AREA     DESCRIPTION

    O    DDNAME    ........ OPEN THE FILE USING THE SPECIFIED DDNAME.
                            INCLUDE A DD STATEMENT IN THE JCL WITH
                            THIS DDNAME. MUST REFER TO A PDS HAVING
                            LRECL=80.
    F    TXXX      ........ POSITION TO THE MEMBER WHOSE RELATIVE
                            TRACK AND RECORD (TTR) ARE GIVEN BY THE
                            XXX FIELD FOLLOWING THE FT. THE TTR CAN
                            BE OBTAINED FROM A BLDL OR BY USING THE
                            READDIR SUBROUTINE.
    F    NCCCCCCCC ........ POSITION TO THE MEMBER WHOSE NAME FOLLOWS
                            THE FN. IF THE MEMBER IS NOT FOUND, X'00'
                            IS RETURNED IN THE FIRST BYTE OF THE
                            MEMBER NAME FIELD.
    R    ......    REC AREA READ THE NEXT RECORD IN THE MEMBER. YOU
                            MUST HAVE CALLED TO OPEN THE FILE, AND TO
                            POSITION TO THE MEMBER BEFORE CALLING TO
                            READ. IF END OF MEMBER IS FOUND, X'FF'
                            WILL BE RETURNED IN THE FIRST BYTE OF THE
                            RECORD AREA.
    U    ......    UPDT REC WRITE THE RECORD IN THE RECORD AREA OVER
                            THE LAST RECORD READ FROM THE PDS. THE
                            READ MUST IMMEDIATELY PRECEDE THE UPDATE
                            CALL.
    C    ......    ........ CLOSE THE PDS. ALWAYS DO THIS TO INSURE
                            THE LAST UPDATE IS WRITTEN.

  THE SUBROUTINE WILL TRERMINATE ABNORMALLY WITH USER ABEND CODE U201
  IF AN INVALID REQUEST CODE IS RECEIVED, IF AN F REQUEST CODE IS NOT
  FOLLOWED BY A 'N' OR 'T', OR IF AN UPDATE CALL IS NOT PRECEDED BY A
  READ.

  SEE ALSO THE READDIR AND READMEM SUBROUTINES AND PROGRAMS SUCH AS
  JCLSCAN AND CHNGACCT FOR HINTS ON USE.
./ ADD NAME=VI       0100-02092-02092-1417-00033-00033-00000-BC0THOR
                     ***** COMMANDS FOR THE AIX VI EDITOR *****

 NAVIGATION                             DELETE TEXT
    Top of File:           1G              Delete n Characters:  nx
    Bottom of File:        0G              Delete n Lines:       ndd
    Top of Screen:         H               Delete to End of Line:D
    Bottom of Screen:      L
    Up n Lines:            nk           INSERT/REPLACE TEXT
    Down n Lines:          nj              Enter INSERT Mode:    i
    Go to Line n:          nG              INSERT Mode, New Line:o
    Left of Line:          0               Enter REPLACE Mode:   R
    Right of Line:         $               Replace 1 character:  r
    Left n Spaces:         nh
    Right n Spaces:        nl           SAVE and/or END
                                           Save and Continue:    :w
 SCROLLING                                 Save and End:         ZZ
    Scroll Up 1 Page:      Ctrl-B          End without Save:     :q!
    Scroll Down 1 Page:    Ctrl-F
    Scroll Up 1 Line:      Ctrl-Y       CUT AND PASTE
    Scroll Down 1 Line:    Ctrl-E          Cut n lines:          ny
                                           Paste last lines cut: p
 SEARCH FOR STRING
    Search forward for xx: /xx          MISCELLANEOUS
    Search backward for w: ?w              Redraw Screen:        Ctrl-L
    Repeat last search:    n               Back to Command Mode: Esc
    Repeat search reversed:N               Change aBc to DeF:    :s/aBc/DeF/
    Find Matching ()[]{}:  %






./ ADD NAME=VOLLIST  0100-90191-90191-0816-00019-00019-00000-USER02
                ***** ONLINE DASD VOLUME LISTING *****

   Looks through all DASD device UCB's using the CVTUCBSC routine,
   and reads the Format 4 DSCB from each online volume using EXCP.
   The listing contains one line per device including the volume
   serial, device type, CUU address, VTOC TTR, and VTOC Index status.

         Sample JCL:

//USER02WW JOB (1234567-1234567,,TMVS01-UR-XXXX),RTHORNTON,CLASS=V,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=HDQRTRS,DEFAULT=YES,JESDS=ALL
//*******************************************************************
//* PRINT ONLINE DISK VOLUME LISTING                                *
//*******************************************************************
//VOLLIST  EXEC PGM=VOLLIST
//STEPLIB  DD DSN=TEST.LOAD,DISP=SHR
//SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=80
//SYSUDUMP DD SYSOUT=*
./ ADD NAME=VOLLIST2 0101-90191-90191-1306-00027-00024-00000-USER02
                ***** ONLINE DASD VOLUME LISTING *****

   Looks through all DASD device UCB's using the CVTUCBSC routine.
   The LSPACE macro is used to read the Format 4 DSCB and other
   VTOC related data. Since the information on disabled VTOC Index
   datasets is inconclusive in the VTOC, an OBTAIN/CAMLST is used to
   try to read the format 1 DSCB for the SYS1.VTOCIX.vvvvvv when
   indicator bits show no VTOC Index is present.
   The listing contains one line per device including the system id
   on which the job was run, volume serial number, device type, CUU
   address, VTOC TTR, volume mount status, number free Format 0
   DSCB's in the VTOC, number free VIR's in the VTOC Index, number
   free extents on the volume, total free cylinders on the volume,
   and number cylinders in the largest free extent.

         Sample JCL:

//USER02WW JOB (1234567-1234567,,TMVS01-UR-XXXX),RTHORNTON,CLASS=V,
//   NOTIFY=USER02,MSGCLASS=Y
//JESOUT OUTPUT GROUPID=HDQRTRS,DEFAULT=YES,JESDS=ALL
//*******************************************************************
//* PRINT ONLINE DISK VOLUME LISTING                                *
//*******************************************************************
//VOLLIST2 EXEC PGM=VOLLIST2
//STEPLIB  DD DSN=TEST.LOAD,DISP=SHR
//SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=80
//SYSUDUMP DD SYSOUT=*
./ ADD NAME=VSAMDIAG 0100-02092-02092-1417-00484-00484-00000-BC0THOR
  *********************************************************************
  *                                                                   *
  *                    VSAMDIAG                                       *
  *                                             VERSION    19 JUN 1978*
  *                                                        30 APR 1979*       00
  *                                                        22 NOV 1979*
  *                                FALSE ERROR CODE 24     25 MAR 1980*       00
  *********************************************************************

     A - GENERALITIES
     B - INDEX TESTS
     C - DATA TESTS
     D - PROCEDURES
     E - MESSAGES AND CODES
     F - DATA AREAS
     G - PROGRAMS ORGNAIZATION



                 *****************************
                 A      GENERALITIES         A
                 *****************************

     THIS PROGRAM IS IBM PROPERTY AND IS INTERNAL USE ONLY.
     VSAMDIAG IS NOT SUPPORTED, BUT ANY PROBLEM ENCOUNTERED WILL
     WILL BE LOOKED AT ON A BEST EFFORT BASIS. PLEASE SUBMIT THE
     PORTABLE FAILING DATA SET TO: VSAM CT.  ATTN. JERRY GREY.
     THE INSTALL DECK CONTAINS THE OBJECT DECK FOR VSAMDIAG AND
     THE NECESSARY LINKAGE EDITOR CONTROL CARDS TO LINK VSAMDIAG
     INTO SYS1.LINKLIB WITH AUTHORIZATION.

     VSAMDIAG IS A FIELD DEVELOPED VSAM DATA SET DIAGNOSTIC
     PROGRAM. IT IS MAINLY DESIGNED TO EXAMINE SEPARATLY THE INDEX
     COMPONENT AND THE DATA COMPONENT OF A VSAM KSDS.
     EXAMINATION OF THE INDEX COMPONENT IS MAINLY DONE BY A
     CROSS-CHECKING OF THE VERTICAL AND HORIZONTAL POINTERS IN
     THE INDEX CI'S AND FURTHER CHECKING THE WHOLE DATA COMPONENT
     DESCRIBED BY THE INDEXES.
     EXAMINATION OF THE DATA COMPONENT IS DONE BY LOGICAL SEQUENTIAL
     READING OF ALL THE DATA CI'S ALLOCATED, EVEN FOR FREE SPACE CI'S.
     RECORD IS CHECKED, AS WELL AS KEY SEQUENCE AND FREE SPACE GOOD
     ERASURE. UPDATE INTEGRITY OF SPANNED RECORDS IS ALSO CHECKED.
     VSAMDIAG DOES NOT MODIFY ANYTHING IN THE DATA SET, BUT ONLY
     INDICATES IF THERE IS A DATA INTEGRITY PROBLEM, AND WHAT IS
     WRONG IN THAT CASE.
     VSAMDIAG CAN ALSO SEARCH THROUGH THE INDEXES TO RETRIEVE THE
     CI OF EACH LEVEL IN WHICH A KEY GIVEN AS AN ARGUMENT SHOULD BE.
     THIS IS ACCOMPLISHED BY HORIZONTAL SCANNING OF THE INDEX, AND
     IS COMPLIMENTARY OF OTHER USUAL GET DIRECT METHODS. YOU CAN
     ALSO RETRIEVE THE DATA CI THAT SHOULD CONTAINE THE GIVEN KEY.


                       ********************
                       B  INDEX TESTS     B
                       ********************

     1-HIGH LEVEL INDEX NOT UNIQUE
     2-HORIZONTAL POINTER POINTING TO ITSELF
     3-INDEX LEVELS INTERMIXED
     4-MISSING CI IN HORIZONTAL CHAIN
     5-MISSING VERTICAL POINTER(S)
     6-LONG LOOP IN HORIZONTAL CHAIN
     7-DUPLICATE VERTICAL POINTER
     8-DUPLICATE BASE RBA IN SEQUENCE SET
     9-DUPLICATE KEYS IN THE INDEXES
     10-OUT-OF-SEQUENCE KEYS IN THE INDEXES
     11-SEOF INSIDE THE INDEX COMPONENT
     12-DATA CI NOT DESCRIBED BY INDEXES
     13-BAD HIGH LEVEL INDEX RBA
     14-BAD FIRST SEQUENCE SET INDEX RBA VALUE
     15-INCORRECT HIGH USED RBA IN DATA
     16-INCORRECT HIGH USED RBA IN INDEX
     17-INCONSISTENT EXTENT ALLOCATION
     18-LOSS OF A CI IN THE INDEX
     19-LOSS OF A CA IN THE DATA
     20-HORIZONTAL CHAIN BROKEN IN ANY INDEX LEVEL
     21-INCORRECT BASE RBA IN T THE SEQEUNCE SET
     22-TOO MANY POINTERS IN THE SEQUENCE SET

        RUNNIG ON A MODEL 168 UP, THE INDEX TEST TAKES LESS
      TWO MINUTES ELAPSED TIME FOR A KSDS WITH ABOUT 50,000
      DATA CIS. (IE: ONE MILLION 200 BYTE RECORDS)

                     **********************
                     C   DATA  TESTS      C
                     **********************

     1-INCONSISTENT CIDF IN A FREE SPACE CI
     2-SEOF IN A FREE SPACE CI
     3-FREE SPACE CI NOT EMPTY
     4-SOME RDF ERRORS
     5-DATA CI OVERFLOW
     6-UPDATE FAILURE IN SEGMENTS OF A SPANNED RECORD
     7-INCOMPLETE SPANNED RECORD
     8-INCORRECT KEY SEQUENCE
     9-SEOF IN A DATA CI
     10-RECORD LONGER THAN MAXIMUM RECORD LENGTH
     11-MISSING ENDING SEOF
     12-SOME DATA IN A FREE SPACE CI
       AS THE DATA TESTS MUST READ ALL THE DATA CI'S, IT USES
     ASYNCHRONOUS PROCESSING TO OPTIMIZE ITS PERFORMANCE. YOU CAN
     SPECIFY, IN THE SYSIN DDCARD, THE NUMBER OF BUFFERS THAT YOU
     WISH IN ORDER TO OBTAIN THE BEST PASS TIME. THE DEFAULT VALUE
     OF THREE SHOULD BE GOOD IN MOST CASES. NOTE, TOO MANY BUFFERS
     MAY RESULT IN EXCESSIVE PAGINATION.


        TO ESTIMATE THE NECESSARY TIME TO RUN THE DATA TEST,
      GET THE HURBA(HIGH USED RBA) AND THE DATA CISIZE FROM
      THE CATALOG FOR THE DATA SET TO TEST:

         ELAPSED TIME = (HURBA * 0.03) / CISIZE
         (IN SECONDS)
       FOR A FULL 3330, CISIZE = 1024, ABOUT ONE HOUR.

                      *********************
                      D    PROCEDURES     D
                      *********************

       JCL NEEDED
          (STEPCAT)... WHERE IS THE CLUSTER TO TEST DEFINED
          (STEPLIB)... WHERE IS VSAMDIAG
          (VSAMDS) ... DESCRIBE THE DATA SET TO TEST
          (SYSPRINT).. DIAGNOSTIC OUTPUT(IF ABSENT TO OPERATOR)
          (SNAP) ..... SNAP OF CI'S IN ERROR
                            -SNAP OF CI'S WHEN AN INPUT
                             KEY IS GIVEN
                            -SNAP OF LVLWA'S (IF SNAP OPTION)
          (SYSUDUMP).. TO GET DUMP IF DEBUG OPTION OF ABEND
          (SYSIN) .... TO GIVE PARAMETERS

      OPTIONS FOR SYSIN:
                        SNAP....-WILL PROVIDE SNAP OF LVLWA'S
                        DEBUG...-DUMP AT INDEX TEST TERMINATION
                        INDXTEST-TO EXECUTE THE INDEX TESTS
                        DATATEST-TO EXECUTE THE DATA TESTS
                        NBUFF=NN-TO SPECIFY THE NUMBER OF BUFFERS
                                 FOR DATA TEST.(01 TO 99)
                        KEY= DCX(...)
                             DCC(...) TO SEARCH A KEY (IF DATATEST)
                                      OR SNAP ALL INDEX LEVELS
                                      CROSSED(IF INDXTEST)
         IF SYSIN NOT SPECIFIED, THE DEFAULT TEST OPTIONS ARE:
                  --NODEBUG  NOSNAP  NODATATEST INDXTEST  NBUFF=3

       KEYWORDS ARE NOT POSITIONAL. THERE ARE NO RESTRICTION ON
     THE NUMBER OF SYSIN CARDS. FOR KEY = PARAMETER, FIELD DCX(...)
     DEFINES A HEX FIELD IN THE KEY AND MUST NOT EXCEED 14 DIGITS,
     WITH AN EVEN NUMBER OF DIGITS. FIELD DCC(...) DEFINES A
     CHARACTER FIELD IN THE KEY.

       KEY FIELDS CAN BE CONCATINATED ON SEVERAL SYSIN CARDS. EACH
     CARD CONTAINING A PORTION OF THE KEY MUST BEGIN WITH KEY =.
     LENGTH OF THE KEY SEARCHED IS THE TOTAL LENGTH OF THE KEY
     FIELDS. MAXIMUM LENGTH IS 256.

       EXAMPLE SYSIN CARD:
         //SYSIN DD *
           SNAP  INDXTEST KEY= DCX(03274C)
           KEY= DCC(ABCDEF)  DCC(GHI) DCX(FF0011)
           KEY= DCC(JKL   MN)       DEBUG
        OPTIONS IN EFFECT:
               SNAP   INDXTEST   DEBUG

        THE KEY SEARCHED FOR IS:
           03274CC1C2C3C4C5C6C7C8C9FF0011D1D2D3404040D4D5
         WITH A KEY LENGTH OF 23.

         NOTE: IF THE KEY USED AS THE ARGUMENT IS TO BE COMPARED
               WITH LONGER KEYS, IT IS REAR PADDED WITH FFFF.


                    *******************************
                    E    MESSAGES  AND CODES      E
                    *******************************

     001 ... DS TESTED IS NOT A KSDS
         ATTEMPTED TO RUN VSAMDIAG ON A NON-KSDS FILE.

     002 ... DS WAS NOT CLOSED - LEFT OPEN -
         VSAMDIAG FOUND THAT THE CLUSTER WAS NOT PROPERLY CLOSED.
         THE ONLY TEST DONE IS ON THE ARDB CHAIN, AND THE CLUSTER
         IS LEFT OPEN.

     003 ... DS WAS NOT CLOSED - WAS IN CREATE MODE
         VSAMDIAG FOUND THAT THE CLUSTER WAS NOT PROPERLY CLOSED,
         AND WAS IN LOAD/CREATE MODE. IN THIS CASE VERIFY WILL ONLY
         SET THE HIGH USED RBA TO ZERO. THE CLUSTER MUST BE RECREATED.

     004 ... DATA COMP CONTAINS NN% FREE CI REUSABLE
         THIS MESSAGE WILL APPEAR WHEN THERE IS NO SEVERE ERROR. IT
         GIVES THE PERCENTAGE OF FREE SPACE IN THE DATA COMPONENT.

     005 ... ** INDEX INTEGRITY PROBLEM DETECTED **
         VSAMDIAG DETECTED AN ERROR IN THE INDEX COMPONENT. THERE
         COULD BE AN EXPOSURE TO LOSE DATA IF USING STANDARD
         RECOVERY PROCEDURES OR VERIFY. INDEXES MUST BE EXAMINED
         WITH THE HELP OF THE CONCURRENT MSG 00I, BEFORE USING THE
         CLUSTER. SAVE THE CLUSTER VIA IEHDASDR IF POSSIBLE.

     006 ... ** NO ERROR DETECTED IN INDEXES **
         IT'S OK, BUT DON'T FORGET DATATEST .. IF YOU DOUBT

     007 ... GETMAIN ERROR RC NNNN
         VSAMDIAG UNABLE TO OBTAIN STORAGE FOR LVLWAS. THE DATA SET
         IS PROBABLY TOO LARGE FOR THE REGION SPECIFIED. INCREASE
         REGION SIZE OR EXAMINE THE RETURN CODE NNNN(GETMAIN R15)

     008 ... ** WARNING ** SAVE DS VIA IEHDASDR BEFORE ANY USE
         ...DO NOT RUN VERIFY
         PLEASE, DO IT.

     009 ... ** SEVERE ERROR; NO FURTHER PROCESS DONE **
         VSAMDIAG ENCOUNTERED A SEVERE ERROR AND COULD NOT CONTINUE
         TESTING. ABEND CODE IS U002. LOOK FIRST IN MSG LOG FOR A
         POSSIBLE OPEN RETURN CODE FROM VSAM. IF NOT, THIS MESSAGE
         MUST BE PROCEDED BY MSG 00I.

     010 ... ** NO ERROR DETECTED IN DATA **
         VSAMDIAG DID NOT DETECT ANY ERRORS IN THE DATA COMPONENT.

     011 ... DATA COMP CONTAINS NNNNNNNN RECORDS
         ALL THESE RECORDS CONTAIN VALID AND IN-SEQUENCE KEYS.

     012 ... DATA COMP CONTAINS NNNNNNNN DELETED CI(S)
         THE COUNT OF CI'S IN WHICH ALL RECORDS HAVE BEEN DELETED.
         THESE CI'S ARE NOT AVAILABLE AS FREE SPACE, AND WILL ONLY
         BE REUSED IF RECORDS INSERTED CONTAIN KEYS THAT ARE IN
         THE OLD RANGE OF KEYS FOR THAT CI.

     013 ... ** DATA INTEGRITY PROBLEM DETECTED **
         VSAMDIAG DETECTED AN ERROR IN THE DATA COMPONENT.
         THERE IS AN EXPOSURE TO LOSE DATA IF USING STANDARD
         RECOVERY PROCEDURES. YOU SHOULD PRINT THE ENTIRE CA
         IN ERROR BEFORE MODIFYING THE DATA SET.

     014 ... PROBABLE LOOP IN HORIZONTAL POINTERS
         ... RUN INDEX TEST
         VSAMDIAG IS PROTECTED AGAINST POSSIBLE HORIZONTAL POINTER
         LOOP IN THE SEQUENCE SET WHEN RUNNING DATATEST. YOU SHOULD
         RUN INDXTEST PRIOR TO DATATEST.

     015 ... SEOF INSIDE SEQUENCE SET - RUN INDEX TEST
         WHILE RUNNING DATATEST, VSAMDIAG ENCOUNTERED AN UNEXPECTED
         SEOF IN THE SEQUENCE SET. INDXTEST SHOULD BE RUN PRIOR TO
         TO DATATEST. THE DIAGNOSTIC WILL BE MORE ACCURATE.

     016 ... KEY SEACRH OK * SSRBA N/A * CIRBA N *
         THE KEY PASSED VIA SYSIN HAS BEEN FOUND. N IS THE RBA OF
         THE DATA CI CONTAINING THE RECORD. IF YOU GAVE A SNAP DD,
         THIS CI IS SNAPPED.

     00D ... ERROR CODE NN * SSRBA N1 * CIRBA N2 *
         VSAMDIAG DETECTED AN ERROR IN DATA COMPONENT CHECKING.
         FIELD N1 IS THE RBA OF THE SEQUENCE SET INDEX CI, AND
         FIELD N2 IS THE RBA OF THE CURRENT DATA CI. SEE NN ERROR
         CODE IN THE TABLE BELOW.

     100 ... ** REC MANAGEMENT ERROR - RPL FDBK = NNNNNN
         THERE WAS A BAD RETURN CODE ON A GETIX MACRO. IF YOU
         RAN WITH THE DEBUG OPTION YOU MAY FIND WHY YOU GOT THE
         NNNNNN RETURN CODE IN THE RPL.

     00I ... ERROR CODE NN * CIN/I-RBA N1 LVL N2 * CIN/-RBA N3
         ... LVL N4 * RBA N5 * RBA N6
         VSAMDIAG DETECTED AN ERROR IN CROSS TESTING THE INDEXES.
         FIELDS N1,N2,N3,N4,N5,N6, VARIES UPON THE ERROR CODE AND
         ARE EXPLAINED IN THE TABLE BELOW.

         ERROR CODE TABLE FOR MESSAGE 00I:
      X AFTER THE ERROR CODE INDICATES A SEVERE ERROR, AND VSAMDIAG
      TERMINATES TESTING.

      N1,N3 ARE THE CI NUMBER AND RBA IN HEX.
      N2,N4 ARE THE INDEX LEVELS.
      N5,N6 ARE THE RBA IN HEX.
    ________________________________________________________________
    | 02- | HI USED RBA NOT ON CI BOUNDARY      | NONE             |
    |     | DATA COMPONENT                      |                  |
    | 03- | HI ALLOCATED RBA NOT ON CI BOUNDARY | NONE             |
    |     | DATA COMPONENT                      |                  |
    | 04- | HI USED RBA GREATER THAN HI ALLOC.  | NONE             |
    |     | DATA COMPONENT                      |                  |
    | 05- | HI USED RBA NOT ON CA BOUNDARY      | NONE             |
    |     | DATA COMPONENT                      |                  |
    | 06- | HI ALLOCATED RBA NOT ON CA BOUNDARY | NONE             |
    |     | DATA COMPONENT                      |                  |
    | 07- | HI USED RBA GREATER THAN HI ALLOC.  | NONE             |
    |     | INDEX COMPONENT                     |                  |
    | 08- | HI USED RBA NOT ON CI BOUNDARY      | NONE             |
    |     | INDEX COMPONENT                     |                  |
    | 09- | HI ALLOCATED RBA NOT ON CI BOUNDARY | NONE             |
    |     | INDEX COMPONENT                     |                  |
    | 10- | HI LEVEL INDEX NOT UNIQUE           | N1 IS HI LVL IX  |
    |     |                                     | N3 IS HHP FOUND  |
    | 11-X| INDEX LEVELS INTERMIXED             | N1 IS PREVIOUS CI|
    |     |                                     | N3 IS NEXT CI    |
    | 12- | MISSING CI IN HORIZONTAL CHAIN OR   | N1 IS CI EXPECTED|
    |     | LOOP START AT CURRENT LVL(SEE 15).  |                  |
    | 13-X| CI WITH HHP POINTING TO ITSELF.     | N1 IS CI IN ERROR|
    |     |                                     |                  |
    | 14- | CI ON HORIZONTAL CHAIN NOT POINTED  | N1 IS CURRENT CI |
    |     | TO BY NEXT HIGHER LEVEL INDEX.      |                  |
    | 15-X| LONG LOOP IN HORIZONTAL CHAIN.(YOU  | N1 LAST CI IN THE|
    |     | WILL GET N ERROR12 AND ONE ERROR(15)| LOOP             |
    | 16- | BAD KEY SEQUENCE INSIDE OR          | N1 CURRENT CI    |
    |     | BETWEEN INDEXES.                    | N3 PREVIOUS CI   |
    | 17- | DUPLICATE KEYS INSIDE OR BETWEEN    | N1 CURRENT CI    |
    |     | INDEXES.                            | N3 PREVIOUS CI   |
    | 18- | BAD IXP IN A SEQUENCE SET(IXP OR    | N1 SEQ SET CI    |
    |     | FREE POINTER OUT OF CI/CA.          |                  |
    | 19- | 1ST SEQ SET RBA IN AMDSB DOES NOT   | N5 RBA FOUND     |
    |     | MATCH WITH ONE FOUND VIA IXP'S.     | N6 EXPECTED RBA  |
    | 20- | DUPLICATE IXP ON THIS LEVEL         | N2 IS THE LEVEL  |
    |     | (ONLY FOR INDEX SET).               |                  |
    | 21- | HORIZONTAL CHAIN IS TOO LONG.(TABLE | N1 IS FIRST OVER |
    |     | OVERFLOW - INTERMEDIATE LVL).       | FLOWING CI       |
    | 22- | CI IS IN NO CHAIN.(NOT POINTED TO). | NONE             |
    |     | (ALWAYS WITH ERRORS 12,14,21)       |                  |
    | 23- | BASE RBA NOT ON CA BOUNDARY         | N1 CURRENT CI    |
    |     |                                     |                  |
    | 24- | BAD INDEX HI USED.( HIGHEST RBA     | N5 RBA FOUND     |
    |     | FOUND + CISZ NOT EQUAL TO HI USED)  | N6 HI USED RBA   |
    | 25- | TOO MANY IXP'S OR FREE POINTERS     | N1 CURRENT CI    |
    |     | IN SEQ. SET(TABLE OVERFLOW).        |                  |
    | 26- | BAD DATA HIGH USED( GREATEST BRBA   | N5 COMPUTED RBA  |
    |     | FOUND + CA SIZE NOT EQUAL TO HI USED| N6 CATALOG RBA   |
    | 27-X| SEOF INSIDE INDEX.                  | N1 IS EOF CI     |
    |     |                                     |                  |
    | 28- | DATA CA NOT POINTED TO BY SEQ SET.  | NONE             |
    |     | (COUNT OF SEQ SET CIS * CA SIZE NOT |                  |
    |     | EQUAL TO DATA HIGH USED).           |                  |
    | 29- | INDEX CI(S) NOT USED IN THE INDEX.  | NUMBER OF UNUSED |
    |     | (COUNT OF CI'S READ * CISZ NOT      |                  |
    |     | EQUAL TO INDEX HIGH USED).          |                  |
    | 30- | BASE RBA IN THE UNIQUE SEQUENCE SET | NONE             |
    |     | IS INVALID.                         |                  |
    | 31- | BAD LEVEL FOUND FOR HIGH LEVEL.     | N2 EXPECTED LEVEL|
    |     | (PROCESSING CONTINUES ASSUMES HLI OK| N4 LEVEL FOUND   |
    | 37- | DATA CI NOT DESCRIBED BY THE SEQ SET| N1 SEQ SET IN ERR|
    |     | (IXP OR FREE SPACE POINTER).        |                  |
    | 66- | DUPLICATE BASE RBA IN SEQUENCE SET  | N1,N3 ARE THE    |
    |     |                                     | CI'S INVOLVED    |
    ________________________________________________________________


          ERROR CODE TABLE FOR MESSAGE 00D:

    _______________________________________________
    | 40- | BAD CIDF IN A FREE SPACE CI.          |
    |     |                                       |
    | 41- | SEOF IN A FREE SPACE CI.              |
    |     |                                       |
    | 42- | FREE SPACE CI CONTAINS SOME DATA. THE |
    |     | CIDF INDICATES AN EMPTY CI.           |
    | 43- | THERE IS SOME DATA IN REMAINING FREE  |
    |     | SPACE OF A DATA CI                    |
    | 44- | LEFT RDF WITHOUT PRECEDING RIGTH RDF  |
    |     |                                       |
    | 45- | MISSING LEFT RDF WHEN PAIRED          |
    |     |                                       |
    | 46  | DISCREPENCY IN UPDATE NUMBERS OF SPND |
    |     | RECORD SEQMENTS. PROBABLY ONE         |
    |     | SEQMENT NOT WRITTEN.                  |
    | 47- | TRUNCATED SPANNED RECORD. THE SPANNED |
    |     | RECORD IS INTERRUPTED BY A FREE CI OR |
    |     | ANOTHER RECORD.                       |
    | 48- | SEOF IN DATA CI. THIS CI IS NOT A FREE|
    |     | SPACE CI.                             |
    | 49- | MISSING FIRST SEQMENT OF A SPANNED    |
    |     | RECORD.                               |
    | 50- | DUPLICATE CONSECUTIVE KEYS IN A CI OR |
    |     | BETWEEN TWO DATA CIS.                 |
    | 51- | OUT-OF-SEQUENCE KEYS IN A CI OR       |
    |     | BETWEEN TWO CIS.                      |
    | 52- | RECORD LONGER THAN MAX LRECL.         |
    |     |                                       |
    | 53- | MISSING ENDING SEOF. (WHEN NOT AT END |
    |     | OF AN EXTENT).                        |
    | 54- | CI OVERFLOW FOR LAST RDF RECORD       |
    |     |                                       |
    | 55- | KEY SEARCHED FOR HAS NOT BEEN FOUND   |
    |     |                                       |
    _______________________________________________

    ABEND CODES:
               S000 U000 - REQUESTED BY DEBUG OPTION.
               S000 U001 - ALWAYS AFTER MSG 005 OR 013.
               S000 U002 - AFTER MSG 009 OR IF KSDS NOT CLOSED.


                      *************************
                      F    DATA  AREAS        F
                      *************************


    CI BUFFERS:
              GOTTEN VIA SNAP DD CARD. THEY ARE AUTOMATICALLY
              DUMPED WHEN AN ERRO IS FOUND ON A CI (WITH MSG
              00I OR 00D WHERE THE RBA IS GIVEN).

              DISPLACEMENTS IN HEX:

         '00'... NEXT BUFFER POINTER
         '04'... CI NUMBER IN HEX
         '08'... CORRESPONDING RBA IN HEX
         '0C'... RPL ADDRESS (ONLY FOR DATA CI BUFFERS)
         '20'... BEGINNING OF CI


    LVLWA:
              ONE PER LEVEL OF INDEX. ONLY FOR INDEX TEST.
              THE LVLWA CONTAINS THE TABLES FOR HORIZONTAL
              POINTERS, BASE RBAS, AND VERTICAL POINTERS.
              GOTTEN VIA THE SNAP PARAMETER IN SYSIN AND
              PROVIDING A SNAP DD CARD.

              DISPLACEMENTS IN HEX:

         '00'... LWANXT............PTR TO NEXT LVLWA
         '04'... LWAPRV............PTR TO PREVIOUS LVLWA
         '08'... LWAFLG............FLAGS
         '--'... LWASWKS..X'80'....SWITCH FOR KEY SEARCHING
         '--'... LWAFIL...X'40'....FIRST INDEX IN LEVEL
         '09'... LWALVL............INDEX LEVEL(ONE BYTE)
         '0C'... LWALL.............LENGTH OF LVLWA
         '10'... TITLE.............'INDEX LEVEL N '
         '20'... LWAHHN............TITLE ' HHN '
         '24'... LWAHHF............POINTER TO FIRST HHP
         '28'... LWAHHSP...........SCAN PTR FOR HHPS
         '2C'... LWAHHL............POINTER TO LAST HHP
         '30'... LWAHHE............POINTER TO END OF HHP AREA
         '34'... LWAHHCT...........COUNT OF HHPS
         '40'... LWAIXN............TITLE 'IXN'
         '44'... LWAIXF............POINTER TO FISRT IXP
         '48'... LWAIXSP...........SCAN PTR FOR IXPS
         '4C'... LWAIXL............POINTER TO LAST IXP
         '50'... LWAIXE............POINTER TO END OF IXP AREA
         '54'... LWAIXPCT..........COUNT OF IXPS
         '60'... LWABRN............TITLE 'BRBA'
         '64'... LWABRF............POINTER TO FIRST BRBA
         '68'... LWABRSP...........SCAN POINTER FOR BRBAS
         '6C'... LWABRL............POINTER TO LAST BRBA
         '70'... LWABRE............POINTER TO END OF BRBA AREA
         '74'... LWABRCT...........COUNT OF BRBAS
         '78'... LWABRGR...........LARGEST BRBA FOUND
         '80'... LWACRBA...........CURRENT RBA
         '84'... LWAFCCT...........COUNT OF FREE CIS IN SEQ SET
         '88'... LWAFCCU...........COUNT OF FREE CIS IN DATA


    IXPWA:
            FILLED WITH VERTICAL POINTERS FOR EACH SEQUENCE SET CI.
            USED ONLY IN DATA TEST.

            DISPLACEMENTS IN HEX:
         '00'... IXPLL.............LENGTH OF IXPWA
         '04'... IXPT..............TITLE ' IXP '
         '08'... IXPF..............POINTER TO FIRST IXP
         '0C'... IXPSP.............SCAN POINTER TO IXPS
         '10'... IXPL..............POINTER TO LAST IXP
         '14'... IXPBRBA...........CURRENT BASE RBA
         '20'... IXPIXP............BEGINNING OF IXP ENTRIES
         DLMTR EQU X'FFFFFFFF'  DELIMITER BETWEEN FREE SPACE
                                ENTRIES AND DATA CI ENTRIES.


                     *******************************
                     G   PROGRAM  ORGANIZATION     G
                     *******************************

       VSAMDIAG IS ORGANIZED INTO ONE LOAD MODULE MADE UP OF
       THREE MODULES, EACH CONTAINING ONE CSECT.

       LOAD MODULE NAME ......... VSAMDIAG
       MODULE LENGTH............. 23712 (X'5CA0')
       CSECT NAMES............... VSAMHAT (ROUTER MODULE)
                  ............... VSAMQCT (INDEX TEST)
                  ............... VSAMKST (DATA  TEST)
       ENTRY POINT............... VSAMHAT

      ****** NOTE FOR VS2 USERS ******
         IF YOU WISH TO RUN THIS PROGRAM ON A VSAM CATALOG,
         VSAMDIAG MU BE LINKEDITED WITH AUTHORIZATION.
./ ADD NAME=WAITASEC 0101-95030-95030-1140-00030-00026-00000-BC0THOR
                WAITASEC SUBROUTINE

  This subroutine permits the caller to request WAIT state for a
  specified period of time less than 24 hours. Wait state insures the
  caller will not use CPU time for the time interval requested, but
  will remain dormant until the time interval expires. At the end of
  the time specified, the caller returns to active execution.

  To use this subroutine, the caller passes an 8-digit external
  decimal field which contains the requested wait time in hours,
  minutes, seconds, and hundredths of seconds. An example of this
  field (in COBOL) is:

  01 WAIT-TIME.
     05 WAIT-HOURS            PIC 99 VALUE '00'.
     05 WAIT-MINUTES          PIC 99 VALUE '00'.
     05 WAIT-SECONDS          PIC 99 VALUE '05'.
     05 WAIT-HUNDREDTHS       PIC 99 VALUE '00'.

  To call this subroutine:

     CALL 'WAITASEC' USING WAIT-TIME.

  The caller is free to request any desired time greater than zero
  and less than 24 hours. If the time field is non-numeric, zero,
  greater than 24 hours, or if the hours field is greater than 23,
  the minutes field is greater than 59, or the seconds field is
  greater than 59, the field is considered to be unusable, and a
  five-second time interval is used. The caller is not informed of
  this, and return code from this subroutine is always zero.
./ ADD NAME=WHEREAMI 0100-93301-93301-0917-00029-00029-00000-USER02
The WHEREAMI subroutine can be called by any program in which it is
statically linked in order to determine whether the caller is running
above or below the 16-megabyte line. The caller passes the address of
a one-byte field which, on return, will contain the letter "A" if the
program is running above the 16-megabyte line, or the letter "B" if
below the 16-megabyte line.

Linkedit requirement: in order to guarantee accuracy, this subroutine
must be statically linkedited with the calling program.

Programming requirements: caller must define and pass a one-byte field
to contain the indicator and pass it in the call to WHEREAMI:

WORKING-STORAGE SECTION.
01  MISCELLANEOUS-FIELDS.
    05  ABOVE-BELOW-INDICATOR            PIC X VALUE ' '.
        88 ABOVE-THE-LINE                VALUE 'A'.
        88 BELOW-THE-LINE                VALUE 'B'.

PROCEDURE DIVISION.
    CALL 'WHEREAMI' USING ABOVE-BELOW-INDICATOR.
    IF ABOVE-THE-LINE
        DISPLAY 'RUNNING ABOVE THE LINE'
    ELSE
        IF BELOW-THE-LINE
            DISPLAY 'RUNNING BELOW THE LINE'
        ELSE
            DISPLAY 'ERROR IN CODE RETURNED BY WHEREAMI'
            CALL 'COBABEND'.
